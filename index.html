<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>8Bit’s Adventure</title>
  <link rel="icon" type="image/png" href="favicon.png" />
  <!-- Google Font: Press Start 2P -->
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet" />
  <style>
    body {
      background: #333;
      color: white;
      font-family: "Press Start 2P", sans-serif;
      text-align: center;
      margin: 0;
    }
    canvas {
      background: #737373;
      display: block;
      margin: 2em auto;
      border: 2px solid white;
    }
    #game-hud {
      position: fixed;
      bottom: 0;
      left: 0;
      width: 100%;
      background-color: #002591;
      color: white;
      display: flex;
      justify-content: space-around;
      align-items: center;
      padding: 10px;
      box-sizing: border-box;
      border-top: 2px solid black;
    }
    .hud-section {
      text-align: center;
      padding: 0 1em;
    }
    #player-status {
      display: flex;
      align-items: center;
      gap: 10px;
    }
    #hp-bar-container {
      width: 150px;
      height: 20px;
      background-color: #555;
      border: 1px solid white;
      position: relative;
    }
    #hp-bar {
      width: 100%;
      height: 100%;
      background-color: #00FF00;
      transition: width 0.5s linear;
    }
    #hp-text {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 0.8em;
      text-shadow: 1px 1px 2px black;
    }
    #battle-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.8);
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      display: none;
      z-index: 2000;
    }
    #enemy-display {
      background-color: #555;
      padding: 20px;
      border: 2px solid white;
      margin-bottom: 20px;
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      justify-content: center;
    }
    #enemy-display button {
      background-color: #333;
      color: white;
      border: 1px solid white;
      cursor: pointer;
      padding: 10px;
      font-family: "Press Start 2P", sans-serif;
      min-width: 100px;
      user-select: none;
    }
    #enemy-display button.selected {
      border: 2px solid red;
      background-color: #555;
    }
    #battle-controls button {
      font-family: "Press Start 2P", sans-serif;
      padding: 10px 20px;
      cursor: pointer;
      margin: 5px;
    }
    #player-battle-status {
      background-color: #002591;
      color: white;
      border: 2px solid black;
      padding: 10px;
      margin-top: 20px;
      width: 250px;
      text-align: left;
    }
    #player-battle-status p {
      margin: 0;
      font-size: 1em;
      user-select: none;
    }
    #player-battle-status .hp-bar-container {
      width: 100%;
      height: 15px;
      background-color: #555;
      border: 1px solid white;
      position: relative;
      margin: 8px 0;
    }
    #player-battle-status .hp-bar {
      height: 100%;
      background-color: #00FF00;
    }
    #stats {
      position: relative;
      user-select: none;
    }
    .stats-popup {
      position: absolute;
      bottom: 100%;
      left: 0;
      width: 200px;
      background-color: #002591;
      border: 2px solid black;
      padding: 10px;
      color: white;
      text-align: left;
      z-index: 1000;
      font-size: 0.75em;
      line-height: 1.2em;
    }
    .enemy-target.stunned {
  filter: grayscale(100%);
  opacity: 0.6;
}
    .enemy-target.shielded {
  box-shadow: 0 0 10px 10px rgba(0, 150, 255, 0.8);
  border-color: #0096ff;
}
    .enemy-target.poisoned {
  box-shadow: 0 0 10px 10px rgba(0, 120, 0, 0.8);
  border-color: #007800;
}
    .enemy-target.enraged {
  box-shadow: 0 0 10px 10px rgba(255, 0, 0, 0.8);
  border-color: #FF0000;
}
    #player-battle-status .hp-bar-container:last-of-type .hp-bar {
      background-color: #00FFFF;
    }
    #player-battle-status .hp-text {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 0.7em;
      text-shadow: 1px 1px 2px black;
      user-select: none;
    }
    /* Settings HUD section (align with other hud sections) */
/* Settings popup: behave like other HUD popups (absolute inside HUD) */
#game-hud { position: fixed; bottom: 0; left: 0; right: 0; z-index: 2000; } /* keep existing */
#game-hud .hud-section#settings { text-align: center; padding: 0 1em; }

/* Match other popups: position absolute and anchored under the HUD item */
#settings-popup {
  display: none;
  position: absolute;       /* same stacking as stats/party popups */
  bottom: 46px;             /* sits above the HUD bar (adjust if your HUD height differs) */
  left: 50%;
  transform: translateX(-50%);
  width: 280px;
  max-height: 380px;
  overflow-y: auto;
  background-color: #002591;
  color: white;
  border: 2px solid black;
  padding: 10px;
  box-sizing: border-box;
  z-index: 3000;
  font-size: 11px;
  box-shadow: 0 6px 12px rgba(0,0,0,0.6);
}

/* Keep same button visuals as HUD */
#settings-popup .item-use-button { font-family:"Press Start 2P",sans-serif; font-size:0.7em; padding:6px 8px; margin:2px 0; cursor:pointer; background:#2b2b2b; border:2px solid white; color:white; }
#settings-popup .item-use-button:hover { background:#0060ff; }

/* compact select tooltip target spacing */
.settings-row { margin:8px 0; display:flex; align-items:center; justify-content:space-between; gap:8px; }
.settings-row label { font-size:10px; display:block; flex:1 1 auto; text-align:left; }
.settings-row .control { flex:0 0 auto; }

/* small tooltip style (used by JS fallback if needed) */
.settings-tooltip {
  font-size:10px;
  color:#ddd;
  margin-top:6px;
  background: rgba(0,0,0,0.2);
  padding:6px;
  border-radius:4px;
}

    /* Inventory styling */
    #inventory-list {
      display: flex;
      flex-direction: row;
      gap: 10px;
      flex-wrap: wrap;
      justify-content: flex-start;
      max-height: 250px;
      overflow-y: auto;
    }
    .inventory-item {
      display: flex;
      flex-direction: column;
      padding: 5px;
      border: 1px solid #555;
      border-radius: 3px;
      background-color: #55260e;
      color: white;
      min-width: 90px;
      user-select: none;
    }
    .inventory-popup {
      display: none;
      position: absolute;
      bottom: 200px;
      right: 100px;
      width: 250px;
      max-height: 300px;
      background-color: #55260e;
      border: 2px solid black;
      color: white;
      padding: 10px;
      text-align: left;
      overflow-y: auto;
      z-index: 1000;
      font-size: 0.75em;
    }
    .item-use-button {
      font-family: "Press Start 2P", sans-serif;
      font-size: 0.7em;
      padding: 2px 5px;
      cursor: pointer;
      margin-top: 5px;
      align-self: flex-start;
      background-color: #333;
      border: 1px solid white;
      color: white;
      user-select: none;
    }
    .item-use-button:hover {
      background-color: #555;
    }
    /* Target Practice - target styles */
.tp-target {
  position: absolute;
  width: 64px;
  height: 64px;
  border-radius: 8px;
  display:flex;
  align-items:center;
  justify-content:center;
  cursor: pointer;
  user-select: none;
  box-shadow: 0 6px 12px rgba(0,0,0,0.6);
  transition: transform 0.08s ease;
}
    #slapjack-overlay .item-use-button { font-family: "Press Start 2P", sans-serif; padding:6px 8px; border:2px solid white; background:#333; color:white; cursor:pointer; }
#slapjack-overlay .item-use-button:disabled { opacity:0.5; pointer-events:none; }

.tp-target:active { transform: scale(0.92); }
.tp-target.normal { background: radial-gradient(circle at 30% 30%, #fff, #ffcccc 30%, #dd3333 60%); border:2px solid #fff; }
.tp-target.golden { background: radial-gradient(circle at 30% 30%, #fff9d6, #ffd24d 40%, #ffb400 70%); border:2px solid #fff2a8; width:72px; height:72px; }
.tp-target-label { font-size:12px; color:#000; font-weight:bold; text-shadow:1px 1px 0 rgba(255,255,255,0.2); pointer-events:none; }

    #battle-blackout {
  display: none;
  position: fixed;
  inset: 0;
  z-index: 2500; /* above canvas but can be below battle UI if you want */
  background: black;
  pointer-events: none; /* doesn't block clicks unless you want it to */
}
    #game-over-overlay {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-color: rgba(0, 0, 0, 0.8);
  display: flex;
  justify-content: center;
  align-items: center;
  text-align: center;
  z-index: 2000;
}

.game-over-content {
  color: white;
  font-family: "Press Start 2P", sans-serif;
}

    /* Save and Load buttons styling */
    #game-hud button {
      font-family: "Press Start 2P", sans-serif;
      padding: 8px 15px;
      cursor: pointer;
      background-color: #2b2b2b;
      border: 2px solid white;
      color: white;
      user-select: none;
      transition: background-color 0.3s ease;
    }
    #game-hud button:hover {
      background-color: #0060ff;
    }
  </style>
</head>
<body>
  <!-- Title screen overlay -->
<div id="title-screen" style="position:fixed;inset:0;display:flex;align-items:center;justify-content:center;background:#001a33;z-index:3000;">
  <div style="text-align:center;color:white;">
    <h1 style="font-family:'Press Start 2P',sans-serif;margin-bottom:20px;">8-Bit's Adventure</h1>
    <button id="play-button" style="font-family:'Press Start 2P',sans-serif;padding:12px 20px;font-size:14px;cursor:pointer;">Play</button>
  </div>
</div>

  <canvas id="game" width="640" height="480" tabindex="0"></canvas>

  <div id="game-hud">
  <div class="hud-section" id="stats">
    <p id="stats-button">Stats</p>
    <div id="stats-popup" class="stats-popup" style="display: none;">
      <h4>Player Stats</h4>
      <p>Level: <span id="popup-level"></span></p>
      <p>XP: <span id="popup-xp"></span></p>
      <p>Damage: <span id="popup-damage"></span></p>
    </div>
  </div>

  <div class="hud-section" id="player-status">
    <p> </p>
    <div id="hp-bar-container">
      <div id="hp-bar"></div>
      <div id="hp-text">16/16</div>
    </div>
  </div>

  <div class="hud-section" id="party">
    <p id="party-button">Party</p>
    <div id="party-popup" class="stats-popup" style="display: none;">
      <h4>Party</h4>
      <div id="party-list"></div>
      <div style="margin-top:8px;">
        <button id="equip-ally-button" class="item-use-button">Equip Selected Ally</button>
      </div>
    </div>
  </div>

  <div class="hud-section" id="inventory">
    <p id="inventory-button">Inventory</p>
    <div id="inventory-popup" class="stats-popup" style="display: none;">
      <h4>Inventory</h4>
      <div id="general-inventory-list"></div>
    </div>
  </div>

    <div class="hud-section" id="achievements">
  <p id="achievements-button">Achievements</p>
  <div id="achievements-popup" class="stats-popup" style="display:none; max-height: 300px; overflow-y:auto;">
  </div>
</div>

  <div class="hud-section" id="settings">
    <p id="settings-button">Settings</p>
    <div id="settings-popup" class="stats-popup" style="display:none; width:280px;">
      <h4>Settings</h4>

      <div style="margin:8px 0;">
        <label style="display:block; font-size:10px;">Difficulty</label>
        <select id="difficulty-select" style="width:100%; font-family:'Press Start 2P',sans-serif;">
          <option value="normal">Normal</option>
          <option value="hard">Hard</option>
          <option value="hard">Extreme</option>
          <option value="ultimate">Ultimate</option>
        </select>
      </div>

      <div style="margin:8px 0;">
  <label style="display:block; font-size:10px;">Mobile Mode</label>
  <input id="toggle-mobile-mode" type="checkbox" /> Enable Mobile Controls
</div>

      <div style="margin:8px 0;">
        <label style="display:block; font-size:10px;">Show Zones & Walls</label>
        <input id="toggle-zones" type="checkbox" /> Show debug outlines
      </div>

      <div style="margin:8px 0;">
        <label style="display:block; font-size:10px;">Save Slots</label>
        <div style="display:flex; gap:6px;">
          <button id="save-slot-1" class="item-use-button">Save 1</button>
          <button id="load-slot-1" class="item-use-button">Load 1</button>
        </div>
        <div style="display:flex; gap:6px; margin-top:6px;">
          <button id="save-slot-2" class="item-use-button">Save 2</button>
          <button id="load-slot-2" class="item-use-button">Load 2</button>
        </div>
        <div style="display:flex; gap:6px; margin-top:6px;">
          <button id="save-slot-3" class="item-use-button">Save 3</button>
          <button id="load-slot-3" class="item-use-button">Load 3</button>
        </div>
      </div>
    </div>
  </div>
</div>


  <div id="battle-overlay">
    <div id="enemy-display"></div>
    <div id="player-battle-status"></div>
    <div id="battle-controls">
      <button id="attack-button">Attack</button>
      <button id="special-attack-button-1">Extra Credits (100 STM)</button>
      <button id="special-attack-button-2">Plasma Blast (200 STM)</button>
      <button id="inventory-battle-button">Inventory</button>
    </div>
    <div id="inventory-battle-popup" class="inventory-popup" style="display: none;">
      <h4>Inventory</h4>
      <div id="inventory-list"></div>
    </div>
    </div>
      <div id="dialog-overlay" style="display:none; position:fixed; inset:0; z-index:2500;
     background:rgba(0,0,0,0.6); align-items:flex-end; justify-content:center; padding:20px;">
  <div id="dialog-box" style="background:#002591; color:white; border:2px solid black;
       padding:16px; max-width:640px; font-family:'Press Start 2P',sans-serif;">
    <div id="dialog-text" style="white-space:pre-wrap; font-size:12px; line-height:1.2;"></div>
    <div style="text-align:right; margin-top:8px;">
      <button id="dialog-next" style="font-family:'Press Start 2P',sans-serif; padding:8px 12px;">Next</button>
    </div>
  </div>
</div>

<div id="password-popup" style="display:none; position:fixed; inset:0; z-index:3000; background:rgba(0,0,0,0.8);">
  <div style="display:flex; flex-direction:column; justify-content:center; align-items:center; height:100%;">
    <div style="background:#002591; padding:20px; border:2px solid black; font-family:'Press Start 2P',sans-serif; color:white; width:300px; text-align:center;">
      <p>Enter 4-digit code:</p>
      <input id="password-input" type="password" maxlength="4" style="font-size:20px; text-align:center; width:100px;" />
      <div style="margin-top:15px;">
        <button id="password-submit" style="font-family:'Press Start 2P',sans-serif; padding:8px 12px; cursor:pointer;">Submit</button>
        <button id="password-cancel" style="font-family:'Press Start 2P',sans-serif; padding:8px 12px; cursor:pointer; margin-left:10px;">Cancel</button>
      </div>
      <p id="password-message" style="color:#ff4444; margin-top:10px; height:18px;"></p>
    </div>
  </div>
</div>
  
<div id="target-practice-overlay" style="display:none; position:fixed; inset:0; z-index:4000; background:rgba(0,0,0,0.85); align-items:center; justify-content:center;">
  <div id="target-practice-ui" style="width:86vw; max-width:900px; height:86vh; background:#112244; border:2px solid #fff; padding:16px; box-sizing:border-box; display:flex; flex-direction:column; gap:12px; font-family: 'Press Start 2P', sans-serif; color:white;">
    <div style="display:flex; justify-content:space-between; align-items:center;">
      <div style="display:flex; gap:12px; align-items:center;">
        <div style="font-size:13px;">Target Practice</div>
        <div id="tp-timer" style="font-size:12px; background:#000a34; padding:6px 10px; border:1px solid #888;">30</div>
        <div id="tp-score" style="font-size:12px; background:#001a00; padding:6px 10px; border:1px solid #888;">Score: 0</div>
        <div id="tp-goal" style="font-size:12px; padding:6px 10px; border:1px solid #888;">Goal: 0</div>
      </div>
      <div style="display:flex; gap:8px; align-items:center;">
        <button id="tp-restart" class="item-use-button">Restart</button>
        <button id="tp-close" class="item-use-button">Close</button>
      </div>
    </div>
    <div id="tp-playfield" style="flex:1; position:relative; background:linear-gradient(#223355,#112233); border:1px solid #000; overflow:hidden;">
      <!-- targets appended here -->
    </div>
    <div style="display:flex; justify-content:space-between; align-items:center;">
      <div style="font-size:11px;">Attempts left: <span id="tp-attempts">5</span></div>
      <div style="font-size:11px;">Click targets to score</div>
    </div>
  </div>
</div>


  <div id="slot-machine-popup" style="display:none; position:fixed; inset:0; z-index:5000; background:rgba(0,0,0,0.85); flex-direction: column; align-items:center; justify-content:center; font-family:'Press Start 2P', sans-serif; color:white;">
  <div style="background:#002591; border:2px solid black; padding:20px; width:300px; text-align:center; border-radius:8px;">
    <h3>Slot Machine</h3>
    <p>Bet: 5 bolts</p>
    <div style="display:flex; justify-content:center; gap:40px; font-size:48px; user-select:none; margin-bottom:20px;">
      <div id="slot-left">-</div>
      <div id="slot-middle">-</div>
      <div id="slot-right">-</div>
    </div>
    <p id="slot-msg" style="min-height:24px;"></p>
    <button id="slot-play-button" style="font-family:'Press Start 2P',sans-serif; padding:8px 12px; cursor:pointer; margin-bottom:10px;">Play</button>
    <button id="slot-close-button" style="font-family:'Press Start 2P',sans-serif; padding:8px 12px; cursor:pointer;">Close</button>
  </div>
</div>

  <!-- Slap Jack overlay -->
<div id="slapjack-overlay" style="display:none; position:fixed; inset:0; z-index:4100;
background:rgba(0,0,0,0.9); align-items:center; justify-content:center; font-family:'Press Start 2P',sans-serif;">
  <div id="slapjack-ui" style="width:86vw; max-width:760px; height:66vh; background:#112244; border:2px solid #fff; padding:16px; box-sizing:border-box; color:white; display:flex; flex-direction:column; gap:10px;">
    <div style="display:flex; justify-content:space-between; align-items:center;">
      <div>
        <div style="font-size:13px;">Slap Jack</div>
        <div id="sj-status" style="font-size:11px; opacity:0.9;">Wager bolts to play</div>
      </div>
      <div style="display:flex; gap:8px; align-items:center;">
        <div style="font-size:11px;">Your bolts:</div>
        <div id="sj-player-bolts" style="font-size:13px; padding:6px 10px; background:#001a00; border:1px solid #888;">0</div>
      </div>
    </div>

    <div style="display:flex; gap:12px; align-items:center; justify-content:center;">
      <div id="sj-npc-top" style="width:110px; height:90px; background:#333; border:2px solid #555; display:flex; align-items:center; justify-content:center;">NPC 1<br>(Top)</div>
      <div style="display:flex; flex-direction:column; gap:8px; align-items:center;">
        <div id="sj-pile" style="width:220px; height:120px; background:#222; border:2px solid #999; display:flex; align-items:center; justify-content:center; flex-direction:column;">
          <div id="sj-mid-counter" style="font-size:18px;">Pile: 0</div>
          <div id="sj-last-player" style="font-size:11px; opacity:0.8;">Last: —</div>
        </div>
        <div style="display:flex; gap:8px;">
          <div id="sj-npc-left" style="width:90px; height:60px; background:#333; border:2px solid #555; display:flex; align-items:center; justify-content:center;">NPC 3<br>(Left)</div>
          <div id="sj-you" style="width:150px; height:60px; background:#004; border:2px solid #fff; display:flex; align-items:center; justify-content:center; flex-direction:column;">
            <div style="font-size:12px;">You (Bottom)</div>
            <div id="sj-you-counter" style="font-size:11px;">Cards: 0</div>
          </div>
          <div id="sj-npc-right" style="width:90px; height:60px; background:#333; border:2px solid #555; display:flex; align-items:center; justify-content:center;">NPC 2<br>(Right)</div>
        </div>
      </div>
    </div>

    <div style="display:flex; gap:8px; justify-content:center; align-items:center; margin-top:6px;">
      <input id="sj-wager-input" type="number" min="1" value="1" style="width:100px; font-family:'Press Start 2P'; padding:6px;" />
      <button id="sj-lock-wager" class="item-use-button">Lock Wager</button>
      <button id="sj-start" class="item-use-button" disabled>Start</button>
      <button id="sj-slap" class="item-use-button" disabled>SLAP</button>
      <button id="sj-close" class="item-use-button">Close</button>
    </div>

    <div style="font-size:11px; opacity:0.9; text-align:center;">
      Win by collecting 30 cards in your pile. Wrong slap penalizes you (-3 cards).
    </div>
  </div>
</div>


  <!-- Battle blackout overlay (hidden by default) -->
<div id="battle-blackout" style="display:none; position:fixed; inset:0; z-index:2500; background:black; pointer-events:none;"></div>
  
<div id="mobile-controls" style="display:none; position: fixed; bottom: 60px; left: 50%; transform: translateX(-50%); width: 220px; user-select:none; z-index: 3000;">

  <div style="display:flex; justify-content:center; margin-bottom: 6px;">
    <button id="btn-up" style="width: 60px; height: 60px;">▲</button>
  </div>
  <div style="display:flex; justify-content:center; gap: 10px;">
    <button id="btn-left" style="width: 60px; height: 60px;">◄</button>
    <button id="btn-interact" style="width: 60px; height: 60px;">X</button>
    <button id="btn-right" style="width: 60px; height: 60px;">►</button>
  </div>
  <div style="display:flex; justify-content:center; margin-top: 6px;">
    <button id="btn-down" style="width: 60px; height: 60px;">▼</button>
  </div>

</div>
<!-- Must start hidden! -->
<div id="game-over-overlay" style="display: none">
  <div class="game-over-content">
    <h1>Game Over</h1>
    <p>Press 'R' to Restart</p>
  </div>
</div>

  </div>

<script>
console.log('script loaded');

const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');

// Focus canvas for keyboard input
canvas.tabIndex = 0;
canvas.focus();
canvas.addEventListener('click', () => canvas.focus());

// Player and game variables
let isGameOver = false;
let x = 150, y = 50;
const speed = 20;
const imageSize = 60;
const hitboxWidth = 30;
const hitboxHeight = 30;
const hitboxOffsetX = (imageSize - hitboxWidth) / 2;
const hitboxOffsetY = (imageSize - hitboxHeight) / 2;
const useImage = true;
const img = new Image();
img.src = '8bit.png';

const hpBar = document.getElementById('hp-bar');
const hpText = document.getElementById('hp-text');

let selectedEnemyIndex = 0;
let gameFlags = {
  isPowered: false,
  louRecruited: false,
  interactedWithDeadBody: false,
  lightsFixed: false
};


let shownDialogs = new Set();
let _dialogQueue = [];
let removedWallIds = new Set();
let _battleDialogQueue = [];
let _battleDialogPausedState = null;


const zoneSprites = {
  fail: new Image (),
  robot: new Image(),
  bossrobot: new Image()
};
zoneSprites.fail.src = 'fail.png';
zoneSprites.bossrobot.src = 'bossrobot.png';
zoneSprites.robot.src = 'robot.png';

let darkTimerMs = 0;
let darkTimerLimitMs = 30000;
let darkTimerTickInterval = null;
const darkTimerTickMs = 100;
let darkTimerActive = false;

let sliding = false;
let slidingDirection = { dx: 0, dy: 0 };
let slidingIntervalId = null;
const SLIDE_STEP_MS = 120; 


// reuse or create blackout overlay
const progressiveDarkEl = document.getElementById('battle-blackout') || (() => {
  const el = document.createElement('div');
  el.id = 'battle-blackout';
  el.style.position = 'fixed';
  el.style.inset = '0';
  el.style.zIndex = '2500';
  el.style.background = 'black';
  el.style.pointerEvents = 'none';
  el.style.display = 'none';
  document.body.appendChild(el);
  return el;
})();
  

  
let tempText = "";
let tempTextTimeout = null;
let defeatedZone = null;
let enemyAttackIntervalId = null;
const ENEMY_ATTACK_DELAY = 2000;
let staminaRegenIntervalId = null;
let inventory = new Map();
let extraLifeTimerId = null;
let battleRounds = 0;                // number of rounds remaining
let currentRoundEncounters = [];     // array of rounds (each round = array of enemy defs)
let currentRoundIndex = 0;           // index of current round

  const armorTypes = {
  retro: { name: "Retro Armor", hpBonus: 0.10, passiveHealPercent: 0 },
  v8:    { name: "V8 Armor", hpBonus: 0.20, passiveHealPercent: 0 },
  saloon:{ name: "Saloon Armor", hpBonus: 0.40, passiveHealPercent: 0.02 },
  haunted:{name: "Haunted Armor", hpBonus: 0.30, passiveHealPercent: 0, blockChance: 0.15 }, // 15% chance to block
  virus: { name: "Virus Armor", hpBonus: 0.50, passiveHealPercent: 0 }
};

const weaponTypes = {
  retro: { name: "Retro Weapon", dmgBonus: 0.10 },
  v8:    { name: "V8 Weapon", dmgBonus: 0.20 },
  saloon:{ name: "Saloon Weapon", dmgBonus: 0.15 },
  haunted:{name: "Haunted Weapon", dmgBonus: 0.25 },
  virus: { name: "Virus Weapon", dmgBonus: 0.50 }
};

  let equippedArmor = null;  // e.g. "retro", "v8", etc.
let equippedWeapon = null; // e.g. "retro", "virus", etc.

function applyEquipmentBonuses() {
  // read base stats (never mutated by this function)
  const baseMaxHp = playerStats.baseMaxHp;
  const baseDamage = playerStats.baseDamage;

  // Armor bonus to max HP (percentage)
  let armorBonusHp = 0;
  if (equippedArmor && armorTypes[equippedArmor]) {
    armorBonusHp = Math.floor(baseMaxHp * armorTypes[equippedArmor].hpBonus);
  }

  // Weapon bonus to damage (percentage)
  let weaponBonusDmg = 0;
  if (equippedWeapon && weaponTypes[equippedWeapon]) {
    weaponBonusDmg = Math.floor(baseDamage * weaponTypes[equippedWeapon].dmgBonus);
  }

  // compute final stats (idempotent)
  playerStats.maxHp = baseMaxHp + armorBonusHp;
  playerStats.damage = baseDamage + weaponBonusDmg;

  // clamp current HP to max (preserve relative HP percentage)
  if (playerStats.currentHp > playerStats.maxHp) {
    playerStats.currentHp = playerStats.maxHp;
  }

  updateHp(playerStats.currentHp);
  updateStatsPopup();
}

  
// Initialize inventory with items
inventory.set("bandaid", 1);
inventory.set("emp_grenade", 1);
inventory.set("poison_vial", 1);
inventory.set("extra_life", 1);
inventory.set("driftwood", 1);

inventory.set("bolts", 20);
  
inventory.set("hammer", 0);
inventory.set("laser_cutter", 0);
inventory.set("raft", 0);
inventory.set("keycard", 0);
inventory.set("gas_mask", 0);
inventory.set("drill", 1);
inventory.set("torch", 0);
inventory.set("ice_boots", 0);
  
inventory.set("armor_retro", 0);
inventory.set("armor_v8", 0);
inventory.set("armor_saloon", 1);
inventory.set("armor_haunted",1);
inventory.set("armor_virus", 0);

inventory.set("weapon_retro", 0);
inventory.set("weapon_v8", 0);
inventory.set("weapon_saloon", 1);
inventory.set("weapon_haunted", 1);
inventory.set("weapon_virus", 1);

  const ABILITIES = {
  block: { cooldownMs: 10000, effectMs: 1000 },  
  counter: { cooldownMs: 8000, windowMs: 700, stunMs: 3000 }, 
  cleanse: { cooldownMs: 15000 }                 
};

  let abilityCooldowns = {
  block: 0, 
  counter: 0,
  cleanse: 0
};
let abilityRegenIntervalId = null;
let blockActive = false;
let counterWindowActive = false;
  
let playerStats = {
  level: 1,
  currentHp: 16,
  maxHp: 16,
  damage: 2,
  xp: 0,
  xpToNextLevel: 10,
  currentStamina: 50,
  maxStamina: 200,

  baseMaxHp: 16,
  baseDamage: 2
};
const alliesData = [
  { id: 'ally1', name: 'Lou', baseMaxHp: 30, baseDamage: 3, attackIntervalMs: 1700, level: 1, xp: 0, xpToNextLevel: 10 },
  { id: 'ally2', name: 'Buzz', baseMaxHp: 58, baseDamage: 4, attackIntervalMs: 2200, level: 1, xp: 0, xpToNextLevel: 10 },
  { id: 'ally3', name: 'Colt', baseMaxHp: 23, baseDamage: 6, attackIntervalMs: 3000, level: 1, xp: 0, xpToNextLevel: 10 },
  { id: 'ally4', name: 'Otis', baseMaxHp: 45, baseDamage: 4, attackIntervalMs: 2000, level: 1, xp: 0, xpToNextLevel: 10 },
  { id: 'ally5', name: 'Janet', baseMaxHp: 40, baseDamage: 3, attackIntervalMs: 1500, level: 1, xp: 0, xpToNextLevel: 10 },
  { id: 'ally6', name: 'Max', baseMaxHp: 36, baseDamage: 4, attackIntervalMs: 1000, level: 1, xp: 0, xpToNextLevel: 10 },
];

let unlockedAllies = new Set();  // Track unlocked ally IDs
let equippedAllyId = null;       // Currently equipped ally ID or null
let activeAlly = null;           // Ally battle state (HP etc)
let allyAttackTimerId = null;    // Timer for ally attacks

let inBattle = false;

const enemyTypes = {
  Dummy: { name: "Dummy", maxHp: 32, damage: 1, xpReward: 3, behavior: "normalAttack" },
  Botling: { name: "Botling", maxHp: 10, damage: 1, xpReward: 2, behavior: "normalAttack" },
  Sniperbot: { name: "Sniper", maxHp: 50, damage: 1, xpReward: 5, behavior: "sniperAttack" },
  Puncherbot: { name: "Puncher", maxHp: 90, damage: 1, xpReward: 5, behavior: "normalAttack" },
  Mousebot: { name: "Quickbot", maxHp: 75, damage: 2, xpReward: 5, behavior: "normalAttack" },
  BossBot: { name: "BossRobot", maxHp: 100, damage: 4, xpReward: 50, isBoss: true, behavior: "bossBehavior", defaultResistances: {stun: true, poison:true }},
  Summoner: { name: "Factory", maxHp: 80, damage: 0, xpReward: 20, behavior: "summonerBehavior" },
  SecondStageBossStage1: { name: "The Works Plant", maxHp: 50, damage: 3, xpReward: 0, behavior: "secondStageBossBehavior", secondStageType: "SecondStageBossStage2" },
  SecondStageBossStage2: { name: "The Heated Works Plant", maxHp: 200, damage: 6, xpReward: 50, behavior: "factoryBehavior" },
  Healer: { name: "Barbot", maxHp: 35, damage: 1, xpReward: 15, behavior: "healerBehavior" },
  IceBoss: { name: "Frozen Metal", maxHp: 100, damage: 6, xpReward: 1, behavior: "iceBossBehavior", isBoss: true, defaultResistances: {stun: true, poison:true }},
  LifeStealBoss: { name: "Soul Slasher", maxHp: 100, damage: 5, xpReward: 1, behavior: "lifeStealBossBehavior", isBoss: true, defaultResistances: {stun: true, poison:true }},
  CritBoss: { name: "Deadshot", maxHp: 100, damage: 7, xpReward: 1, behavior: "critBossBehavior", isBoss: true, defaultResistances: {stun: true, poison:true }},
  CaveBoss: { name: "Stoneforce", maxHp: 200, damage: 4, xpReward: 150, isBoss: true, behavior: "caveBossBehavior", defaultResistances: { stun: true, poison: true }},
  CrystalShard: { name: "Crystal Shard", maxHp: 5, damage: 2, xpReward: 1, behavior: "normalAttack" },
  MountainBoss: { name: "Autoyvern", maxHp: 250, damage: 1, xpReward: 200, behavior: "mountainBossBehavior", isBoss: true, defaultResistances: {stun: true, poison:true }},
  GhostBoss: { name: "The Maestro", maxHp: 450, damage: 3, xpReward: 150, behavior: "ghostBossBehavior", isBoss: true, defaultResistances: {stun: true, poison:true }},
  Train: { name: "Train Carriage", maxHp: 40, damage: 0, xpReward: 0, behavior: "normalAttack"},
  SpectralMinion: { name: "Spirit", maxHp: 12, damage: 3, xpReward: 1, behavior: "normalAttack" },
  IslandBoss: { name: "Nekark of the Seas", maxHp: 320, damage: 3, xpReward: 180, behavior: "islandBossBehavior", isBoss: true, defaultResistances: { stun: true, poison: true }},
  Roboworker: { name: "Roboworker", maxHp: 8, damage: 2, xpReward: 0, behavior: "normalAttack" },
  LifeCore: { name: "Life Core", maxHp: 80, damage: 0, xpReward: 0, behavior: "lifeCoreBehavior" },
  FinalBossStage1: { name: "Dark Lord Spike", maxHp: 420, damage: 4, xpReward: 100, behavior: "finalBossStage1Behavior", defaultResistances: { stun: true, poison: true }},
  FinalBossStage2: { name: "Dark Lord Spike", maxHp: 20, damage: 6, xpReward: 180, behavior: "finalBossStage2Behavior", defaultResistances: { stun: true, poison: true }},
  FinalBossStage3: { name: "Corruptus Caliginis Aeternae", maxHp: 1000, damage: 5, xpReward: 300, behavior: "finalBossStage3Behavior", defaultResistances: { stun: true, poison: true }},
  Eye: { name: "Watcher Eye", maxHp: 220, damage: 8,  xpReward:  80, behavior: "normalAttack", defaultResistances: { poison: true } },
  ShadowOrb: { name: "Shadow Orb", maxHp:  60, damage: 2,  xpReward:   5, behavior: "shadowOrbBehavior", defaultResistances: {} },
  LightOrb: { name: "Light Orb", maxHp:  40, damage: 0,  xpReward:   8, behavior: "lightOrbBehavior", defaultResistances: {} }

};


  // want multiple rounds? just do comma may or may not be needed at the end {
    //x: 507, y: 70, width: 64, height: 64,
    //encounter: [
      //[ { type: "Sniperbot" }, { type: "Sniperbot" } ], // round 1
      //[ { type: "Puncherbot" }, { type: "Sniperbot" } ]   // round 2
    //],
    //sprite: 'fail'
  //}
  
const levels = [
  {
    bgSrc: "arcadebg.png",
    walls: [
      { x: 0, y: 0, width: 640, height: 20 },
      { x: 0, y: 460, width: 640, height: 20 },
      { x: 290, y: 150, width: 32, height: 200 },
      { x: 290, y: 150, width: 220, height: 20 },
      { x: 500, y: 150, width: 20, height: 200 },
      { x: 0, y: 0, width: 20, height: 480 },
      { x: 290, y: 350, width: 85, height: 15 },
      { x: 450, y: 350, width: 50, height: 15 },
    ],
    doors: [
      { x: 375, y: 340, width: 85, height: 10, destLevel: 1, destX: 300, destY: 375 },
      { x: 620, y: 0, width: 20, height: 480, destLevel: 2, destX: 40, destY: 40 }
    ],
    darkZones: [],
    battleZones: [],
    dialogZones: [],
    interactables: []
  },
  {
    bgSrc: "arcadeinside.png",
    walls: [
      { x: 0, y: 0, width: 640, height: 70 },
      { x: 608, y: 0, width: 32, height: 480 },
      { x: 0, y: 0, width: 50, height: 480 },
      { x: 400, y: 300, width: 100, height: 100},
    ],
    doors: [
      { x: 0, y: 460, width: 640, height: 20, destLevel: 0, destX: 400, destY: 400 }
    ],
    battleZones: [],
    dialogZones: [
  {
    id: 'enter_arcade',
    x: 0, y: 0, width: 640, height: 480,
    text: ["The arcade! Always been my source of comfort.", "It's a little broken down, though."],
    autoShow: true,
    style: 'dialog',
    speaker: '8-Bit'
  }
],
    interactables: [
      { name: "power_box", x: 20, y: 260, width: 100, height: 100, action: "power_on" },
      { name: "arcade_machine", x: 340, y: 80, width: 100, height: 100, action: "start_battle", encounter: [{ type: "Dummy" }] },
      { name: "steel_block", x: 400, y: 300, width: 100, height: 100, action: "break", requiredItem: "laser_cutter" },
      { name: "hammer", x: 150, y: 300, width: 32, height: 32, action: "pickup", itemName: "hammer"},
      { id: "door1", name: "door", x: 535, y: 410, width: 40, height: 40, action: "open_door", destLevel: 11, destX: 480, destY: 410 },
      { name: "security_panel", x: 500, y: 100, width: 40, height: 40, action: "open_door", requiresKeycard: true, destLevel: 2, destX: 50, destY: 50 },
      { id: "chest_001", name: "wooden_chest", x: 220, y: 220, width: 64, height: 64, action: "chest",
    rewards: [["bandaid",2], ["emp_grenade",1], ["extra_life",1]], opened: false }
    ]
  },
  {
    bgSrc: "arcadeA2.png",
    walls: [
      { x: 0, y: 460, width: 640, height: 20 },
      { x: 620, y: 0, width: 20, height: 220 },
      { x: 580, y: 250, width: 64, height: 64 },
      { x: 0, y: 150, width: 500, height: 70},
      { x: 615, y: 335, width: 25, height: 200},
    ],
    doors: [
      { x: 0, y: 0, width: 20, height: 150, destLevel: 0, destX: 550, destY: 400 },
      { x: 50, y: 0, width: 50, height: 20, destLevel: 3, destX: 50, destY: 400 },
      { x: 100, y: 0, width: 50, height: 20, destLevel: 3, destX: 100, destY: 400 },
      { x: 150, y: 0, width: 50, height: 20, destLevel: 3, destX: 150, destY: 400 },
      { x: 200, y: 0, width: 50, height: 20, destLevel: 3, destX: 200, destY: 400 },
      { x: 250, y: 0, width: 50, height: 20, destLevel: 3, destX: 250, destY: 400 },
      { x: 300, y: 0, width: 50, height: 20, destLevel: 3, destX: 300, destY: 400 },
      { x: 350, y: 0, width: 50, height: 20, destLevel: 3, destX: 350, destY: 400 },
      { x: 400, y: 0, width: 50, height: 20, destLevel: 3, destX: 400, destY: 400 },
      { x: 450, y: 0, width: 50, height: 20, destLevel: 3, destX: 450, destY: 400 },
      { x: 500, y: 0, width: 50, height: 20, destLevel: 3, destX: 500, destY: 400 },
      { x: 550, y: 0, width: 50, height: 20, destLevel: 3, destX: 550, destY: 400 },
      { x: 600, y: 0, width: 40, height: 20, destLevel: 3, destX: 600, destY: 400 },
      { x: 0, y: 200, width: 20, height: 240, destLevel: 13, destX: 580, destY: 240 }
    ],
     battleZones: [
      { x: 530, y: 80, width: 64, height: 64, encounter: [{ type: "Sniperbot" }], sprite: 'fail' },
      { x: 240, y: 315, width: 64, height: 64, encounter: [{ type: "Sniperbot" }, {type: "Sniperbot"}], sprite: 'fail'},
],
    waterZones: [], // make something like { x: 0, y: 0, width: 1, height: 1 } for zones
  poisonZones: [],
    dialogZones: [
  {
    id: 'encounter_enemies',
    x: 0, y: 0, width: 640, height: 480,
    text: ["Oh, wow. There's robots around.", "I wonder if they're hostile. Maybe I should ask them what happened?"],
    autoShow: true,
    style: 'dialog',
    speaker: '8-Bit'
  },
      {
    id: 'after_first_battle',
    x: 520, y: 170, width: 120, height: 70,
    text: ["Okay, something's definitely up.", "After all, I did wake up to a wasteland.", "Wait, how long was I out for?", "It can't be a few years, I mean, I hope..."],
    autoShow: true,
    style: 'dialog',
    speaker: '8-Bit'
      }
],
    interactables: [
      { name: "big_stone", x: 580, y: 250, width: 64, height: 64, interactRect: { x: 560, y: 230, width: 120, height: 96 }, action: "break", requiredItem: "hammer" },
      {
  id: 'lever_group_a_1',
  action: 'lever',
  leverType: 'multi',
  groupId: 'A',
  indexInGroup: 0,
  initialState: false,
  x: 200, y: 120, width: 32, height: 32
},
      {
  action: 'lever',
  leverType: 'single',
  linkedWallId: 'wall_id_2',
  linkedLevelIndex: 3,
  x: 100,
  y: 100,
  width: 16,
  height: 16
},
{
  id: 'lever_group_a_2',
  action: 'lever',
  leverType: 'multi',
  groupId: 'A',
  indexInGroup: 1,
  initialState: false,
  x: 240, y: 120, width: 32, height: 32
},
{
  id: 'lever_group_a_3',
  action: 'lever',
  leverType: 'multi',
  groupId: 'A',
  indexInGroup: 2,
  initialState: false,
  x: 280, y: 120, width: 32, height: 32
},
{
  id: 'lever_group_a_controller',
  name: 'lever_group_controller',
  action: 'lever_controller',
  groupId: 'A',
  targetCombo: [true, true, false],
  linkedWallId: 'wall_multi_a_1',
  x: 0, y: 0, width: 16, height: 16
}
    ]
  },
  { bgSrc: "arcadeB2_3.png",
    walls: [
      { id: 'wall_multi_a_1', x: 300, y: 150, width: 32, height: 120 },
      { id: 'wall_id_2', x: 500, y: 150, width: 32, height: 120 },
      { x: 0, y: 0, width: 640, height: 20 },
      { x: 0, y: 0, width: 20, height: 480 },
      { x: 620, y: 0, width: 20, height: 480},
      { x: 0, y: 160, width: 315, height: 20},
      { x: 460, y: 160, width: 220, height: 20},
    ],
    doors: [
      { x: 0, y: 460, width: 50, height: 20, destLevel: 2, destX: 50, destY: 50 },
      { x: 50, y: 460, width: 50, height: 20, destLevel: 2, destX: 100, destY: 50 },
      { x: 100, y: 460, width: 50, height: 20, destLevel: 2, destX: 150, destY: 50 },
      { x: 150, y: 460, width: 50, height: 20, destLevel: 2, destX: 200, destY: 50 },
      { x: 200, y: 460, width: 50, height: 20, destLevel: 2, destX: 250, destY: 50 },
      { x: 250, y: 460, width: 50, height: 20, destLevel: 2, destX: 300, destY: 50 },
      { x: 300, y: 460, width: 50, height: 20, destLevel: 2, destX: 350, destY: 50 },
      { x: 350, y: 460, width: 50, height: 20, destLevel: 2, destX: 400, destY: 50 },
      { x: 400, y: 460, width: 80, height: 20, destLevel: 2, destX: 450, destY: 50 },
      { x: 450, y: 460, width: 50, height: 20, destLevel: 2, destX: 500, destY: 50 },
      { x: 500, y: 460, width: 50, height: 20, destLevel: 2, destX: 550, destY: 50 },
      { x: 550, y: 460, width: 50, height: 20, destLevel: 2, destX: 550, destY: 50 },
      { x: 600, y: 460, width: 40, height: 20, destLevel: 2, destX: 600, destY: 50 }
    ],
    darkZones: [],
iceZones: [],
    battleZones: [
      { x: 507, y: 70, width: 64, height: 64, encounter: [{ type: "Sniperbot" }, {type: "Sniperbot"}], sprite: 'fail' },
      { x: 240, y: 60, width: 80, height: 80, encounter: [{ type: "Sniperbot" }, {type: "Puncherbot"}, {type: "Sniperbot"}], sprite: 'fail'}
    ],
    dialogZones: [
      {
    id: 'enter_B2',
    x: 0, y: 0, width: 640, height: 480,
    text: ["Wow, is that a chest I see?", "What's up with that huge crack on the floor though?"],
    autoShow: true,
    style: 'dialog',
    speaker: '8-Bit'
  }
    ],
    interactables: [
      {
  name: "ground_crack",
  x: 486,
  y: 371,
  width: 64,
  height: 64,
  action: "use_drill",
  destLevel: 4,
  destX: 100,
  destY: 100
},
    
{ name: 'target_board', x: 360, y: 120, width: 96, height: 96, action: 'target_practice' },
{ id: "slap_board_1", name: "slap_board", x: 360, y: 220, width: 96, height: 96, action: "slap_jack" },
{ id: "slot_machine_1", name: "slot_machine", x: 320, y: 180, width: 96, height: 96, action: "slot_machine" },
{ id: "shop1", name: "shop", x: 400, y: 300, width: 50, height: 50, action: "shop" },
      { id: "chest_001", name: "wooden_chest", x: 78, y: 70, width: 64, height: 64, action: "chest",
    rewards: [["bandaid",1], ["emp_grenade",1]], opened: false }
    ]
  },
  {
    bgSrc: "caves1_4.png",
    walls: [
      { x: 0, y: 0, width: 20, height: 480 },
      { x: 0, y: 0, width: 640, height: 20 },
      { x: 0, y: 460, width: 640, height: 20 },
      { x: 0, y: 250, width: 50, height: 230},
    ],
    doors: [
      { x: 100, y: 163, width: 64, height: 64, destLevel: 3, destX: 550, destY: 400 },
      { x: 620, y: 0, width: 20, height: 50, destLevel: 5, destX: 50, destY: 50 },
      { x: 620, y: 50, width: 20, height: 50, destLevel: 5, destX: 50, destY: 100 },
      { x: 620, y: 100, width: 20, height: 50, destLevel: 5, destX: 50, destY: 150 },
      { x: 620, y: 150, width: 20, height: 50, destLevel: 5, destX: 50, destY: 200 },
      { x: 620, y: 200, width: 20, height: 50, destLevel: 5, destX: 50, destY: 250 },
      { x: 620, y: 250, width: 20, height: 50, destLevel: 5, destX: 50, destY: 300 },
      { x: 620, y: 300, width: 20, height: 50, destLevel: 5, destX: 50, destY: 350 },
      { x: 620, y: 350, width: 20, height: 50, destLevel: 5, destX: 50, destY: 350 },
      { x: 620, y: 400, width: 20, height: 80, destLevel: 5, destX: 50, destY: 400 }
    ],
     battleZones: [],
    waterZones: [],
  poisonZones: [],
    dialogZones: [
      {
    id: 'enter_caves1',
    x: 0, y: 0, width: 640, height: 480,
    text: ["Oh, a cave, interesting!", "I wonder what's in store..."],
    autoShow: true,
    style: 'dialog',
    speaker: '8-Bit'
  }
    ],
    interactables: [
      {
  id: 'lou_recruit',
  name: 'lou_recruit',
  x: 100,
  y: 100,
  width: 32,
  height: 32,
  interactRect: { x: 290, y: 190, width: 52, height: 52 },
  action: 'recruit',
  allyId: 'ally1',         
  displayName: 'Lou',
  recruitDialog: [
    { speaker: 'Lou', text: "hey", style: 'lou' },
    { speaker: '8-Bit', text: "eeeee", style: 'dialog' }
  ],
  opened: false
}
    ]
  },
  {
    bgSrc: "caves2_5.png",
    walls: [
      { x: 0, y: 0, width: 640, height: 30 },
      { x: 0, y: 450, width: 640, height: 30 },
      { x: 196, y: 196, width: 444, height: 133 },
    ],
    doors: [
      { x: 0, y: 0, width: 20, height: 50, destLevel: 4, destX: 580, destY: 50 },
      { x: 0, y: 50, width: 20, height: 50, destLevel: 4, destX: 580, destY: 100 },
      { x: 0, y: 100, width: 20, height: 50, destLevel: 4, destX: 580, destY: 150 },
      { x: 0, y: 150, width: 20, height: 50, destLevel: 4, destX: 580, destY: 200 },
      { x: 0, y: 200, width: 20, height: 50, destLevel: 4, destX: 580, destY: 250 },
      { x: 0, y: 250, width: 20, height: 50, destLevel: 4, destX: 580, destY: 300 },
      { x: 0, y: 300, width: 20, height: 50, destLevel: 4, destX: 580, destY: 350 },
      { x: 0, y: 350, width: 20, height: 50, destLevel: 4, destX: 580, destY: 400 },
      { x: 0, y: 400, width: 20, height: 80, destLevel: 4, destX: 580, destY: 400 },
      { x: 620, y: 40, width: 20, height: 160, destLevel: 6, destX: 50, destY: 120 },
      { x: 620, y: 330, width: 20, height: 130, destLevel: 6, destX: 50, destY: 350}
    ],
     battleZones: [
      { x: 530, y: 80, width: 64, height: 64, encounter: [{ type: "Sniperbot" }], sprite: 'fail' },
      { x: 240, y: 315, width: 64, height: 64, encounter: [{ type: "GhostBoss" }, {type: "Sniperbot"}], sprite: 'fail'}
],
    waterZones: [],
  poisonZones: [],
    dialogZones: [
  {
    id: 'test',
    x: 0, y: 0, width: 640, height: 480,
    text: [
      { speaker: '8-Bit', text: "Why am I speaking right now?", style: 'dialog' },
      { speaker: 'Boss',  text: "Author wanted to test some code.", style: 'boss' },
      { speaker: '8-Bit', text: "Oh. Well I hope it works.", style: 'dialog' },
      { speaker: 'Boss',  text: "If you're seeing this, it probably does.", style: 'boss' }
    ],
    autoShow: true,
    style: 'dialog'
  }
      ],
    interactables: []
  },
  {
    bgSrc: "caves3_6.png",
    walls: [
      { x: 0, y: 460, width: 640, height: 20 },
      { x: 620, y: 0, width: 20, height: 480 },
      { x: 0, y: 210, width: 640, height: 115 },
      { x: 360, y: 160, width: 100, height: 40 },
      { x: 447, y: 0, width: 200, height: 250 },
    ],
    doors: [
      { x: 0, y: 0, width: 20, height: 210, destLevel: 5, destX: 580, destY: 100 },
      { x: 0, y: 325, width: 20, height: 160, destLevel: 5, destX: 580, destY: 360 }
    ],
     battleZones: [],
    waterZones: [],
  poisonZones: [],
    dialogZones: [],
    interactables: [
      {
  name: "ground_crack",
  x: 526,
  y: 359,
  width: 64,
  height: 64,
  action: "use_drill",
  destLevel: 8, //temp
  destX: 100,
  destY: 100
}
    ]
  },
  {
    bgSrc: "darkcaves1_7.png",
    walls: [
      { x: 0, y: 0, width: 640, height: 20 },
    ],
    doors: [],
    darkZones: [
      { x: 0, y: 0, width: 640, height: 480 }
    ],
    battleZones: [],
    dialogZones: [],
    interactables: []
  },
  {
    bgSrc: "darkcaves2_8.png",
    walls: [
      { x: 0, y: 0, width: 640, height: 20 },
    ],
    doors: [
      { x: 375, y: 340, width: 85, height: 10, destLevel: 1, destX: 300, destY: 375 },
      { x: 620, y: 0, width: 20, height: 480, destLevel: 2, destX: 40, destY: 40 }
    ],
    darkZones: [
      { x: 0, y: 0, width: 640, height: 480 }
    ],
    battleZones: [
      {
  x: 507,
  y: 70,
  width: 64,
  height: 64,
  encounter: [
    [ { type: "Sniperbot" }, { type: "Sniperbot" } ],
    [ { type: "FinalBossStage1" } ]
  ],
  sprite: 'fail'
}
 //LifeStealBoss, CritBoss, CaveBoss, IceBoss, MountainBoss
    ],
    dialogZones: [],
    interactables: []
  },
  {
    bgSrc: "darkcaves3_9.png",
    walls: [
      { x: 0, y: 0, width: 640, height: 20 },
    ],
    doors: [
      { x: 375, y: 340, width: 85, height: 10, destLevel: 1, destX: 300, destY: 375 },
      { x: 620, y: 0, width: 20, height: 480, destLevel: 2, destX: 40, destY: 40 }
    ],
    darkZones: [
      { x: 0, y: 0, width: 640, height: 480 }
    ],
    battleZones: [],
    dialogZones: [],
    interactables: []
  },
    {
    bgSrc: "darkcaves4_10.png",
    walls: [
      { x: 0, y: 0, width: 20, height: 480 },
    ],
    doors: [
      { x: 375, y: 340, width: 85, height: 10, destLevel: 1, destX: 300, destY: 375 }
    ],
    darkZones: [
      { x: 0, y: 0, width: 640, height: 480 }
    ],
    battleZones: [],
    dialogZones: [],
    interactables: []
  },
  {
    bgSrc: "arcaderoom1_11.png",
    walls: [
      { x: 0, y: 0, width: 40, height: 480 },
      { x: 600, y: 0, width: 40, height: 480 },
      { x: 37, y: 101, width: 300, height: 102 },
      { x: 530, y: 150, width: 70, height: 70 },
      { x: 0, y: 440, width: 640, height: 40 },
    ],
    doors: [
      { x: 0, y: 0, width: 50, height: 20, destLevel: '12', destX: 25, destY: 400 },
  { x: 50, y: 0, width: 50, height: 20, destLevel: '12', destX: 75, destY: 400 },
  { x: 100, y: 0, width: 50, height: 20, destLevel: '12', destX: 125, destY: 400 },
  { x: 150, y: 0, width: 50, height: 20, destLevel: '12', destX: 175, destY: 400 },
  { x: 200, y: 0, width: 50, height: 20, destLevel: '12', destX: 225, destY: 400 },
  { x: 250, y: 0, width: 50, height: 20, destLevel: '12', destX: 275, destY: 400 },
  { x: 300, y: 0, width: 50, height: 20, destLevel: '12', destX: 325, destY: 400 },
  { x: 350, y: 0, width: 50, height: 20, destLevel: '12', destX: 375, destY: 400 },
  { x: 400, y: 0, width: 50, height: 20, destLevel: '12', destX: 425, destY: 400 },
  { x: 450, y: 0, width: 50, height: 20, destLevel: '12', destX: 475, destY: 400 },
  { x: 500, y: 0, width: 50, height: 20, destLevel: '12', destX: 525, destY: 400 },
  { x: 550, y: 0, width: 50, height: 20, destLevel: '12', destX: 575, destY: 400 },
  { x: 600, y: 0, width: 40, height: 20, destLevel: '12', destX: 620, destY: 400 }
    ],
    darkZones: [],
    battleZones: [],
    dialogZones: [],
    interactables: [
      { id: "door2", name: "door", x: 486, y: 311, width: 80, height: 80, action: "open_door", destLevel: 1, destX: 527, destY: 300 }
    ]
  },
  {
    bgSrc: "arcaderoom2_12.png",
    walls: [
      { x: 0, y: 0, width: 40, height: 480 },
      { x: 600, y: 0, width: 40, height: 480 },
      { x: 0, y: 0, width: 640, height: 30 },
    ],
    doors: [
        { x: 0, y: 460, width: 50, height: 20, destLevel: '11', destX: 25, destY: 50 },
  { x: 50, y: 460, width: 50, height: 20, destLevel: '11', destX: 75, destY: 50 },
  { x: 100, y: 460, width: 50, height: 20, destLevel: '11', destX: 125, destY: 50 },
  { x: 150, y: 460, width: 50, height: 20, destLevel: '11', destX: 175, destY: 50 },
  { x: 200, y: 460, width: 50, height: 20, destLevel: '11', destX: 225, destY: 50 },
  { x: 250, y: 460, width: 50, height: 20, destLevel: '11', destX: 275, destY: 50 },
  { x: 300, y: 460, width: 50, height: 20, destLevel: '11', destX: 325, destY: 50 },
  { x: 350, y: 460, width: 50, height: 20, destLevel: '11', destX: 375, destY: 50 },
  { x: 400, y: 460, width: 50, height: 20, destLevel: '11', destX: 425, destY: 50 },
  { x: 450, y: 460, width: 50, height: 20, destLevel: '11', destX: 475, destY: 50 },
  { x: 500, y: 460, width: 50, height: 20, destLevel: '11', destX: 525, destY: 50 },
  { x: 550, y: 460, width: 50, height: 20, destLevel: '11', destX: 575, destY: 50 },
  { x: 600, y: 460, width: 40, height: 20, destLevel: '11', destX: 620, destY: 50 }
    ],
    darkZones: [],
    battleZones: [],
    dialogZones: [],
    interactables: [
      { name: 'photo1', x: 60, y: 40, width: 55, height: 30, action: 'photo' },
      { name: 'photo2', x: 350, y: 40, width: 80, height: 30, action: 'photo' },
      { name: 'arcadekey', x: 38, y: 131, width: 80, height: 100, action: 'arcadekey' },
      { name: 'arcadetrophy', x: 470, y: 70, width: 120, height: 130, action: 'arcadetrophy' }
    ]
  },
  {
    bgSrc: "arcade_13.png",
    walls: [
      { x: 0, y: 0, width: 40, height: 480 },
      { id: "wall_5", x: 400, y: 0, width: 16, height: 16 },
      { x: 175, y: 63, width: 64, height: 64 },
      { x: 139, y: 129, width: 64, height: 64 },
      { x: 30, y: 180, width: 50, height: 50 },
      { x: 0, y: 0, width: 640, height: 40 },
      { x: 80, y: 220, width: 50, height: 50, },
    ],
    doors: [
      { x: 0, y: 460, width: 50, height: 20, destLevel: '14', destX: 25, destY: 50 },
  { x: 50, y: 460, width: 50, height: 20, destLevel: '14', destX: 75, destY: 50 },
  { x: 100, y: 460, width: 50, height: 20, destLevel: '14', destX: 125, destY: 50 },
  { x: 150, y: 460, width: 50, height: 20, destLevel: '14', destX: 175, destY: 50 },
  { x: 200, y: 460, width: 50, height: 20, destLevel: '14', destX: 225, destY: 50 },
  { x: 250, y: 460, width: 50, height: 20, destLevel: '14', destX: 275, destY: 50 },
  { x: 300, y: 460, width: 50, height: 20, destLevel: '14', destX: 325, destY: 50 },
  { x: 350, y: 460, width: 50, height: 20, destLevel: '14', destX: 375, destY: 50 },
  { x: 400, y: 460, width: 50, height: 20, destLevel: '14', destX: 425, destY: 50 },
  { x: 450, y: 460, width: 50, height: 20, destLevel: '14', destX: 475, destY: 50 },
  { x: 500, y: 460, width: 50, height: 20, destLevel: '14', destX: 525, destY: 50 },
  { x: 550, y: 460, width: 50, height: 20, destLevel: '14', destX: 575, destY: 50 },
  { x: 600, y: 460, width: 40, height: 20, destLevel: '14', destX: 620, destY: 50 },
  { x: 620, y: 0, width: 20, height: 50, destLevel: '2', destX: 50, destY: 260 },
  { x: 620, y: 50, width: 20, height: 50, destLevel: '2', destX: 50, destY: 260 },
  { x: 620, y: 100, width: 20, height: 50, destLevel: '2', destX: 50, destY: 260 },
  { x: 620, y: 150, width: 20, height: 50, destLevel: '2', destX: 50, destY: 260 },
  { x: 620, y: 200, width: 20, height: 50, destLevel: '2', destX: 50, destY: 260 },
  { x: 620, y: 250, width: 20, height: 50, destLevel: '2', destX: 50, destY: 275 },
  { x: 620, y: 300, width: 20, height: 50, destLevel: '2', destX: 50, destY: 325 },
  { x: 620, y: 350, width: 20, height: 50, destLevel: '2', destX: 50, destY: 375 },
  { x: 620, y: 400, width: 20, height: 50, destLevel: '2', destX: 50, destY: 425 },
  { x: 620, y: 450, width: 20, height: 30, destLevel: '2', destX: 50, destY: 465 }
    ],
    darkZones: [],
    battleZones: [],
    dialogZones: [],
    interactables: [
      { id: "door2", name: "door", x: 486, y: 311, width: 80, height: 80, action: "open_door", destLevel: 1, destX: 527, destY: 300 },
      { name: "big_stone", x: 139, y: 129, width: 64, height: 64, interactRect: { x: 120, y: 100, width: 120, height: 96 }, action: "break", requiredItem: "hammer" },
      { name: "big_stone", x: 175, y: 63, width: 64, height: 64, interactRect: { x: 150, y: 40, width: 120, height: 96 }, action: "break", requiredItem: "hammer" },
      {
  id: "gate_001",
  name: "tester",
  x: 300,
  y: 200,
  width: 32,
  height: 32,
  action: "item_gate",
  wallId: "wall_5",
  requiredItems: ["hammer"],
  opened: false,
  dialogId: "gate_001_dialog",
  messages: {
    needItems: "You need and a hammer to pass!",
    opened: "The gate is open. You may go now."
  }
}
    ]
  },
  {
    bgSrc: "arcade_14.png",
    walls: [
      { x: 0, y: 0, width: 40, height: 480 },
    ],
    doors: [
      { x: 0, y: 0, width: 50, height: 20, destLevel: '13', destX: 25, destY: 400 },
  { x: 50, y: 0, width: 50, height: 20, destLevel: '13', destX: 75, destY: 400 },
  { x: 100, y: 0, width: 50, height: 20, destLevel: '13', destX: 125, destY: 400 },
  { x: 150, y: 0, width: 50, height: 20, destLevel: '13', destX: 175, destY: 400 },
  { x: 200, y: 0, width: 50, height: 20, destLevel: '13', destX: 225, destY: 400 },
  { x: 250, y: 0, width: 50, height: 20, destLevel: '13', destX: 275, destY: 400 },
  { x: 300, y: 0, width: 50, height: 20, destLevel: '13', destX: 325, destY: 400 },
  { x: 350, y: 0, width: 50, height: 20, destLevel: '13', destX: 375, destY: 400 },
  { x: 400, y: 0, width: 50, height: 20, destLevel: '13', destX: 425, destY: 400 },
  { x: 450, y: 0, width: 50, height: 20, destLevel: '13', destX: 475, destY: 400 },
  { x: 500, y: 0, width: 50, height: 20, destLevel: '13', destX: 525, destY: 400 },
  { x: 550, y: 0, width: 50, height: 20, destLevel: '13', destX: 575, destY: 400 },
  { x: 600, y: 0, width: 40, height: 20, destLevel: '13', destX: 620, destY: 400 },
  { x: 0, y: 0, width: 20, height: 50, destLevel: '17', destX: 600, destY: 25 },
  { x: 0, y: 50, width: 20, height: 50, destLevel: '17', destX: 600, destY: 75 },
  { x: 0, y: 100, width: 20, height: 50, destLevel: '17', destX: 600, destY: 125 },
  { x: 0, y: 150, width: 20, height: 50, destLevel: '17', destX: 600, destY: 175 },
  { x: 0, y: 200, width: 20, height: 50, destLevel: '17', destX: 600, destY: 225 },
  { x: 0, y: 250, width: 20, height: 50, destLevel: '17', destX: 600, destY: 275 },
  { x: 0, y: 300, width: 20, height: 50, destLevel: '17', destX: 600, destY: 325 },
  { x: 0, y: 350, width: 20, height: 50, destLevel: '17', destX: 600, destY: 375 },
  { x: 0, y: 400, width: 20, height: 50, destLevel: '17', destX: 600, destY: 425 },
  { x: 0, y: 450, width: 20, height: 30, destLevel: '17', destX: 600, destY: 465 },
      { x: 0, y: 460, width: 50, height: 20, destLevel: '15', destX: 25, destY: 50 },
  { x: 50, y: 460, width: 50, height: 20, destLevel: '15', destX: 75, destY: 50 },
  { x: 100, y: 460, width: 50, height: 20, destLevel: '15', destX: 125, destY: 50 },
  { x: 150, y: 460, width: 50, height: 20, destLevel: '15', destX: 175, destY: 50 },
  { x: 200, y: 460, width: 50, height: 20, destLevel: '15', destX: 225, destY: 50 },
  { x: 250, y: 460, width: 50, height: 20, destLevel: '15', destX: 275, destY: 50 },
  { x: 300, y: 460, width: 50, height: 20, destLevel: '15', destX: 325, destY: 50 },
  { x: 350, y: 460, width: 50, height: 20, destLevel: '15', destX: 375, destY: 50 },
  { x: 400, y: 460, width: 50, height: 20, destLevel: '15', destX: 425, destY: 50 },
  { x: 450, y: 460, width: 50, height: 20, destLevel: '15', destX: 475, destY: 50 },
  { x: 500, y: 460, width: 50, height: 20, destLevel: '15', destX: 525, destY: 50 },
  { x: 550, y: 460, width: 50, height: 20, destLevel: '15', destX: 575, destY: 50 },
  { x: 600, y: 460, width: 40, height: 20, destLevel: '15', destX: 620, destY: 50 }
    ],
    darkZones: [],
    battleZones: [],
    dialogZones: [],
    interactables: []
  },
  {
    bgSrc: "arcade_15.png",
    walls: [
      { x: 0, y: 0, width: 40, height: 480 },
    ],
    doors: [
  { x: 620, y: 0, width: 20, height: 50, destLevel: '16', destX: 50, destY: 25 },
  { x: 620, y: 50, width: 20, height: 50, destLevel: '16', destX: 50, destY: 75 },
  { x: 620, y: 100, width: 20, height: 50, destLevel: '16', destX: 50, destY: 125 },
  { x: 620, y: 150, width: 20, height: 50, destLevel: '16', destX: 50, destY: 175 },
  { x: 620, y: 200, width: 20, height: 50, destLevel: '16', destX: 50, destY: 225 },
  { x: 620, y: 250, width: 20, height: 50, destLevel: '16', destX: 50, destY: 275 },
  { x: 620, y: 300, width: 20, height: 50, destLevel: '16', destX: 50, destY: 325 },
  { x: 620, y: 350, width: 20, height: 50, destLevel: '16', destX: 50, destY: 375 },
  { x: 620, y: 400, width: 20, height: 50, destLevel: '16', destX: 50, destY: 425 },
  { x: 620, y: 450, width: 20, height: 30, destLevel: '16', destX: 50, destY: 465 },
  { x: 0, y: 0, width: 50, height: 20, destLevel: '14', destX: 25, destY: 400 },
  { x: 50, y: 0, width: 50, height: 20, destLevel: '14', destX: 75, destY: 400 },
  { x: 100, y: 0, width: 50, height: 20, destLevel: '14', destX: 125, destY: 400 },
  { x: 150, y: 0, width: 50, height: 20, destLevel: '14', destX: 175, destY: 400 },
  { x: 200, y: 0, width: 50, height: 20, destLevel: '14', destX: 225, destY: 400 },
  { x: 250, y: 0, width: 50, height: 20, destLevel: '14', destX: 275, destY: 400 },
  { x: 300, y: 0, width: 50, height: 20, destLevel: '14', destX: 325, destY: 400 },
  { x: 350, y: 0, width: 50, height: 20, destLevel: '14', destX: 375, destY: 400 },
  { x: 400, y: 0, width: 50, height: 20, destLevel: '14', destX: 425, destY: 400 },
  { x: 450, y: 0, width: 50, height: 20, destLevel: '14', destX: 475, destY: 400 },
  { x: 500, y: 0, width: 50, height: 20, destLevel: '14', destX: 525, destY: 400 },
  { x: 550, y: 0, width: 50, height: 20, destLevel: '14', destX: 575, destY: 400 },
  { x: 600, y: 0, width: 40, height: 20, destLevel: '14', destX: 620, destY: 400 }
    ],
    darkZones: [],
    battleZones: [],
    dialogZones: [],
    interactables: []
  },
  {
    bgSrc: "arcade_16.png",
    walls: [
      { x: 600, y: 0, width: 40, height: 480 },
    ],
    doors: [
       { x: 0, y: 0, width: 20, height: 50, destLevel: '15', destX: 600, destY: 25 },
  { x: 0, y: 50, width: 20, height: 50, destLevel: '15', destX: 600, destY: 75 },
  { x: 0, y: 100, width: 20, height: 50, destLevel: '15', destX: 600, destY: 125 },
  { x: 0, y: 150, width: 20, height: 50, destLevel: '15', destX: 600, destY: 175 },
  { x: 0, y: 200, width: 20, height: 50, destLevel: '15', destX: 600, destY: 225 },
  { x: 0, y: 250, width: 20, height: 50, destLevel: '15', destX: 600, destY: 275 },
  { x: 0, y: 300, width: 20, height: 50, destLevel: '15', destX: 600, destY: 325 },
  { x: 0, y: 350, width: 20, height: 50, destLevel: '15', destX: 600, destY: 375 },
  { x: 0, y: 400, width: 20, height: 50, destLevel: '15', destX: 600, destY: 425 },
  { x: 0, y: 450, width: 20, height: 30, destLevel: '15', destX: 600, destY: 465 },
  { x: 0, y: 0, width: 50, height: 20, destLevel: '17', destX: 25, destY: 400 },
  { x: 50, y: 0, width: 50, height: 20, destLevel: '17', destX: 75, destY: 400 },
  { x: 100, y: 0, width: 50, height: 20, destLevel: '17', destX: 125, destY: 400 },
  { x: 150, y: 0, width: 50, height: 20, destLevel: '17', destX: 175, destY: 400 },
  { x: 200, y: 0, width: 50, height: 20, destLevel: '17', destX: 225, destY: 400 },
  { x: 250, y: 0, width: 50, height: 20, destLevel: '17', destX: 275, destY: 400 },
  { x: 300, y: 0, width: 50, height: 20, destLevel: '17', destX: 325, destY: 400 },
  { x: 350, y: 0, width: 50, height: 20, destLevel: '17', destX: 375, destY: 400 },
  { x: 400, y: 0, width: 50, height: 20, destLevel: '17', destX: 425, destY: 400 },
  { x: 450, y: 0, width: 50, height: 20, destLevel: '17', destX: 475, destY: 400 },
  { x: 500, y: 0, width: 50, height: 20, destLevel: '17', destX: 525, destY: 400 },
  { x: 550, y: 0, width: 50, height: 20, destLevel: '17', destX: 575, destY: 400 },
  { x: 600, y: 0, width: 40, height: 20, destLevel: '17', destX: 620, destY: 400 }
    ],
    darkZones: [],
    battleZones: [],
    dialogZones: [],
    interactables: [
      { id: "door2", name: "door", x: 486, y: 311, width: 80, height: 80, action: "open_door", destLevel: 1, destX: 527, destY: 300 }
    ]
  },
  {
    bgSrc: "arcade_17.png",
    walls: [
      { x: 0, y: 0, width: 40, height: 480 },
      { x: 600, y: 0, width: 40, height: 480 },
      { x: 37, y: 101, width: 300, height: 102 },
    ],
    doors: [
      { x: 0, y: 0, width: 640, height: 20, destLevel: 12, destX: 40, destY: 40 }
    ],
    darkZones: [],
    battleZones: [],
    dialogZones: [],
    interactables: [
      { id: "door2", name: "door", x: 486, y: 311, width: 80, height: 80, action: "open_door", destLevel: 1, destX: 527, destY: 300 }
    ]
  }
];

let currentLevelIndex = 0;
let currentLevel = levels[currentLevelIndex];
  // Assign unique IDs to walls for tracking
levels.forEach(level => {
  level.walls.forEach((wall, idx) => {
    if (!wall.id) wall.id = `wall_${idx}`;
  });
});

  const achievements = [
  {
    id: 'played',
    name: 'Demo Player',
    description: 'Played the demo? idk of the game!',
    target: 1,      // set your number here
    progress: 0,
    unlocked: false,
    checkCondition: () => achievementsMap['played'].progress >= 1
  },
  {
    id: 'kill_enemies',
    name: 'Bot Killer',
    description: 'Kill 50 enemies',
    target: 50,      // set your number here
    progress: 0,
    unlocked: false,
    checkCondition: () => achievementsMap['kill_enemies'].progress >= achievementsMap['kill_enemies'].target
  },
    {
    id: 'kill_enemies2',
    name: 'Bot Slayer',
    description: 'Kill 100 enemies',
    target: 100,      // set your number here
    progress: 0,
    unlocked: false,
    checkCondition: () => achievementsMap['kill_enemies2'].progress >= achievementsMap['kill_enemies2'].target
  },
    {
    id: 'kill_enemies3',
    name: 'No More Robots',
    description: 'Kill 1000 enemies',
    target: 1000,      // set your number here
    progress: 0,
    unlocked: false,
    checkCondition: () => achievementsMap['kill_enemies3'].progress >= achievementsMap['kill_enemies3'].target
  },
  {
    id: 'open_chests',
    name: 'Treasure Opener',
    description: 'Open 10 chests',
    target: 10,
    progress: 0,
    unlocked: false,
    checkCondition: () => achievementsMap['open_chests'].progress >= achievementsMap['open_chests'].target
  },
    {
    id: 'kill_tutorial_dummy',
    name: 'Tutorial Beaten',
    description: 'Kill the tutorial dummy enemy',
    target: 1,
    progress: 0,
    unlocked: false,
    checkCondition: () => achievementsMap['kill_tutorial_dummy'].progress >= 1
  },
    {
    id: 'tp_beat_master',
    name: 'Sharp Shot',
    description: 'Beat Unit 318920s score in Target Practice',
    target: 1,
    progress: 0,
    unlocked: false,
    checkCondition: () => achievementsMap['tp_beat_master'].progress >= 1
  },
    {
    id: 'kill_bossbot',
    name: 'Boss Slayer',
    description: 'Kill the Boss Robot on Ultimate Difficulty',
    target: 1,
    progress: 0,
    unlocked: false,
    checkCondition: () => achievementsMap['kill_bossbot'].progress >= 1
  },
  {
    id: 'kill_icebot',
    name: 'Ice Lord',
    description: 'Kill Frozen Metal on Ultimate Difficulty',
    target: 1,
    progress: 0,
    unlocked: false,
    checkCondition: () => achievementsMap['kill_icebot'].progress >= 1
  },
  {
    id: 'kill_lifestealboss',
    name: 'Undertaker',
    description: 'Kill the Soul Slasher on Ultimate Difficulty',
    target: 1,
    progress: 0,
    unlocked: false,
    checkCondition: () => achievementsMap['kill_lifestealboss'].progress >= 1
  },
  {
    id: 'kill_critboss',
    name: 'High Noon',
    description: 'Kill Deadshot on Ultimate Difficulty',
    target: 1,
    progress: 0,
    unlocked: false,
    checkCondition: () => achievementsMap['kill_critboss'].progress >= 1
  },
    {
    id: 'kill_caveboss',
    name: 'Reduced to Pebbles',
    description: 'Kill Stoneforce on Ultimate Difficulty',
    target: 1,
    progress: 0,
    unlocked: false,
    checkCondition: () => achievementsMap['kill_caveboss'].progress >= 1
  },
    {
    id: 'kill_mountainboss',
    name: 'Last Fire Breath',
    description: 'Kill Autoyvern on Ultimate Difficulty',
    target: 1,
    progress: 0,
    unlocked: false,
    checkCondition: () => achievementsMap['kill_mountainboss'].progress >= 1
  },
    {
    id: 'kill_islandboss',
    name: 'Washed Up Guardian',
    description: 'Kill Nekark of the Seas on Ultimate Difficulty',
    target: 1,
    progress: 0,
    unlocked: false,
    checkCondition: () => achievementsMap['kill_islandboss'].progress >= 1
  },
    {
    id: 'kill_factoryboss',
    name: 'Fireworks',
    description: 'Kill The Works Plant on Ultimate Difficulty',
    target: 1,
    progress: 0,
    unlocked: false,
    checkCondition: () => achievementsMap['kill_factoryboss'].progress >= 1
  },
  {
    id: 'kill_ghostboss',
    name: 'Whack-a-ghost',
    description: 'Kill The Maestro on Ultimate Difficulty',
    target: 1,
    progress: 0,
    unlocked: false,
    checkCondition: () => achievementsMap['kill_ghostboss'].progress >= 1
  },
    {
    id: 'kill_finaleboss',
    name: 'Save the World!',
    description: 'Kill Corruptus Caliginis Aeternae on Ultimate Difficulty',
    target: 1,
    progress: 0,
    unlocked: false,
    checkCondition: () => achievementsMap['kill_finaleboss'].progress >= 1
  }
];

  alliesData.forEach(ally => {
  achievements.push({
    id: `ally_unlock_${ally.id}`,
    name: `Unlock ${ally.name}`,
    description: `Unlock the ally ${ally.name}.`,
    progress: 0,
    target: 1,
    unlocked: false,
    checkCondition: function() { return this.progress >= this.target; }
  });
});

    const achievementsMap = {};
achievements.forEach(a => achievementsMap[a.id] = a);
  
  const titleScreen = document.getElementById('title-screen');
const playBtn = document.getElementById('play-button');
  
// Preload and spawn background + player at game start
let bgImg = new Image();
bgImg.src = 'arcade.png';
const playerImg = new Image();
playerImg.src = '8bit.png'; // keep your existing player path


function preloadImagesForLevel(levelIndex, onComplete) {
  const level = levels[levelIndex];
  // preload bg
  bgImg = new Image();
  bgImg.onload = () => {
    // preload player sprite after bg (optional parallel)
    if (img && img.complete) return onComplete();
    img = img || new Image();
    img.onload = () => onComplete();
    img.src = img.src || '8bit.png';
  };
  bgImg.src = level.bgSrc;
}

// find first unseen dialog zone at a given world position
function findDialogZone(checkX, checkY) {
  const hitboxX = checkX + (typeof hitboxOffsetX !== 'undefined' ? hitboxOffsetX : 0);
  const hitboxY = checkY + (typeof hitboxOffsetY !== 'undefined' ? hitboxOffsetY : 0);
  const hw = typeof hitboxWidth !== 'undefined' ? hitboxWidth : 16;
  const hh = typeof hitboxHeight !== 'undefined' ? hitboxHeight : 16;
  const level = currentLevel;
  if (!level || !level.dialogZones) return null;
  for (const zone of level.dialogZones) {
    if (!zone || !zone.id) continue;
    if (shownDialogs.has(zone.id)) continue;
    if (
      hitboxX < zone.x + zone.width &&
      hitboxX + hw > zone.x &&
      hitboxY < zone.y + zone.height &&
      hitboxY + hh > zone.y
    ) return zone;
  }
  return null;
}


function normalizeDialogLines(textOrLines, defaultStyle) {
  const lines = Array.isArray(textOrLines) ? textOrLines.slice() : [String(textOrLines)];
  return lines.map(line => {
    if (typeof line === 'string') {
      return { speaker: null, text: line, style: defaultStyle || 'dialog' };
    }
    return {
      speaker: line.speaker || null,
      text: line.text != null ? String(line.text) : '',
      style: line.style || defaultStyle || 'dialog'
    };
  });
}

function applyDialogStyle(box, style) {
  box.style.maxWidth = '640px';
  box.style.fontSize = '12px';
  if (style === 'other') {
    box.style.background = '#223344';
    box.style.fontSize = '14px';
  } else if (style === 'lou') {
    box.style.background = '#78bdff';
    box.style.fontSize = '14px';
  } else if (style === 'unit') {
    box.style.background = '#4c4c4c';
    box.style.fontSize = '14px';
  } else if (style === 'boss') {
    box.style.background = '#330000';
    box.style.fontSize = '12px';
    } else if (style === 'colt') {
    box.style.background = '#ca2f2f';
    box.style.fontSize = '12px';
  } else {
    box.style.background = '#0e2057';
    box.style.fontSize = '12px';
  }
}
function findNearbyDialogZone(px, py) {
  // reuse existing findDialogZone but allow manual triggers (ignore autoShow if present)
  const level = currentLevel;
  if (!level || !level.dialogZones) return null;
  const hitboxX = px + (typeof hitboxOffsetX !== 'undefined' ? hitboxOffsetX : 0);
  const hitboxY = py + (typeof hitboxOffsetY !== 'undefined' ? hitboxOffsetY : 0);
  const hw = typeof hitboxWidth !== 'undefined' ? hitboxWidth : 16;
  const hh = typeof hitboxHeight !== 'undefined' ? hitboxHeight : 16;
  for (const zone of level.dialogZones) {
    if (!zone || !zone.id) continue;
    if (shownDialogs.has(zone.id)) continue;
    if (
      hitboxX < zone.x + zone.width &&
      hitboxX + hw > zone.x &&
      hitboxY < zone.y + zone.height &&
      hitboxY + hh > zone.y
    ) return zone;
  }
  return null;
}

function showDialogWithOptions(dialogText, options, idToMark, opts = {}) {
  const overlay = document.getElementById('dialog-overlay');
  const box = document.getElementById('dialog-box');
  const textDiv = document.getElementById('dialog-text');

  overlay.style.display = 'flex';
  overlay._markId = idToMark || null;

  // Clear previous content
  textDiv.innerHTML = '';
  applyDialogStyle(box, opts.style || 'dialog');

  // Show main dialog text
  const p = document.createElement('p');
  p.textContent = dialogText;
  textDiv.appendChild(p);

  options.forEach(opt => {
    const btn = document.createElement('button');
    btn.textContent = opt.label;
    btn.className = 'item-use-button';
    btn.style.marginTop = '8px';
    btn.style.padding = '8px 16px';
    btn.style.fontSize = '14px';
    btn.onclick = () => {
      overlay.style.display = 'none';
      if (opt.onSelect) opt.onSelect();
      if (idToMark) shownDialogs.add(idToMark);
      draw();
    };
    textDiv.appendChild(btn);
  });
}
  
  function showBattleDialog(textOrLines, idToMark, opts = {}) {
  if (!inBattle) {
    showDialog(textOrLines, idToMark, opts);
    return;
  }

  const overlay = document.getElementById('dialog-overlay');
  const box = document.getElementById('dialog-box');
  const textDiv = document.getElementById('dialog-text');

  function normalize(line, fallbackStyle) {
    if (typeof line === 'string') return { speaker: null, text: line, style: fallbackStyle };
    return { speaker: line.speaker || null, text: line.text != null ? String(line.text) : '', style: line.style || fallbackStyle };
  }

  const fallbackStyle = opts.style || 'dialog';
  const lines = Array.isArray(textOrLines) ? textOrLines.slice() : [textOrLines];
  _battleDialogQueue = lines.map(l => normalize(l, fallbackStyle));

  pauseBattleTimersForDialog();

  if (_battleDialogQueue.length > 0) {
    const line = _battleDialogQueue.shift();
    applyDialogStyle(box, line.style || fallbackStyle);
    if (line.speaker) {
      textDiv.innerHTML = `<strong>${line.speaker}</strong>\n\n${line.text}`;
    } else {
      textDiv.textContent = line.text;
    }
  } else {
    textDiv.textContent = '';
  }

  overlay.style.display = 'flex';
  overlay._markId = idToMark || null;

  drawBattleUI();
  drawPlayerBattleStatus();
}

function showDialog(textOrLines, idToMark, opts = {}) {
  const overlay = document.getElementById('dialog-overlay');
  const box = document.getElementById('dialog-box');
  const textDiv = document.getElementById('dialog-text');

  const defaultStyle = opts.style || 'dialog';
  _dialogQueue = normalizeDialogLines(textOrLines, defaultStyle);

  if (_dialogQueue.length > 0) {
    const line = _dialogQueue.shift();
    applyDialogStyle(box, line.style);
    if (line.speaker) {
      textDiv.innerHTML = `<strong>${line.speaker}</strong>\n\n${line.text}`;
    } else {
      textDiv.textContent = line.text;
    }
  } else {
    textDiv.textContent = '';
  }

  overlay.style.display = 'flex';
  overlay._markId = idToMark || null;
  draw();
}


// Play button handler
playBtn.addEventListener('click', () => {
  // Hide title screen
  titleScreen.style.display = 'none';
  achievementsMap['played'].progress++;
  checkAchievements();
  updateAbilityButtonsUI();

  // Set starting level and spawn coordinates (adjust if different)
  currentLevelIndex = 0;
  currentLevel = levels[currentLevelIndex];
  x = typeof x === 'number' ? x : 150;
  y = typeof y === 'number' ? y : 50;

  // Preload necessary images then draw/start
  preloadImagesForLevel(currentLevelIndex, () => {
    // show background and player immediately after preload
    draw();

  });


  draw();
});

const closedChestImg = new Image(); closedChestImg.src = "chest_closed.png";
const openChestImg   = new Image(); openChestImg.src = "chest_open.png";

const stoneImg = new Image();
stoneImg.src = "stone.png";

const hammerImg = new Image();
hammerImg.src = "hammer.png";

const steelBlockImg = new Image();
steelBlockImg.src = 'steel_block.png';

const laserCutterImg = new Image();
laserCutterImg.src = 'laser_cutter.png';

const keycardImg = new Image();
keycardImg.src = 'keycard.png';

const gasMaskImg = new Image();
gasMaskImg.src = 'gas_mask.png';

const raftImg = new Image();
raftImg.src = 'raft.png';

const torchImg = new Image();
torchImg.src = 'torch.png';

const drillImg = new Image();
drillImg.src = 'drill.png';

const leverOnImg = new Image();
leverOnImg.src = 'leveron.png';
const leverOffImg = new Image();
leverOffImg.src = 'leveroff.png';


let activeEnemies = [];

// Utility: text wrapping for canvas
function wrapText(context, text, x, y, maxWidth, lineHeight) {
  const words = String(text).split(' ');
  let line = "";
  for (let n = 0; n < words.length; n++) {
    const testLine = line ? (line + " " + words[n]) : words[n];
    const metrics = context.measureText(testLine);
    const testWidth = metrics.width;
    if (testWidth > maxWidth && n > 0) {
      context.fillText(line.trim(), x, y);
      line = words[n];
      y += lineHeight;
    } else {
      line = testLine;
    }
  }
  context.fillText(line.trim(), x, y);
}

// Show temporary text on screen for 3 seconds
function showTemporaryText(message) {
  tempText = message;
  if (tempTextTimeout) clearTimeout(tempTextTimeout);
  tempTextTimeout = setTimeout(() => {
    tempText = "";
    draw();
  }, 3000);
}

  
// Check if player can go below 1 HP (used with extra life item)
function canGoBelow1Hp() {
  return extraLifeTimerId === null;
}

// Update stamina and clamp between 0 and max
function updateStamina(newStamina) {
  if (newStamina < 0) newStamina = 0;
  if (newStamina > playerStats.maxStamina) newStamina = playerStats.maxStamina;
  playerStats.currentStamina = newStamina;
}

// Update HP and UI bar
function updateHp(newHealth) {
  if (newHealth < 0) newHealth = 0;
  if (newHealth > playerStats.maxHp) newHealth = playerStats.maxHp;
  playerStats.currentHp = newHealth;
  const newWidth = (playerStats.currentHp / playerStats.maxHp) * 100;
  hpBar.style.width = `${newWidth}%`;
  hpText.textContent = `${playerStats.currentHp}/${playerStats.maxHp}`;
}

// Update stats popup UI
function updateStatsPopup() {
  document.getElementById('popup-level').textContent = playerStats.level;
  document.getElementById('popup-xp').textContent = `${playerStats.xp} / ${playerStats.xpToNextLevel}`;
  document.getElementById('popup-damage').textContent = playerStats.damage;
}

const passwordPopup = document.getElementById('password-popup');
const passwordInput = document.getElementById('password-input');
const passwordSubmit = document.getElementById('password-submit');
const passwordCancel = document.getElementById('password-cancel');
const passwordMessage = document.getElementById('password-message');

let currentPasswordDoor = null;

function openPasswordPopup(doorObj) {
  currentPasswordDoor = doorObj;
  passwordInput.value = "";
  passwordMessage.textContent = "";
  passwordPopup.style.display = 'flex';
  passwordInput.focus();
}

function closePasswordPopup() {
  passwordPopup.style.display = 'none';
}

passwordSubmit.addEventListener('click', () => {
  if (!currentPasswordDoor) {
    console.error('No password door assigned');
    return;
  }

  const entered = passwordInput.value;

  if (entered === currentPasswordDoor.passcode) {
    showTemporaryText('Access granted!');
    closePasswordPopup();

    if (typeof currentPasswordDoor.destLevel === 'number') {
      loadLevel(currentPasswordDoor.destLevel, currentPasswordDoor.destX, currentPasswordDoor.destY);
    } else {
      console.error('Destination level is invalid or missing');
    }

    currentLevel.interactables = currentLevel.interactables.filter(o => o !== currentPasswordDoor);
    draw();
  } else {
    passwordMessage.textContent = "Incorrect code!";
  }
});

passwordCancel.addEventListener('click', () => {
  closePasswordPopup();
});

function ensureFiniteNumber(v, fallback) {
  const n = Number(v);
  return Number.isFinite(n) ? n : fallback;
}

function levelUpAlly(ally) {
  console.log('levelUp start', { id: ally.id, name: ally.name, before: { ...ally } });

  // Ensure numeric values are valid
  ally.level = ensureFiniteNumber(ally.level, 1);
  ally.xp = ensureFiniteNumber(ally.xp, 0);
  ally.xpToNextLevel = ensureFiniteNumber(ally.xpToNextLevel, 10);
  ally.baseMaxHp = ensureFiniteNumber(ally.baseMaxHp, null);
  ally.baseDamage = ensureFiniteNumber(ally.baseDamage, null);

  // Fill in defaults from alliesData if missing
  const baseAllyTemplate = alliesData.find(a => a.id === ally.id);
  if (baseAllyTemplate) {
    if (ally.baseMaxHp === null) ally.baseMaxHp = ensureFiniteNumber(baseAllyTemplate.baseMaxHp, 1);
    if (ally.baseDamage === null) ally.baseDamage = ensureFiniteNumber(baseAllyTemplate.baseDamage, 0);
  } else {
    if (ally.baseMaxHp === null) ally.baseMaxHp = 1;
    if (ally.baseDamage === null) ally.baseDamage = 0;
  }

  // Handle repeated level-ups if XP is enough
  let leveled = false;
  while (ally.xp >= ally.xpToNextLevel && ally.xpToNextLevel > 0) {
    leveled = true;
    ally.level++;
    ally.xp -= ally.xpToNextLevel;
    ally.xpToNextLevel = Math.floor(ally.xpToNextLevel * 1.2);

    // Stat growth
    ally.baseMaxHp += Math.floor(3 + (ally.level / 2));
    ally.baseDamage += Math.floor(1 + (ally.level / 6));

    console.log('leveled one step', {
      id: ally.id, level: ally.level, xp: ally.xp,
      xpToNextLevel: ally.xpToNextLevel, baseMaxHp: ally.baseMaxHp, baseDamage: ally.baseDamage
    });
  }

  // If leveled, update HP and show message
  if (leveled) {
    ally.maxHp = ally.baseMaxHp;
    ally.currentHp = ally.maxHp;
    showTemporaryText(`${ally.name} leveled up to ${ally.level}!`);
    drawPartyStatus();
  } else {
    console.log('no level up: xp below threshold', { xp: ally.xp, xpToNextLevel: ally.xpToNextLevel });
  }

  // Sync back to alliesData
  const baseAlly = alliesData.find(a => a.id === ally.id);
  if (baseAlly) {
    baseAlly.level = ally.level;
    baseAlly.xp = ally.xp;
    baseAlly.xpToNextLevel = ally.xpToNextLevel;
    baseAlly.baseMaxHp = ally.baseMaxHp;
    baseAlly.baseDamage = ally.baseDamage;
    console.log('synced to template', { before: baseAlly });
  } else {
    console.warn('No base template found for ally id', ally.id);
  }

  console.log('levelUp end', { id: ally.id, after: { ...ally } });
}



// Level up player
function levelUp() {
  playerStats.level++;
  playerStats.xp -= playerStats.xpToNextLevel;
  playerStats.xpToNextLevel = Math.floor(playerStats.xpToNextLevel * 1.5);

  playerStats.baseMaxHp += Math.floor(3 + (playerStats.level / 1));
  playerStats.baseDamage = Math.min(20, playerStats.baseDamage + 1);

  applyEquipmentBonuses();

  playerStats.currentHp = playerStats.maxHp;
  updateHp(playerStats.currentHp);

  updateStatsPopup();
  showTemporaryText(`Leveled up to ${playerStats.level}!`);
}

// Gain XP and check level up
function gainXP(amount) {
  playerStats.xp += amount;

  // Also give XP to equipped ally
  if (activeAlly) {
    activeAlly.xp += amount;
    while (activeAlly.xp >= activeAlly.xpToNextLevel) {
      levelUpAlly(activeAlly);
    }
  }

  if (playerStats.xp >= playerStats.xpToNextLevel) {
    levelUp();
  }
  updateStatsPopup();
  drawPartyStatus();
}

// Remove battle or interactable zone after clearing
function removeZone(zone) {
  if (!zone) return;
  if (zone.type === 'battleZone') {
    const index = currentLevel.battleZones.indexOf(zone.object);
    if (index > -1) currentLevel.battleZones.splice(index, 1);
  } else if (zone.type === 'interactable') {
    const index = currentLevel.interactables.indexOf(zone.object);
    if (index > -1) currentLevel.interactables.splice(index, 1);
  }
}

  function arraysEqual(a, b) {
  if (!Array.isArray(a) || !Array.isArray(b)) return false;
  if (a.length !== b.length) return false;
  for (let i = 0; i < a.length; i++) if (a[i] !== b[i]) return false;
  return true;
}

function findLeversInGroup(groupId) {
  if (!groupId) return [];
  const arr = [];
  (currentLevel.interactables || []).forEach(obj => {
    if (obj && obj.action === 'lever' && obj.leverType === 'multi' && obj.groupId === groupId) {
      // initialize runtime state if missing
      if (typeof obj.currentState === 'undefined') obj.currentState = !!obj.initialState;
      arr[obj.indexInGroup] = obj;
    }
  });
  return arr;
}

function toggleWallById(wallId, present, levelIndex = currentLevelIndex) {
  if (!wallId) return;
  const level = levels[levelIndex];
  if (!level) return;
  const walls = level.walls || [];
  const idx = walls.findIndex(w => w.id === wallId);
  if (present) {
    if (idx === -1) {
    }
  } else {
    if (idx !== -1) {
      removedWallIds.add(wallId);
      walls.splice(idx, 1);
    }
  }
}

function evaluateMultiLeverGroup(groupId, controllerObj = null) {
  const levers = findLeversInGroup(groupId);
  if (!levers.length) {
    showTemporaryText('Nothing happens.');
    return;
  }
  const currentCombo = levers.map(l => !!(l && l.currentState));
  const controller = controllerObj || (currentLevel.interactables || []).find(o => o.action === 'lever_controller' && o.groupId === groupId);
  if (!controller || !Array.isArray(controller.targetCombo)) {
    showTemporaryText('This lever group is not configured.');
    return;
  }
  const target = controller.targetCombo.map(v => !!v);
  const matches = arraysEqual(currentCombo, target);
  if (matches) {
    showTemporaryText('Correct combination!');
    if (controller.linkedWallId) toggleWallById(controller.linkedWallId, false);
  } else {
    showTemporaryText('Nothing happens.');
    if (controller.linkedWallId) toggleWallById(controller.linkedWallId, true);
  }
  draw();
}

// Scale enemy stats with level
// === Difficulty multipliers ===
function getDifficultyMultipliers() {
  // Normal: 1x; Hard: enemy damage x2; Ultimate: enemy damage x2 and enemy HP x2
  if (gameSettings.difficulty === 'hard') {
    return { enemyHp: 1, enemyDmg: 2 };
  } else if (gameSettings.difficulty === 'extreme') {
    return { enemyHp: 2, enemyDmg: 2 };
  } else if (gameSettings.difficulty === 'ultimate') {
    return { enemyHp: 3, enemyDmg: 3 };
  }
  return { enemyHp: 1, enemyDmg: 1 };
}


function scaleEnemyStats(baseStats) {
  const mult = getDifficultyMultipliers();
  return {
    ...baseStats,
    maxHp: Math.max(1, Math.floor((baseStats.maxHp + Math.floor(currentLevelIndex / 2)) * mult.enemyHp)),
    damage: Math.max(0, Math.floor((baseStats.damage + Math.floor(currentLevelIndex / 3)) * mult.enemyDmg))
  };
}


  
// Inventory popup toggle and drawing
const inventoryButton = document.getElementById('inventory-button');
const inventoryPopup = document.getElementById('inventory-popup');
const statsPopup = document.getElementById('stats-popup');
const inventoryList = document.getElementById('general-inventory-list');

inventoryButton.addEventListener('click', () => {
  // don't open during battle or after game over
  if (inBattle || isGameOver) return;

  // Hide stats popup whenever opening inventory
  if (statsPopup) statsPopup.style.display = 'none';

  // Detect if it's currently hidden (using computed style)
  const isHidden = window.getComputedStyle(inventoryPopup).display === 'none';
  if (isHidden) {
    drawGeneralInventory();
    inventoryPopup.style.display = 'block';
  } else {
    inventoryPopup.style.display = 'none';
  }
});

function drawGeneralInventory() {
  inventoryList.innerHTML = "";
  const allZero = inventory.size === 0 || Array.from(inventory.values()).every(q => q === 0);
  if (allZero) {
    inventoryList.innerHTML = '<p>Your inventory is empty.</p>';
    return;
  }
  inventory.forEach((quantity, itemName) => {
    if (quantity > 0) {
      const p = document.createElement('p');
      p.textContent = `${itemName.replace(/_/g, ' ')}: ${quantity}`;

      // Add equip buttons for armor and weapons
      if (itemName.startsWith("armor_")) {
        const type = itemName.replace("armor_", "");
        const equipBtn = document.createElement('button');
        equipBtn.textContent = "Equip";
        equipBtn.className = 'item-use-button';
        equipBtn.onclick = () => equipArmor(type);
        p.appendChild(equipBtn);
      } else if (itemName.startsWith("weapon_")) {
        const type = itemName.replace("weapon_", "");
        const equipBtn = document.createElement('button');
        equipBtn.textContent = "Equip";
        equipBtn.className = 'item-use-button';
        equipBtn.onclick = () => equipWeapon(type);
        p.appendChild(equipBtn);
      }

      inventoryList.appendChild(p);
    }
  });
}


// Find battle zone for given player position
function findBattleZone(checkX, checkY) {
  const hitboxX = checkX + hitboxOffsetX;
  const hitboxY = checkY + hitboxOffsetY;
  if (!currentLevel.battleZones) return null;
  for (const zone of currentLevel.battleZones) {
    if (
      hitboxX < zone.x + zone.width &&
      hitboxX + hitboxWidth > zone.x &&
      hitboxY < zone.y + zone.height &&
      hitboxY + hitboxHeight > zone.y
    ) {
      return zone;
    }
  }
  return null;
}

function showGameOver() {
  isGameOver = true;
  if (enemyAttackIntervalId) clearInterval(enemyAttackIntervalId);
  if (staminaRegenIntervalId) clearInterval(staminaRegenIntervalId);
  document.getElementById('battle-overlay').style.display = 'none';
  document.getElementById('game-over-overlay').style.display = 'flex';
}

// Battle inventory popup draw
function drawInventoryBattlePopup() {
 
console.log('drawInventoryBattlePopup called, entries:', Array.from(inventory.entries()));

  const battleInventoryList = document.getElementById('inventory-list');
  battleInventoryList.innerHTML = "";

  // whitelist: items that are allowed in battle (exact names or prefixes)
  const allowedExact = new Set(['bandaid','emp_grenade','poison_vial','extra_life', 'driftwood']);
  const allowedPrefix = ['battle_']; // add prefixes for any future battle-only items

  // build list of entries that are allowed and have qty > 0
  const entries = [];
  inventory.forEach((quantity, itemName) => {
    if (!quantity || quantity <= 0) return;
    if (allowedExact.has(itemName)) {
      entries.push({ itemName, quantity });
      return;
    }
    for (const p of allowedPrefix) {
      if (itemName.startsWith(p)) { entries.push({ itemName, quantity }); break; }
    }
  });

  if (entries.length === 0) {
    battleInventoryList.innerHTML = '<p>Inventory is empty.</p>';
    return;
  }

  for (const { itemName, quantity } of entries) {
    const itemElement = document.createElement('div');
    itemElement.className = 'inventory-item';
    itemElement.innerHTML = `<span>${itemName.replace(/_/g,' ')} (${quantity})</span>`;

    const useButton = document.createElement('button');
    useButton.textContent = 'Use';
    useButton.className = 'item-use-button';
    useButton.onclick = () => useItem(itemName);
    itemElement.appendChild(useButton);

    battleInventoryList.appendChild(itemElement);
  }
}

  const partyButton = document.getElementById('party-button');
const partyPopup = document.getElementById('party-popup');
const partyListDiv = document.getElementById('party-list');
const equipAllyButton = document.getElementById('equip-ally-button');

partyButton.addEventListener('click', () => {
  if (partyPopup.style.display === 'none') {
    drawPartyList();
    partyPopup.style.display = 'block';
  } else {
    partyPopup.style.display = 'none';
  }
});

function drawPartyList() {
  partyListDiv.innerHTML = '';
  if (unlockedAllies.size === 0) {
    partyListDiv.innerHTML = '<p>No allies unlocked yet.</p>';
    equipAllyButton.disabled = true;
    return;
  }

  equipAllyButton.disabled = false;

  unlockedAllies.forEach(allyId => {
    const ally = alliesData.find(a => a.id === allyId);
    if (!ally) return;

    const div = document.createElement('div');
    div.className = 'party-ally-item';
    div.textContent = `${ally.name} (Lvl ${ally.level}, HP: ${ally.baseMaxHp}, DMG: ${ally.baseDamage})`;
    div.dataset.allyId = ally.id;
    div.style.cursor = 'pointer';

    if (ally.id === equippedAllyId) {
      div.style.fontWeight = 'bold';
      div.style.color = 'yellow';
    }

    div.onclick = () => {
      const prevSelected = partyListDiv.querySelector('.selected');
      if (prevSelected) prevSelected.classList.remove('selected');
      div.classList.add('selected');
    };

    partyListDiv.appendChild(div);
  });
}

equipAllyButton.addEventListener('click', () => {
  const selectedDiv = partyListDiv.querySelector('.selected');
  if (!selectedDiv) {
    showTemporaryText('Select an ally to equip.');
    return;
  }
  const allyId = selectedDiv.dataset.allyId;
  if (!unlockedAllies.has(allyId)) {
    showTemporaryText('This ally is not unlocked.');
    return;
  }
  equippedAllyId = allyId;
  showTemporaryText(`Equipped ${alliesData.find(a => a.id === allyId).name} as ally.`);
  partyPopup.style.display = 'none';
  drawPartyList();
});

function equipArmor(type) {
  if (!armorTypes[type]) {
    showTemporaryText(`Unknown armor type: ${type}`);
    return;
  }
  if ((inventory.get(`armor_${type}`) || 0) <= 0) {
    showTemporaryText(`You don't have ${armorTypes[type].name} in your inventory.`);
    return;
  }
  equippedArmor = type;
  applyEquipmentBonuses();
  showTemporaryText(`Equipped ${armorTypes[type].name}`);
}

function equipWeapon(type) {
  if (!weaponTypes[type]) {
    showTemporaryText(`Unknown weapon type: ${type}`);
    return;
  }
  if ((inventory.get(`weapon_${type}`) || 0) <= 0) {
    showTemporaryText(`You don't have ${weaponTypes[type].name} in your inventory.`);
    return;
  }
  equippedWeapon = type;
  applyEquipmentBonuses();
  showTemporaryText(`Equipped ${weaponTypes[type].name}`);
}
  
// Use inventory item logic
function useItem(itemName) {
  if ((inventory.get(itemName) || 0) <= 0) return;

  // at the top of useItem(itemName) function, add:
if (inBattle) {
  // only allow explicit battle items while in battle
  const battleAllowed = new Set(['bandaid','emp_grenade','poison_vial','extra_life', 'driftwood']);
  if (!battleAllowed.has(itemName) && !itemName.startsWith('battle_')) {
    showTemporaryText("You can't use that item during battle.");
    return;
  }
}

  if (itemName === 'bandaid') {
    const healAmount = Math.ceil(playerStats.maxHp * 0.33);
    updateHp(playerStats.currentHp + healAmount);
    showTemporaryText(`Used a Bandage to heal for ${healAmount} HP!`);
  } else if (itemName === 'emp_grenade') {
  const STUN_DURATION_MS = 4000;

  activeEnemies.forEach(enemy => {
    if (enemy.resistances && enemy.resistances.stun) return;

  
    enemy.stunned = true;

    if (enemy._stunTimeout != null) {
      clearTimeout(enemy._stunTimeout);
      enemy._stunTimeout = null;
    }


    enemy._stunTimeout = setTimeout(() => {
     
      if (!enemy || enemy.removed || enemy.currentHp == null) {
        if (enemy && enemy._stunTimeout != null) {
          clearTimeout(enemy._stunTimeout);
          enemy._stunTimeout = null;
        }
        if (enemy) enemy.stunned = false;
        drawBattleUI();
        return;
      }

     
      enemy.stunned = false;
      enemy._stunTimeout = null;
      drawBattleUI();
    }, STUN_DURATION_MS);
  });

  showTemporaryText('Used an EMP Grenade! Some enemies stunned for 4 seconds!');
  drawBattleUI();
  } else if (itemName === 'poison_vial') {
  const POISON_TICK_MS = 500;
  const POISON_DURATION_MS = 3000;
  const poisonDamagePerTick = Math.max(1, Math.ceil(200 * playerStats.damage / 100));

  activeEnemies.forEach(enemy => {
    if (enemy.resistances && enemy.resistances.poison) return;
    enemy.poisoned = true;
    enemy._poisonElapsed = 0;
    enemy._poisonDuration = POISON_DURATION_MS;

    if (enemy._poisonIntervalId != null) {
      enemy._poisonDuration = POISON_DURATION_MS;
      return;
    }

    enemy._poisonIntervalId = setInterval(() => {
      // defensive guards
      if (!enemy || enemy.removed || enemy.currentHp == null) {
        if (enemy && enemy._poisonIntervalId != null) {
          clearInterval(enemy._poisonIntervalId);
          enemy._poisonIntervalId = null;
        }
        if (enemy) enemy.poisoned = false;
        return;
      }

      // tick damage
      enemy.currentHp = Math.max(0, enemy.currentHp - poisonDamagePerTick);
      enemy._poisonElapsed += POISON_TICK_MS;
      enemy._poisonDuration -= POISON_TICK_MS;

      drawBattleUI();

      // death handling: clear interval first, then remove via handler with known index if possible
      if (enemy.currentHp === 0) {
        const idx = activeEnemies.indexOf(enemy);
        if (enemy._poisonIntervalId != null) {
          clearInterval(enemy._poisonIntervalId);
          enemy._poisonIntervalId = null;
        }
        enemy.poisoned = false;

        if (idx >= 0) {
          handleEnemyDeath(enemy, idx);
        } else {
          handleEnemyDeath(enemy);
        }
        return;
      }

      // expiry
      if (enemy._poisonDuration <= 0) {
        if (enemy._poisonIntervalId != null) {
          clearInterval(enemy._poisonIntervalId);
          enemy._poisonIntervalId = null;
        }
        enemy.poisoned = false;
      }
    }, POISON_TICK_MS);
  });

  showTemporaryText('Used a Poison Vial! Enemies are taking poison damage!');
} else if (itemName === 'driftwood') {
    if (!IslandBossPresent()) {
      showTemporaryText("This driftwood seems useless here.");
      return;
    }
    if (!window._raft) window._raft = { maxHp: 12, hp: 12 };
    if (window._raft.hp >= window._raft.maxHp) {
      showTemporaryText("Your raft is already at full health.");
    } else {
      window._raft.hp = Math.min(window._raft.maxHp, window._raft.hp + 1);
      showTemporaryText(`You repair the raft with driftwood. Raft HP +1 (${window._raft.hp}/${window._raft.maxHp})`);
      // reflect UI updates
      drawPlayerBattleStatus();
      drawBattleUI();
    }
  } else if (itemName === 'extra_life') {
    if (extraLifeTimerId) {
      clearTimeout(extraLifeTimerId);
      extraLifeTimerId = null;
    }
    showTemporaryText('Used an Extra Life! You have 3 seconds of invincibility!');
    extraLifeTimerId = setTimeout(() => {
      extraLifeTimerId = null;
    }, 3000);
  }

  inventory.set(itemName, Math.max(0, (inventory.get(itemName) || 0) - 1));
  drawInventoryBattlePopup();
  drawBattleUI();
  drawPartyStatus();
  drawPlayerBattleStatus();
}

function updateProgressiveDarknessUI() {
  if (!progressiveDarkEl) return;
  const frac = Math.min(1, Math.max(0, darkTimerMs / darkTimerLimitMs));
  progressiveDarkEl.style.display = frac > 0 ? 'block' : 'none';
  progressiveDarkEl.style.opacity = String(Math.min(0.95, frac * 0.95));

  if (!document.getElementById('dark-timer-hud')) {
    const hud = document.createElement('div');
    hud.id = 'dark-timer-hud';
    hud.style.position = 'fixed';
    hud.style.top = '6px';
    hud.style.left = '50%';
    hud.style.transform = 'translateX(-50%)';
    hud.style.zIndex = '4000';
    hud.style.color = '#fff';
    hud.style.fontFamily = "'Press Start 2P', sans-serif";
    hud.style.fontSize = '12px';
    hud.style.background = 'rgba(0,0,0,0.5)';
    hud.style.padding = '6px 10px';
    hud.style.border = '2px solid rgba(255,255,255,0.06)';
    hud.style.borderRadius = '6px';
    document.body.appendChild(hud);
  }
  const hud = document.getElementById('dark-timer-hud');
  if (hud) {
    const secondsLeft = Math.max(0, Math.ceil((darkTimerLimitMs - darkTimerMs) / 1000));
    hud.textContent = `Dark Timer: ${secondsLeft}s`;
    hud.style.opacity = frac > 0 ? '1' : '0';
  }
}


// Draw battle enemies UI
function drawBattleUI() {
  const battleOverlay = document.getElementById('battle-overlay');
  battleOverlay.style.display = 'flex';
  const enemyDisplay = document.getElementById('enemy-display');
  enemyDisplay.innerHTML = "";
  activeEnemies.forEach((enemy, index) => {
    const enemyButton = document.createElement('button');
    enemyButton.innerHTML = `<h3>${enemy.name}</h3><p>HP: ${enemy.currentHp}/${enemy.maxHp}</p>`;
    enemyButton.className = 'enemy-target';
    if (enemy.shieldActive) enemyButton.classList.add('shielded');
    if (enemy.stunned) enemyButton.classList.add('stunned');
    if (enemy.poisoned) enemyButton.classList.add('poisoned');
    if (enemy.enraged) enemyButton.classList.add('enraged');
    enemyButton.dataset.enemyIndex = index;
    enemyDisplay.appendChild(enemyButton);
    if (index === selectedEnemyIndex) enemyButton.classList.add('selected');
  });
}

// Draw player status in battle UI
function drawPlayerBattleStatus() {
  const playerBattleStatusDiv = document.getElementById('player-battle-status');
  playerBattleStatusDiv.innerHTML = "";

  // Player block
  const leftBlock = document.createElement('div');
  leftBlock.style.display = 'inline-block';
  leftBlock.style.verticalAlign = 'top';
  leftBlock.style.marginRight = '12px';

  const playerName = document.createElement('p');
  playerName.textContent = '8-Bit';
  leftBlock.appendChild(playerName);

  const hpContainer = document.createElement('div');
  hpContainer.className = 'hp-bar-container';
  hpContainer.style.width = '150px';
  hpContainer.style.height = '15px';
  hpContainer.style.position = 'relative';

  const innerHpBar = document.createElement('div');
  innerHpBar.className = 'hp-bar';
  innerHpBar.style.width = `${(playerStats.currentHp / playerStats.maxHp) * 100}%`;
  innerHpBar.style.height = '100%';
  innerHpBar.style.backgroundColor = '#00FF00'; // force HP green

  const hpTxt = document.createElement('div');
  hpTxt.className = 'hp-text';
  hpTxt.textContent = `${playerStats.currentHp}/${playerStats.maxHp}`;

  hpContainer.appendChild(innerHpBar);
  hpContainer.appendChild(hpTxt);
  leftBlock.appendChild(hpContainer);

  // Ally block (to the right of player)
  const rightBlock = document.createElement('div');
  rightBlock.style.display = 'inline-block';
  rightBlock.style.verticalAlign = 'top';

  if (activeAlly) {
    const allyName = document.createElement('p');
    allyName.textContent = `${activeAlly.name} (Lvl ${activeAlly.level})`;
    allyName.style.fontWeight = 'bold';
    rightBlock.appendChild(allyName);

    const allyHpContainer = document.createElement('div');
    allyHpContainer.className = 'hp-bar-container';
    allyHpContainer.style.width = '120px';
    allyHpContainer.style.height = '15px';
    allyHpContainer.style.position = 'relative';

    const allyInner = document.createElement('div');
    allyInner.className = 'hp-bar';
    const allyPercent = (activeAlly.currentHp / activeAlly.maxHp) * 100 || 0;
    allyInner.style.width = `${allyPercent}%`;
    allyInner.style.height = '100%';
    allyInner.style.backgroundColor = '#00FF00'; // force ally HP green

    const allyHpText = document.createElement('div');
    allyHpText.className = 'hp-text';
    allyHpText.textContent = `${activeAlly.currentHp}/${activeAlly.maxHp}`;

    allyHpContainer.appendChild(allyInner);
    allyHpContainer.appendChild(allyHpText);
    rightBlock.appendChild(allyHpContainer);
  } else {
    rightBlock.innerHTML = '<p style="opacity:0.7">No ally equipped</p>';
  }

  // Append player + ally blocks
  playerBattleStatusDiv.appendChild(leftBlock);
  playerBattleStatusDiv.appendChild(rightBlock);

  // Stamina bar (separate and explicitly cyan)
  const staminaContainer = document.createElement('div');
  staminaContainer.className = 'hp-bar-container';
  staminaContainer.style.marginTop = '8px';
  staminaContainer.style.width = '100%';
  staminaContainer.style.height = '12px';
  staminaContainer.style.position = 'relative';

  const staminaBar = document.createElement('div');
  staminaBar.className = 'hp-bar';
  staminaBar.style.width = `${(playerStats.currentStamina / playerStats.maxStamina) * 100}%`;
  staminaBar.style.height = '100%';
  staminaBar.style.backgroundColor = '#00FFFF'; // force stamina cyan

  const staminaText = document.createElement('div');
  staminaText.className = 'hp-text';
  staminaText.textContent = `${playerStats.currentStamina}/${playerStats.maxStamina}`;

  staminaContainer.appendChild(staminaBar);
  staminaContainer.appendChild(staminaText);
  playerBattleStatusDiv.appendChild(staminaContainer);

  
  if (window._raft) {
    const raftContainer = document.createElement('div');
    raftContainer.className = 'hp-bar-container';
    raftContainer.style.width = '100%';
    raftContainer.style.height = '12px';
    raftContainer.style.position = 'relative';
    raftContainer.style.marginTop = '6px';

    const raftBar = document.createElement('div');
    raftBar.className = 'hp-bar';
    const raftPercent = (window._raft.hp / window._raft.maxHp) * 100;
    raftBar.style.width = `${Math.max(0, raftPercent)}%`;
    raftBar.style.height = '100%';
    raftBar.style.backgroundColor = '#8B5A2B'; // brown color

    const raftText = document.createElement('div');
    raftText.className = 'hp-text';
    raftText.style.fontSize = '0.7em';
    raftText.textContent = `Raft: ${window._raft.hp}/${window._raft.maxHp}`;

    raftContainer.appendChild(raftBar);
    raftContainer.appendChild(raftText);
    playerBattleStatusDiv.appendChild(raftContainer);
  }
}




  function drawPartyStatus() {
  const partyHud = document.getElementById('party');
  if (!partyHud) return;

  let statusDiv = partyHud.querySelector('.party-status');
  if (!statusDiv) {
    statusDiv = document.createElement('div');
    statusDiv.className = 'party-status';
    statusDiv.style.marginTop = '10px';
    partyHud.appendChild(statusDiv);
  }
  statusDiv.innerHTML = '';

  if (!activeAlly) {
    statusDiv.textContent = ' ';
    return;
  }

  const nameP = document.createElement('p');
  nameP.textContent = `${activeAlly.name} (Lvl ${activeAlly.level})`;
  nameP.style.fontWeight = 'bold';
  statusDiv.appendChild(nameP);

  const hpContainer = document.createElement('div');
  hpContainer.className = 'hp-bar-container';
  hpContainer.style.width = '150px';
  hpContainer.style.height = '15px';
  hpContainer.style.backgroundColor = '#555';
  hpContainer.style.border = '1px solid white';
  hpContainer.style.position = 'relative';

  const hpBar = document.createElement('div');
  hpBar.className = 'hp-bar';
  const hpPercent = (activeAlly.currentHp / activeAlly.maxHp) * 100;
  hpBar.style.width = `${hpPercent}%`;
  hpBar.style.height = '100%';
  hpBar.style.backgroundColor = '#00FF00';

  const hpText = document.createElement('div');
  hpText.className = 'hp-text';
  hpText.textContent = `${activeAlly.currentHp} / ${activeAlly.maxHp}`;
  hpText.style.position = 'absolute';
  hpText.style.top = '50%';
  hpText.style.left = '50%';
  hpText.style.transform = 'translate(-50%, -50%)';
  hpText.style.fontSize = '0.7em';
  hpText.style.textShadow = '1px 1px 2px black';
  hpText.style.userSelect = 'none';

  hpContainer.appendChild(hpBar);
  hpContainer.appendChild(hpText);
  statusDiv.appendChild(hpContainer);
}
  function startAllyAttacking() {
  if (!activeAlly) return;
  if (activeAlly.attackTimerId) clearInterval(activeAlly.attackTimerId);

  activeAlly.attackTimerId = setInterval(() => {
    if (!inBattle || !activeAlly || activeAlly.currentHp <= 0) {
      clearInterval(activeAlly.attackTimerId);
      return;
    }
    if (!activeEnemies.length) return;

    const targetEnemy = activeEnemies[selectedEnemyIndex] || activeEnemies[0];
    if (!targetEnemy) return;

    if (targetEnemy.shieldActive) {
      showTemporaryText(`${activeAlly.name}'s attack was blocked by shield!`);
    } else {
      targetEnemy.currentHp -= activeAlly.damage;
      if (targetEnemy.currentHp < 0) targetEnemy.currentHp = 0;
      showTemporaryText(`${activeAlly.name} attacks ${targetEnemy.name} for ${activeAlly.damage} damage!`);
    }

    if (targetEnemy.currentHp === 0) {
      handleEnemyDeath(targetEnemy);
      if (selectedEnemyIndex >= activeEnemies.length) selectedEnemyIndex = Math.max(0, activeEnemies.length - 1);
      drawBattleUI();
      drawPlayerBattleStatus();
      drawPartyStatus();
      if (activeEnemies.length === 0) {
        endBattle('win');
      }
    } else {
      drawBattleUI();
    }
  }, activeAlly.attackIntervalMs);
}
// Enemy behaviors
// normal enemy attack
function normalAttack(enemy, target) {
  const damage = enemy.damage || 0;
   if (typeof normalAttack === 'function') {
    const _orig_normalAttack = normalAttack;
    normalAttack = function(enemy, target) {
      if (target === playerStats) {
        const dmg = enemy.damage || 0;
        if (typeof playerTakeDamage === 'function') playerTakeDamage(dmg, enemy);
        else _orig_normalAttack(enemy, target);
      } else {
        // fallback to original (for ally)
        _orig_normalAttack(enemy, target);
      }
    };
  }
  if (target === playerStats) {
    playerTakeDamage(damage);
    showTemporaryText(`${enemy.name} attacks you for ${damage} damage!`);
  } else if (target === activeAlly) {
    activeAlly.currentHp -= damage;
    if (activeAlly.currentHp < 0) activeAlly.currentHp = 0;
    showTemporaryText(`${enemy.name} attacks ${activeAlly.name} for ${damage} damage!`);
    if (activeAlly.currentHp === 0) {
      showTemporaryText(`${activeAlly.name} has been defeated!`);
      clearInterval(activeAlly.attackTimerId);
      activeAlly.attackTimerId = null;
    }
  }
}

function sniperAttack(enemy, target) {
  if (typeof sniperAttack === 'function') {
    const _orig_sniperAttack = sniperAttack;
    sniperAttack = function(enemy, target) {
      // compute damage like original wrapper did
      const isCritical = Math.random() < 0.3;
      const damage = isCritical ? (enemy.damage * 3) : enemy.damage;
      if (target === playerStats) {
        if (typeof playerTakeDamage === 'function') playerTakeDamage(damage, enemy);
        else _orig_sniperAttack(enemy, target);
      } else {
        _orig_sniperAttack(enemy, target);
      }
    };
  }
  const isCritical = Math.random() < 0.3;
  const damage = isCritical ? (enemy.damage * 3) : enemy.damage;
  if (target === playerStats) {
    playerTakeDamage(damage);
    showTemporaryText(`${enemy.name} ${isCritical ? 'snipes critically' : 'attacks'} for ${damage} damage!`);
  } else if (target === activeAlly) {
    activeAlly.currentHp -= damage;
    if (activeAlly.currentHp < 0) activeAlly.currentHp = 0;
    showTemporaryText(`${enemy.name} ${isCritical ? 'snipes critically' : 'attacks'} ${activeAlly.name} for ${damage} damage!`);
    if (activeAlly.currentHp === 0) {
      showTemporaryText(`${activeAlly.name} has been defeated!`);
      clearInterval(activeAlly.attackTimerId);
      activeAlly.attackTimerId = null;
    }
  }
}

function bossBehavior(enemy, target) {
  const now = Date.now();
  if (!enemy.shieldActivatedAt) enemy.shieldActivatedAt = 0;
  if (!enemy.shieldCooldownEnd) enemy.shieldCooldownEnd = 0;

  if (enemy.shieldActive) {
    if (now >= enemy.shieldActivatedAt + 2000) {
      enemy.shieldActive = false;
      enemy.shieldCooldownEnd = now + 3000;
      showTemporaryText(`${enemy.name}'s shield fades.`);
    }
  } else {
    if (now >= enemy.shieldCooldownEnd) {
      enemy.shieldActive = true;
      enemy.shieldActivatedAt = now;
      showTemporaryText(`${enemy.name} activates a shield!`);
    }
  }

  if (enemy.rocketActive && enemy.rocketTicksLeft > 0) {
    const rocketTickDamage = Math.ceil(playerStats.maxHp * 0.05);
    if (target === playerStats) {
      playerTakeDamage(rocketTickDamage);
    } else if (target === activeAlly) {
      activeAlly.currentHp -= rocketTickDamage;
      if (activeAlly.currentHp < 0) activeAlly.currentHp = 0;
      if (activeAlly.currentHp === 0) {
        showTemporaryText(`${activeAlly.name} has been defeated!`);
        clearInterval(activeAlly.attackTimerId);
        activeAlly.attackTimerId = null;
      }
    }
    enemy.rocketTicksLeft--;
    showTemporaryText(`${enemy.name}'s rocket hits ${target === playerStats ? 'you' : activeAlly.name} for ${rocketTickDamage} damage!`);
    if (enemy.rocketTicksLeft === 0) {
      enemy.rocketActive = false;
      showTemporaryText("The rocket damage ends.");
    }
  }

  if (enemy.shieldActive) return;

  if (!enemy.rocketActive && Math.random() < 0.25) {
    enemy.rocketActive = true;
    enemy.rocketTicksLeft = 4;
    showTemporaryText(`${enemy.name} launches a rocket!`);
  }

  const damage = enemy.damage || 0;
  if (target === playerStats) {
    playerTakeDamage(damage);
    showTemporaryText(`${enemy.name} attacks you for ${damage} damage!`);
  } else if (target === activeAlly) {
    activeAlly.currentHp -= damage;
    if (activeAlly.currentHp < 0) activeAlly.currentHp = 0;
    showTemporaryText(`${enemy.name} attacks ${activeAlly.name} for ${damage} damage!`);
    if (activeAlly.currentHp === 0) {
      showTemporaryText(`${activeAlly.name} has been defeated!`);
      clearInterval(activeAlly.attackTimerId);
      activeAlly.attackTimerId = null;
    }
  }
}

function summonerBehavior(enemy, target) {
  if (!enemy.lastSummonTime) enemy.lastSummonTime = 0;
  const now = Date.now();

  if (now - enemy.lastSummonTime >= 4000) {
    enemy.lastSummonTime = now;

    const minionBase = enemyTypes["Botling"];
    const minionStats = scaleEnemyStats(minionBase);
    const minion = {
      type: "Botling",
      name: minionStats.name,
      maxHp: minionStats.maxHp,
      currentHp: minionStats.maxHp,
      damage: minionStats.damage,
      xpReward: minionStats.xpReward,
      shieldActive: false,
      shieldCooldownEnd: 0,
      rocketActive: false,
      rocketTicksLeft: 0,
      stunned: false,
      poisoned: false
    };

    activeEnemies.push(minion);
    showTemporaryText(`${enemy.name} summons a minion!`);
    drawBattleUI();
  }

  if (!enemy.stunned) {
    normalAttack(enemy, target);
  }
}

function secondStageBossBehavior(enemy, target) {
  if (!enemy.stunned) {
    normalAttack(enemy, target);
  }
}

  // snowtel boss
function iceBossBehavior(enemy, target) {
  const now = Date.now();

  if (!enemy.lastFreezeTime) enemy.lastFreezeTime = 0;

  if (enemy.shieldActive) {
    return;
  }

  // Freeze cooldown: every 8 seconds
  if (now - enemy.lastFreezeTime >= 8000) {
    enemy.lastFreezeTime = now;

    // Freeze effect: disable attack button and freeze players for 3 seconds
    showTemporaryText(`${enemy.name} unleashes an icy blast! Everyone is frozen!`);

    // Disable player's attack button
    const attackButton = document.getElementById('attack-button');
    const specialButton1 = document.getElementById('special-attack-button-1');
    const specialButton2 = document.getElementById('special-attack-button-2');
    const inventoryBattleButton = document.getElementById('inventory-battle-button');

    if (attackButton) attackButton.disabled = true;
    if (specialButton1) specialButton1.disabled = true;
    if (specialButton2) specialButton2.disabled = true;
    if (inventoryBattleButton) inventoryBattleButton.disabled = true;

    // Also stun active ally if present
    if (activeAlly) {
      activeAlly.stunned = true;
    }

    setTimeout(() => {
      if (attackButton) attackButton.disabled = false;
      if (specialButton1) specialButton1.disabled = false;
      if (specialButton2) specialButton2.disabled = false;
      if (inventoryBattleButton) inventoryBattleButton.disabled = false;

      if (activeAlly) {
        activeAlly.stunned = false;
      }
      showTemporaryText(`The ice melts away, and you can move again!`);
      drawPlayerBattleStatus();
    }, 3000);

    return;
  }

  // Normal attack if not frozen/stunned
  if (!enemy.stunned) {
    normalAttack(enemy, target);
  }
}

//mortuary boss
function lifeStealBossBehavior(enemy, target) {
  if (enemy.shieldActive) {
    return;
  }

  if (!enemy.stunned) {
    const damage = enemy.damage || 0;

    // Deal damage to target
    if (target === playerStats) {
      playerTakeDamage(damage);
      showTemporaryText(`${enemy.name} life steals you for ${damage} damage!`);
    } else if (target === activeAlly) {
      activeAlly.currentHp -= damage;
      if (activeAlly.currentHp < 0) activeAlly.currentHp = 0;
      showTemporaryText(`${enemy.name} life steals ${activeAlly.name} for ${damage} damage!`);
      if (activeAlly.currentHp === 0) {
        showTemporaryText(`${activeAlly.name} has been defeated!`);
        clearInterval(activeAlly.attackTimerId);
        activeAlly.attackTimerId = null;
      }
    }

    // Heal boss for damage dealt to either target
    enemy.currentHp += damage;
    if (enemy.currentHp > enemy.maxHp) enemy.currentHp = enemy.maxHp;
    showTemporaryText(`${enemy.name} heals for ${damage} HP!`);

    drawBattleUI();
    drawPlayerBattleStatus();
  }
}
// Cave boss 
function caveBossBehavior(enemy, target) {
  // Spawn shards
  if (!enemy._shardIntervalId) {
    enemy._shardIntervalId = setInterval(() => {
      if (!inBattle) return;
      const shardBase = enemyTypes['CrystalShard'];
      const mult = getDifficultyMultipliers();
      const shard = {
        type: 'CrystalShard',
        name: shardBase.name,
        maxHp: Math.max(1, Math.floor(shardBase.maxHp * mult.enemyHp)),
        currentHp: Math.max(1, Math.floor(shardBase.maxHp * mult.enemyHp)),
        damage: Math.max(0, Math.floor(shardBase.damage * mult.enemyDmg)),
        xpReward: shardBase.xpReward || 0,
        shieldActive: false,
        shieldCooldownEnd: 0,
        rocketActive: false,
        rocketTicksLeft: 0,
        stunned: false,
        poisoned: false,
        resistances: shardBase.defaultResistances || {}
      };
      activeEnemies.push(shard);
      drawBattleUI();
      showTemporaryText('A Crystal Shard appears!');
    }, 1500);
  }

  // Blackout cycle
  const hpPercent = (enemy.currentHp / enemy.maxHp) * 100;
  if (hpPercent <= 50) {
    if (!enemy._blackoutRunning) {
      enemy._blackoutRunning = true;

      // Start the repeating cycle
      enemy._blackoutIntervalId = setInterval(() => {
        // begin blackout
        showBattleBlackout();
        showTemporaryText('Darkness covers the battlefield!');
        // end blackout after 9s (1s visibility remains)
        setTimeout(() => {
          hideBattleBlackout();
          showTemporaryText('You can see for a moment...');
        }, 9000);
      }, 10000);

      // trigger the first cycle immediately
      showBattleBlackout();
      showTemporaryText('Darkness covers the battlefield!');
      setTimeout(() => {
        hideBattleBlackout();
        showTemporaryText('You can see for a moment...');
      }, 9000);
    }
  }

  // Regular attacks while not stunned
  if (!enemy.stunned) {
    const dmg = enemy.damage || 0;
    if (target === playerStats) {
      playerTakeDamage(dmg);
      showTemporaryText(`${enemy.name} lashes out for ${dmg} damage!`);
    } else if (target === activeAlly && activeAlly) {
      activeAlly.currentHp -= dmg;
      if (activeAlly.currentHp < 0) activeAlly.currentHp = 0;
      showTemporaryText(`${enemy.name} attacks ${activeAlly.name} for ${dmg} damage!`);
      if (activeAlly.currentHp === 0) {
        showTemporaryText(`${activeAlly.name} has been defeated!`);
        clearInterval(activeAlly.attackTimerId);
        activeAlly.attackTimerId = null;
      }
    }
  }
}
//mystic mountain boss

  function findMountainBoss() {
  return activeEnemies.find(e => e && e.type === 'MountainBoss');
}

  function spawnMountainPen(boss) {
  if (!inBattle || !boss || boss.currentHp <= 0) return null;

  // If a pen already exists (in activeEnemies or referenced on boss), don't spawn another
  if (boss._hasPen || activeEnemies.some(e => e && e._isMountainPen)) return null;

  const pen = {
    type: 'MountainPen',
    name: 'Pen',
    maxHp: 100,
    currentHp: 100,
    damage: 0,
    xpReward: 0,
    shieldActive: false,
    stunned: false,
    poisoned: false,
    _isMountainPen: true,
    _ownerBossId: boss._internalId || (boss._internalId = Date.now() + Math.random()),
    _sheepIntervalId: null,
    _spawnedSheep: []
  };

  // Pen behavior: spawn a sheep every sheepSummonIntervalMs
  pen._sheepIntervalId = setInterval(() => {
    if (!inBattle || !activeEnemies.includes(boss) || boss.currentHp <= 0) {
      // boss dead or battle ended -> clean up
      clearInterval(pen._sheepIntervalId);
      pen._sheepIntervalId = null;
      return;
    }
    spawnMountainSheep(pen, boss);
  }, MOUNTAIN_PEN_CONFIG.sheepSummonIntervalMs);

 
  activeEnemies.push(pen);
  boss._hasPen = true;
  boss._penRef = pen;

  showTemporaryText(`${boss.name} conjures a pen!`);
  drawBattleUI();
  return pen;
}


function spawnMountainSheep(pen, boss) {
  if (!pen || !boss || !inBattle) return;
  
  const sheep = {
    type: 'PenSheep',
    name: 'Sheep',
    maxHp: 9999,   
    currentHp: 9999,
    damage: 0,
    xpReward: 0,
    shieldActive: false,
    stunned: false,
    poisoned: false,
    _isSheep: true,
  };

  
  activeEnemies.push(sheep);
  pen._spawnedSheep.push(sheep);
  drawBattleUI();
  showTemporaryText('A sheep spawns from the pen');

  
  setTimeout(() => {
    // If boss still valid and alive, heal
    if (boss && boss.currentHp != null && boss.currentHp > 0) {
      const heal = Math.max(1, Math.ceil((boss.maxHp || 1) * MOUNTAIN_PEN_CONFIG.sheepHealPercent));
      boss.currentHp = Math.min(boss.maxHp, (boss.currentHp || 0) + heal);
      showTemporaryText(`${boss.name} devours a sheep and heals for ${heal} HP!`);
      // reflect in UI
      drawPlayerBattleStatus();
    }

    // Remove sheep from activeEnemies
    const si = activeEnemies.indexOf(sheep);
    if (si > -1) activeEnemies.splice(si, 1);
    // Also remove from pen._spawnedSheep
    if (pen && Array.isArray(pen._spawnedSheep)) {
      pen._spawnedSheep = pen._spawnedSheep.filter(s => s !== sheep);
    }
    drawBattleUI();
  }, MOUNTAIN_PEN_CONFIG.sheepLifetimeMs);
}

// 
function startMountainPenCycle(boss) {
  if (!boss || boss._penCycleStarted) return;
  boss._penCycleStarted = true;

  // Make sure pen respawns every penRespawnIntervalMs if none present
  boss._penRespawnInterval = setInterval(() => {
    if (!inBattle || boss.currentHp <= 0) {
      clearInterval(boss._penRespawnInterval);
      boss._penRespawnInterval = null;
      return;
    }

    // If pen already present and alive, skip
    const penPresent = activeEnemies.some(e => e && e._isMountainPen && e._ownerBossId === boss._internalId);
    if (!penPresent) {
      spawnMountainPen(boss);
    }
  }, MOUNTAIN_PEN_CONFIG.penRespawnIntervalMs);

  // Try to spawn a pen immediately
  spawnMountainPen(boss);
}
function mountainBossBehavior(enemy, target) {
  // set up on first tick
  if (!enemy._initialized) {
    enemy._initialized = true;
    enemy._spawnAt = Date.now();
    enemy._fireTicks = []; // track active fire tick intervals (so we can clear)
    enemy.enraged = false;
    // after 30s become enraged if still alive
    enemy._enrageTimeout = setTimeout(() => {
      if (activeEnemies.includes(enemy) && enemy.currentHp > 0) {
        enemy.enraged = true;
        showTemporaryText(`${enemy.name} becomes enraged! Its attacks deal double damage!`);
      }
    }, 30000);
  }

  // If shield active, skip other actions
  if (enemy.shieldActive) return;

  // 33% chance to spit fire each action -> apply a DOT tick every 1s for 4 ticks (massive)
  if (Math.random() < 0.33) {
    const DOT_TICKS = 4;
    const DOT_INTERVAL = 1000;
    const baseDot = Math.max(5, Math.round(enemy.damage * 0.8)); // base per tick
    let ticks = 0;
    showTemporaryText(`${enemy.name} spits a cone of fire!`);
    const id = setInterval(() => {
      if (!activeEnemies.includes(enemy) || ticks >= DOT_TICKS) {
        clearInterval(id);
        return;
      }
      // apply to chosen target(s)
      const dotDamage = baseDot;
      // prefer player, if ally present sometimes hit them
      const dotTarget = (activeAlly && activeAlly.currentHp > 0 && Math.random() < 0.5) ? activeAlly : playerStats;
      if (dotTarget === playerStats) {
        playerTakeDamage(dotDamage);
        showTemporaryText(`${enemy.name}'s fire scorches you for ${dotDamage} damage!`);
      } else {
        activeAlly.currentHp = Math.max(0, activeAlly.currentHp - dotDamage);
        showTemporaryText(`${enemy.name}'s fire scorches ${activeAlly.name} for ${dotDamage} damage!`);
      }
      ticks++;
      drawBattleUI();
      drawPlayerBattleStatus();
      drawPartyStatus();
    }, DOT_INTERVAL);
    enemy._fireTicks.push(id);
  }
  if (!enemy._penCycleStarted && (enemy.currentHp / enemy.maxHp) <= 0.30) { startMountainPenCycle(enemy); }

  function mountainBossPenTrigger(enemy) {
  if (!enemy || enemy._penCycleStarted) return;
  if ((enemy.currentHp / (enemy.maxHp || 1)) <= 0.30) {
    startMountainPenCycle(enemy);
    showTemporaryText(`${enemy.name} starts searching for pens to heal!`);
  }
}
  // normal attack (double damage if enraged)
  const baseDamage = enemy.damage || 0;
  const finalDamage = enemy.enraged ? baseDamage * 2 : baseDamage;
  // choose target
  let chosen = playerStats;
  if (activeAlly && activeAlly.currentHp > 0 && Math.random() < 0.4) chosen = activeAlly;
  if (chosen === playerStats) {
    playerTakeDamage(finalDamage);
    showTemporaryText(`${enemy.name} bites and smashes you for ${finalDamage} damage!`);
  } else {
    activeAlly.currentHp = Math.max(0, activeAlly.currentHp - finalDamage);
    showTemporaryText(`${enemy.name} bites ${activeAlly.name} for ${finalDamage} damage!`);
    if (activeAlly.currentHp === 0) {
      showTemporaryText(`${activeAlly.name} has been defeated!`);
      clearInterval(activeAlly.attackTimerId);
      activeAlly.attackTimerId = null;
    }
  }
}

// Ensure cleanup in handleEnemyDeath for MountainBoss (clear timers)
const _orig_handleEnemyDeath = handleEnemyDeath;
handleEnemyDeath = function(enemy, idx) {
  // clear boss-specific timers/intervals safely
  try {
    if (enemy._enrageTimeout) { clearTimeout(enemy._enrageTimeout); enemy._enrageTimeout = null; }
    if (enemy._fireTicks && enemy._fireTicks.length) {
      enemy._fireTicks.forEach(id => clearInterval(id));
      enemy._fireTicks = [];
    }
    if (enemy._shardIntervalId) { clearInterval(enemy._shardIntervalId); enemy._shardIntervalId = null; }
    if (enemy._blackoutIntervalId) { clearInterval(enemy._blackoutIntervalId); enemy._blackoutIntervalId = null; }
  } catch (e) { console.warn('cleanup error', e); }
  return _orig_handleEnemyDeath(enemy, idx);
};

// ghost
// ---------- spawnGhostTrains ----------
function spawnGhostTrains(ghostEnemy) {
  // remove any leftover trains for safety
  activeEnemies = activeEnemies.filter(e => !(e && e._isGhostTrain));

  // spawn 3 trains; one will host the ghost (ghostEnemy._hiddenInIndex)
  const trains = [];
  const base = enemyTypes['Train'];
  for (let i = 0; i < 3; i++) {
    const t = {
      type: "Train",
      name: `${base.name} #${i+1}`,
      maxHp: Math.max(1, Math.floor(base.maxHp)),
      currentHp: Math.max(1, Math.floor(base.maxHp)),
      damage: 0,
      xpReward: 0,
      shieldActive: false,
      rocketActive: false,
      stunned: false,
      poisoned: false,
      _isGhostTrain: true,
      _trainIndex: i
    };
    trains.push(t);
    activeEnemies.push(t);
  }

  // ensure ghost has a host index
  ghostEnemy._hiddenInIndex = (typeof ghostEnemy._hiddenInIndex === 'number')
    ? ghostEnemy._hiddenInIndex
    : Math.floor(Math.random() * 3);

  // mark the ghost as hidden and note trains spawned
  ghostEnemy._isHidden = true;
  ghostEnemy._hostTrainSpawned = true;

  showTemporaryText(`${ghostEnemy.name} hides among the phantom carriages!`);
  drawBattleUI();
  return trains;
}

// ---------- ghostHideCycle ----------
function ghostHideCycle(ghost) {
  // clear any existing hide timer
  if (ghost._hideTimeout) {
    clearTimeout(ghost._hideTimeout);
    ghost._hideTimeout = null;
  }
  ghost._hideTimeoutScheduled = false;

  // only schedule when currently revealed, alive, and battle active
  if (ghost._isHidden || ghost.currentHp <= 0 || !inBattle) return;

  const delay = 8000 + Math.floor(Math.random() * 4000); // 8-12s
  ghost._hideTimeout = setTimeout(() => {
    ghost._hideTimeout = null;
    ghost._hideTimeoutScheduled = false;
    if (!inBattle || ghost.currentHp <= 0) return;

    // stop any visible spectral spawner
    if (ghost._spectralIntervalId) { clearInterval(ghost._spectralIntervalId); ghost._spectralIntervalId = null; }

    // hide: remove ghost from activeEnemies and spawn trains
    ghost._isHidden = true;
    ghost._hostTrainSpawned = false;
    ghost._hiddenInIndex = Math.floor(Math.random() * 3);
    activeEnemies = activeEnemies.filter(e => e !== ghost);
    spawnGhostTrains(ghost);

    showTemporaryText(`${ghost.name} slips back into the phantom carriages...`);
    drawBattleUI();
  }, delay);
}

// ---------- revealGhostFromTrain ----------
function revealGhostFromTrain(deadTrain) {
  // find ghost reference
  let ghost = activeEnemies.find(e => e && e.type === 'GhostBoss');
  if (!ghost) ghost = window._lastGhostRef;
  if (!ghost) return;

  // If train is not host and other trains remain, just remove the dead train
  if (deadTrain._trainIndex !== ghost._hiddenInIndex) {
    activeEnemies = activeEnemies.filter(e => !(e && e._isGhostTrain && e._trainIndex === deadTrain._trainIndex));
    // if no trains left and ghost still hidden, respawn trains
    const remainingTrains = activeEnemies.filter(e => e && e._isGhostTrain);
    if (remainingTrains.length === 0 && ghost._isHidden) {
      spawnGhostTrains(ghost);
    }
    drawBattleUI();
    return;
  }

  // If dead train was the host, reveal immediately
  activeEnemies = activeEnemies.filter(e => !(e && e._isGhostTrain));
  if (!activeEnemies.includes(ghost)) activeEnemies.push(ghost);

  ghost._isHidden = false;
  ghost._hostTrainSpawned = false;

  // start spectral minion spawner for revealed ghost (if not already)
  if (ghost._spectralIntervalId) { clearInterval(ghost._spectralIntervalId); ghost._spectralIntervalId = null; }
  ghost._spectralIntervalId = setInterval(() => {
    if (!inBattle || !activeEnemies.includes(ghost) || ghost.currentHp <= 0) {
      if (ghost._spectralIntervalId) { clearInterval(ghost._spectralIntervalId); ghost._spectralIntervalId = null; }
      return;
    }
    const base = enemyTypes.SpectralMinion;
    const m = {
      type: 'SpectralMinion',
      name: base.name,
      maxHp: base.maxHp,
      currentHp: base.maxHp,
      damage: base.damage,
      xpReward: base.xpReward,
      shieldActive: false,
      stunned: false,
      poisoned: false
    };
    activeEnemies.push(m);
    showTemporaryText('A spectral minion emerges!');
    drawBattleUI();
  }, 3000);

  showTemporaryText(`${ghost.name} is revealed!`);
  drawBattleUI();

  // schedule a future hide now that the ghost is visible
  ghostHideCycle(ghost);
}

// ---------- ghostBossBehavior ----------
function ghostBossBehavior(enemy, target) {
  // initialization (only once)
  if (!enemy._initialized) {
    enemy._initialized = true;
    enemy._isHidden = true;
    enemy._hostTrainSpawned = false;
    enemy._hiddenInIndex = Math.floor(Math.random() * 3);
    // if the boss is present in activeEnemies, remove it and spawn trains instead
    if (activeEnemies.includes(enemy)) activeEnemies = activeEnemies.filter(e => e !== enemy);
    spawnGhostTrains(enemy);

    // spawn spectral minions while hidden
    if (enemy._spectralIntervalId) { clearInterval(enemy._spectralIntervalId); enemy._spectralIntervalId = null; }
    enemy._spectralIntervalId = setInterval(() => {
      if (!inBattle || !enemy._isHidden || enemy.currentHp <= 0) {
        if (enemy._spectralIntervalId) { clearInterval(enemy._spectralIntervalId); enemy._spectralIntervalId = null; }
        return;
      }
      const base = enemyTypes.SpectralMinion;
      const m = {
        type: 'SpectralMinion',
        name: base.name,
        maxHp: base.maxHp,
        currentHp: base.maxHp,
        damage: base.damage,
        xpReward: base.xpReward,
        shieldActive: false,
        stunned: false,
        poisoned: false
      };
      activeEnemies.push(m);
      showTemporaryText('A spectral minion emerges from the trains!');
      drawBattleUI();
    }, 3000);
    // Ensure global reference for spawn/reveal handlers
    window._lastGhostRef = enemy;
    return;
  }

  // If hidden, behavior is managed by trains and spectral spawner; do nothing per-turn
  if (enemy._isHidden) return;

  // revealed behavior: normal attack like other bosses
  if (enemy.shieldActive || enemy.stunned) return;
  const dmg = enemy.damage || 0;
  let chosen = playerStats;
  if (activeAlly && activeAlly.currentHp > 0 && Math.random() < 0.5) chosen = activeAlly;
  if (chosen === playerStats) {
    playerTakeDamage(dmg);
    showTemporaryText(`${enemy.name} lashes you with ethereal claws for ${dmg} damage!`);
  } else {
    activeAlly.currentHp = Math.max(0, activeAlly.currentHp - dmg);
    showTemporaryText(`${enemy.name} slashes ${activeAlly.name} for ${dmg} damage!`);
    if (activeAlly.currentHp === 0) {
      showTemporaryText(`${activeAlly.name} has been defeated!`);
      clearInterval(activeAlly.attackTimerId);
      activeAlly.attackTimerId = null;
    }
  }
  drawBattleUI();
  drawPlayerBattleStatus();
  drawPartyStatus();


  if (!enemy._hideTimeoutScheduled && Math.random() < 0.95) {
    enemy._hideTimeoutScheduled = true;
    enemy._hideTimeout = setTimeout(() => {
      enemy._hideTimeoutScheduled = false;
      if (enemy._hideTimeout) { clearTimeout(enemy._hideTimeout); enemy._hideTimeout = null; }
      if (!inBattle || enemy.currentHp <= 0) return;

      // stop visible spectral spawner while hiding (if any)
      if (enemy._spectralIntervalId) { clearInterval(enemy._spectralIntervalId); enemy._spectralIntervalId = null; }

      // hide and spawn trains
      enemy._isHidden = true;
      activeEnemies = activeEnemies.filter(e => !(e && e.type === 'Train'));
      spawnGhostTrains(enemy);

      showTemporaryText(`${enemy.name} fades into the phantom carriages!`);
      drawBattleUI();
    }, 4000 + Math.floor(Math.random() * 3000));
  }
}

// ---------- handleEnemyDeath wrapper (ensure trains and reveal logic) ----------
const __orig_handleEnemyDeath = handleEnemyDeath;
handleEnemyDeath = function(enemy, idx) {
  // call original logic first to handle XP, removal, etc.
  const res = __orig_handleEnemyDeath(enemy, idx);

  // If a train died and a hidden ghost exists, handle reveal/respawn
  if (enemy && enemy._isGhostTrain) {
    let ghost = activeEnemies.find(e => e && e.type === 'GhostBoss');
    if (!ghost) ghost = window._lastGhostRef;
    if (!ghost) return res;

    // If ghost is hidden and host train died -> reveal
    if (ghost._isHidden) {
      if (enemy._trainIndex === ghost._hiddenInIndex) {
        revealGhostFromTrain(enemy); // reveals and schedules next hide
        // guard: ensure hide cycle will be called again after reveal (revealGhostFromTrain does this)
      } else {
        // non-host train died: remove it; if none remain, respawn trains
        const remainingTrains = activeEnemies.filter(e => e && e._isGhostTrain);
        if (remainingTrains.length === 0 && ghost && ghost._isHidden) {
          spawnGhostTrains(ghost);
          ghost._hostTrainSpawned = true;
        }
      }
    }
  }

  return res;
};
  
function IslandBossPresent() {
  return activeEnemies && activeEnemies.some(e => e && e.type === 'IslandBoss');
}

function islandBossBehavior(enemy, target) {
  if (enemy.shieldActive || enemy.stunned) return;

  // ensure raft exists for this fight; if not, initialize safe default
  if (!window._raft) window._raft = { maxHp: 12, hp: 12 };

  // per-action cooldown so boss doesn't attack every tick (tune ms)
  if (!enemy._lastAction) enemy._lastAction = 0;
  const now = Date.now();
  if (now - enemy._lastAction < 800) return; // boss acts at most ~once per 800ms
  enemy._lastAction = now;

  // choose target (50/50 preference for ally if present)
  let chosen = playerStats;
  if (activeAlly && activeAlly.currentHp > 0 && Math.random() < 0.5) chosen = activeAlly;

  // Attack landing logic only reduces raft when it damages the player (not ally)
  const isPiercing = Math.random() < 0.25; // 25% piercing
  const baseDamage = Math.max(0, Number(enemy.damage) || 0);

  if (chosen === playerStats) {
    // damage player
    playerTakeDamage(baseDamage);
    // drain raft HP: 1 normal, 2 piercing
    const drain = isPiercing ? 2 : 1;
    window._raft.hp = Math.max(0, window._raft.hp - drain);
    showTemporaryText(`${enemy.name} attacks your raft and you for ${baseDamage} damage! Raft -${drain}.`);
    // piercing special message
    if (isPiercing) showTemporaryText(`${enemy.name} pierced through the raft!`);
    drawPlayerBattleStatus();
    drawBattleUI();

    // raft destroyed => player dies immediately
    if (window._raft.hp <= 0) {
      showTemporaryText('Your raft breaks apart — you are lost to the sea!');
      // Force player death/instant lose
      playerStats.currentHp = 0;
      updateHp(0);
      endBattle('lose');
      return;
    }
  } else {
    // hit ally only, does not drain raft
    activeAlly.currentHp = Math.max(0, activeAlly.currentHp - baseDamage);
    showTemporaryText(`${enemy.name} hits ${activeAlly.name} for ${baseDamage} damage!`);
    if (activeAlly.currentHp === 0) {
      showTemporaryText(`${activeAlly.name} has been defeated!`);
      clearInterval(activeAlly.attackTimerId);
      activeAlly.attackTimerId = null;
    }
    drawPartyStatus();
    drawBattleUI();
  }
}

  function factoryBehavior(enemy, target) {
  // one-time init
  if (!enemy._initialized) {
    enemy._initialized = true;
    enemy._robospawnInterval = null;
    enemy._lifecoreInterval = null;
    enemy._robospawnCount = 0;
    enemy._lifeCoreRefs = []; // track active life cores
    enemy._spawnedEntities = []; // track spawned enemies for cleanup

    // spawn roboworkers every 500ms
    enemy._robospawnInterval = setInterval(() => {
      if (!inBattle || enemy.currentHp <= 0) return;
      // keep spawn rate bounded to avoid runaway
      if (enemy._robospawnCount > 60) return;

      const base = enemyTypes.Roboworker;
      const mult = getDifficultyMultipliers();
      const r = {
        type: 'Roboworker',
        name: base.name,
        maxHp: Math.max(1, Math.floor(base.maxHp * mult.enemyHp)),
        currentHp: Math.max(1, Math.floor(base.maxHp * mult.enemyHp)),
        damage: Math.max(0, Math.floor(base.damage * mult.enemyDmg)),
        xpReward: base.xpReward || 0,
        shieldActive: false,
        stunned: false,
        poisoned: false,
        resistances: base.defaultResistances || {}
      };
      enemy._robospawnCount++;
      enemy._spawnedEntities.push(r);
      activeEnemies.push(r);
      drawBattleUI();
    }, 500);

    // spawn a Life Core every 5000ms
    enemy._lifecoreInterval = setInterval(() => {
      if (!inBattle || enemy.currentHp <= 0) return;

      // create a Life Core and link it to the factory as a protector
      const base = enemyTypes.LifeCore;
      const mult = getDifficultyMultipliers();
      const lc = {
        type: 'LifeCore',
        name: base.name,
        maxHp: Math.max(1, Math.floor(base.maxHp * mult.enemyHp)),
        currentHp: Math.max(1, Math.floor(base.maxHp * mult.enemyHp)),
        damage: base.damage || 0,
        xpReward: base.xpReward || 0,
        shieldActive: false,
        stunned: false,
        poisoned: false,
        resistances: base.defaultResistances || {}
      };

      // track
      enemy._lifeCoreRefs.push(lc);
      enemy._spawnedEntities.push(lc);
      activeEnemies.push(lc);

      // when a life core dies, we'll remove references (handled elsewhere)
      drawBattleUI();
    }, 5000);

    // initial shield state: if any lifeCore exists, keep shield active
    enemy.shieldActive = (enemy._lifeCoreRefs.length > 0);
  }

  // Maintain shield while any LifeCore exists
  // Purge stale refs (in case quality of references changes)
  enemy._lifeCoreRefs = enemy._lifeCoreRefs.filter(ref => ref && ref.currentHp > 0 && activeEnemies.includes(ref));
  const anyLifeCoreAlive = enemy._lifeCoreRefs.length > 0;

  if (anyLifeCoreAlive) {
    if (!enemy.shieldActive) {
      enemy.shieldActive = true;
      showTemporaryText(`${enemy.name} draws power from its Life Cores and shields itself!`);
    }
  } else {
    if (enemy.shieldActive) {
      enemy.shieldActive = false;
      showTemporaryText(`${enemy.name}'s Life Cores are gone — its shield drops!`);
    }
  }

  // Factory performs occasional direct attacks if not shielded
  if (!enemy.shieldActive && !enemy.stunned) {
    // basic attack behaviour: pick a target (player or ally)
    const now = Date.now();
    if (!enemy._lastAttack || (now - enemy._lastAttack) > 1200) {
      enemy._lastAttack = now;
      const chosen = (activeAlly && activeAlly.currentHp > 0 && Math.random() < 0.5) ? activeAlly : playerStats;
      const dmg = enemy.damage || 0;
      if (chosen === playerStats) {
        playerTakeDamage(dmg);
        showTemporaryText(`${enemy.name} slams you for ${dmg} damage!`);
      } else {
        activeAlly.currentHp = Math.max(0, activeAlly.currentHp - dmg);
        showTemporaryText(`${enemy.name} smashes ${activeAlly.name} for ${dmg} damage!`);
        if (activeAlly.currentHp === 0) {
          showTemporaryText(`${activeAlly.name} has been defeated!`);
          clearInterval(activeAlly.attackTimerId);
          activeAlly.attackTimerId = null;
        }
      }
      drawBattleUI();
      drawPlayerBattleStatus();
      drawPartyStatus();
    }
  }
}

  function lifeCoreBehavior(enemy, target) {
    if (!enemy || enemy.currentHp == null) return;

  
  if (!enemy.stunned && !enemy.shieldActive) {
    const regen = Math.max(0, Math.floor(enemy.maxHp * 0.05));
    if (regen > 0) {
      enemy.currentHp = Math.min(enemy.maxHp, enemy.currentHp + regen);
      
      if (regen >= 2) showTemporaryText(`${enemy.name} hums and regains ${regen} HP.`);
    }
  }
}
  //dark lord

  function onShadowOrbTurnIncrementMultiplier(shadow) {
  if (!shadow) return;
  if (!shadow._attackMultiplier) shadow._attackMultiplier = 1;
  else shadow._attackMultiplier++;
}

function shadowOrbBehavior(enemy, target) {
  onShadowOrbTurnIncrementMultiplier(enemy);
  const multiplier = enemy._attackMultiplier || 1;
  const baseDmg = enemy.damage || 0;
  const damage = baseDmg * multiplier;
  if (target === playerStats) {
    playerTakeDamage(damage);
    showTemporaryText(`${enemy.name} attacks you for ${damage} dmg (x${multiplier})`);
  } else if (target === activeAlly) {
    if (activeAlly) {
      activeAlly.currentHp = Math.max(0, activeAlly.currentHp - damage);
      showTemporaryText(`${enemy.name} attacks ${activeAlly.name} for ${damage} dmg (x${multiplier})`);
      if (activeAlly.currentHp === 0) {
        showTemporaryText(`${activeAlly.name} has been defeated!`);
        if (activeAlly.attackTimerId) { clearInterval(activeAlly.attackTimerId); activeAlly.attackTimerId = null; }
        activeAlly = null;
      }
    }
  }
  drawBattleUI();
  drawPlayerBattleStatus();
  if (typeof drawPartyStatus === 'function') drawPartyStatus();
}

function lightOrbBehavior(enemy) {
  // idle — effect handled on death
}


function finalBossStage1Behavior(enemy, target) {
  if (!enemy._initialized) {
  enemy._initialized = true;
  // clear any leftover timers just in case
  if (enemy._eyeSpawnTimeout) { clearTimeout(enemy._eyeSpawnTimeout); enemy._eyeSpawnTimeout = null; }

  enemy._eyeSpawnTimeout = setTimeout(() => {
    // only spawn if this instance still exists and is alive
    if (!inBattle) return;
    if (enemy.currentHp <= 0) return;
    if (!activeEnemies.includes(enemy)) return;

    // build Eye using safe multipliers
    const base = enemyTypes.Eye || { name: 'Watcher Eye', maxHp: 100, damage: 6, xpReward: 0 };
    const mult = (typeof getDifficultyMultipliers === 'function') ? getDifficultyMultipliers() : { enemyHp: 1, enemyDmg: 1 };
    const eye = {
      type: 'Eye',
      name: base.name,
      maxHp: Math.max(1, Math.floor(base.maxHp * (mult.enemyHp || 1))),
      currentHp: Math.max(1, Math.floor(base.maxHp * (mult.enemyHp || 1))),
      damage: Math.max(0, Math.floor(base.damage * (mult.enemyDmg || 1))),
      xpReward: base.xpReward || 0,
      shieldActive: false,
      stunned: false,
      poisoned: false,
      resistances: base.defaultResistances || {}
    };

    // insert Eye just after this enemy in the list
    const idx = activeEnemies.indexOf(enemy);
    const insertAt = (idx >= 0) ? idx + 1 : activeEnemies.length;
    activeEnemies.splice(insertAt, 0, eye);

    showTemporaryText(`${enemy.name} summons a Watcher Eye!`);
    drawBattleUI();
  }, 5000);
}
  if (!enemy.stunned && !enemy.shieldActive) {
  const dmg = enemy.damage || 0;

  if (target === playerStats) {
    playerTakeDamage(dmg);
    showTemporaryText(`${enemy.name} lashes out for ${dmg} damage!`);
  } else if (target === activeAlly && activeAlly) {
    activeAlly.currentHp = Math.max(0, activeAlly.currentHp - dmg);
    showTemporaryText(`${enemy.name} hits ${activeAlly.name} for ${dmg} damage!`);

    if (activeAlly.currentHp === 0 && activeAlly.attackTimerId) {
      clearInterval(activeAlly.attackTimerId);
      activeAlly.attackTimerId = null;
    }
  }
}

drawBattleUI();
drawPlayerBattleStatus();
}

// Stage 2 behavior: orb + dark-timer mechanics
function finalBossStage2Behavior(enemy, target) {
  // safe defaults
  if (!enemy) return;
  const now = Date.now();
  const ORB_COOLDOWN_MS = 10000; // 10s cooldown
  const mult = (typeof getDifficultyMultipliers === 'function') ? getDifficultyMultipliers() : { enemyHp: 1, enemyDmg: 1 };

  // Orb spawning: spawn 1-2 shadow orbs once per cooldown window
  if (!enemy.stunned && enemy._canSpawnOrbs !== false) {
    if (!enemy._lastOrbAt) enemy._lastOrbAt = 0;
    if (now - enemy._lastOrbAt >= ORB_COOLDOWN_MS) {
      enemy._lastOrbAt = now;
      const spawnCount = (Math.random() < 0.5) ? 1 : 2;
      const base = (enemyTypes && enemyTypes.ShadowOrb) || { maxHp: 40, damage: 2, name: 'Shadow Orb' };

      // build and push orbs
      for (let i = 0; i < spawnCount; i++) {
        const orb = {
          type: 'ShadowOrb',
          name: base.name || 'Shadow Orb',
          maxHp: Math.max(1, Math.floor((base.maxHp || 40) * (mult.enemyHp || 1))),
          currentHp: Math.max(1, Math.floor((base.maxHp || 40) * (mult.enemyHp || 1))),
          damage: Math.max(0, Math.floor((base.damage || 0) * (mult.enemyDmg || 1))),
          xpReward: base.xpReward || 0,
          shieldActive: false,
          stunned: false,
          poisoned: false,
          resistances: base.defaultResistances ? { ...base.defaultResistances } : {}
        };
        activeEnemies.push(orb);
      }

      if (spawnCount > 0) {
        showTemporaryText(`${enemy.name} spawns ${spawnCount} Shadow Orb${spawnCount > 1 ? 's' : ''}!`);
        drawBattleUI();
      }
    }
  }

  // normal attack (separate from orb cooldown)
  if (!enemy.stunned && !enemy.shieldActive) {
    const dmg = Number(enemy.damage) || 0;
    if (target === playerStats) {
      playerTakeDamage(dmg);
      showTemporaryText(`${enemy.name} slashes you for ${dmg} damage!`);
    } else if (target === activeAlly && activeAlly) {
      activeAlly.currentHp = Math.max(0, activeAlly.currentHp - dmg);
      showTemporaryText(`${enemy.name} slashes ${activeAlly.name} for ${dmg} damage!`);
      if (activeAlly.currentHp === 0 && activeAlly.attackTimerId) {
        clearInterval(activeAlly.attackTimerId);
        activeAlly.attackTimerId = null;
      }
    }
  }

  drawBattleUI();
  drawPlayerBattleStatus();
}


// Stage 3 behavior placeholder (no mechanics yet)
function finalBossStage3Behavior(enemy, target) {
  // Stage 3: placeholder, add mechanics later
  if (!enemy.stunned && !enemy.shieldActive) {
    const dmg = enemy.damage || 0;
    if (target === playerStats) {
      playerTakeDamage(dmg);
      showTemporaryText(`${enemy.name} strikes for ${dmg} damage!`);
    }
  }
  drawBattleUI();
  drawPlayerBattleStatus();
}

//battlefield boss
function critBossBehavior(enemy, target) {
  if (enemy.shieldActive) {
    return;
  }

  if (!enemy.stunned) {
    const isCrit = Math.random() < 0.5;
    const baseDamage = enemy.damage || 0;
    const damage = isCrit ? baseDamage * 3 : baseDamage;

    if (target === playerStats) {
      playerTakeDamage(damage);
      showTemporaryText(`${enemy.name} ${isCrit ? 'critically attacks' : 'attacks'} you for ${damage} damage!`);
    } else if (target === activeAlly) {
      activeAlly.currentHp -= damage;
      if (activeAlly.currentHp < 0) activeAlly.currentHp = 0;
      showTemporaryText(`${enemy.name} ${isCrit ? 'critically attacks' : 'attacks'} ${activeAlly.name} for ${damage} damage!`);
      if (activeAlly.currentHp === 0) {
        showTemporaryText(`${activeAlly.name} has been defeated!`);
        clearInterval(activeAlly.attackTimerId);
        activeAlly.attackTimerId = null;
      }
    }
  }
}


  const battleBlackoutEl = document.getElementById('battle-blackout');

function showBattleBlackout() {
  if (!battleBlackoutEl) return;
  battleBlackoutEl.style.display = 'block';
}

function hideBattleBlackout() {
  if (!battleBlackoutEl) return;
  battleBlackoutEl.style.display = 'none';
}
// Override endBattle to check for second stage boss this is the defunct endbattle idk why i have 2 of em why doesnt the game crash idk
function endBattle(outcome) {
  inBattle = false;
  document.getElementById('battle-overlay').style.display = 'none';

  if (staminaRegenIntervalId) { clearInterval(staminaRegenIntervalId); staminaRegenIntervalId = null; }
  if (enemyAttackIntervalId) { clearInterval(enemyAttackIntervalId); enemyAttackIntervalId = null; }

  if (outcome === 'win') {
    let totalXp = activeEnemies.reduce((sum, enemy) => sum + (enemy.xpReward || 0), 0);

    for (const enemy of activeEnemies) {
      if (enemy.type === "SecondStageBossStage1" && enemy.currentHp <= 0) {
        // Remove stage 1 enemy and spawn stage 2 boss
        activeEnemies = activeEnemies.filter(e => e !== enemy);

        const stage2Base = enemyTypes[enemyTypes.SecondStageBossStage1.secondStageType];
        const stage2Stats = scaleEnemyStats(stage2Base);
        const stage2Enemy = {
          type: "SecondStageBossStage2",
          name: stage2Stats.name,
          maxHp: stage2Stats.maxHp,
          currentHp: stage2Stats.maxHp,
          damage: stage2Stats.damage,
          xpReward: stage2Stats.xpReward,
          shieldActive: false,
          shieldCooldownEnd: 0,
          rocketActive: false,
          rocketTicksLeft: 0,
          stunned: false,
          poisoned: false
        };

        activeEnemies.push(stage2Enemy);
        showTemporaryText(`${stage2Enemy.name} emerges!`);
        inBattle = true;
        enemyAttackIntervalId = setInterval(takeTurn, ENEMY_ATTACK_DELAY);
        drawBattleUI();
        drawPlayerBattleStatus();
        return; // Important to return early so battle continues
      }
    }

    if (activeEnemies.length === 0) {
      gainXP(totalXp);
      playerStats.currentHp = playerStats.maxHp;
      updateHp(playerStats.currentHp);
      if (defeatedZone) removeZone(defeatedZone);
      activeEnemies = [];
      defeatedZone = null;
      draw();
      document.getElementById('player-battle-status').innerHTML = '';
      return;
    }
  } else if (outcome === 'lose') {
    showGameOver();
  }
}

// Healer: heals all allies every 3 seconds
function healerBehavior(enemy) {
  if (!enemy.lastHealTime) enemy.lastHealTime = 0;
  const now = Date.now();

  if (now - enemy.lastHealTime >= 3000) {
    enemy.lastHealTime = now;

    activeEnemies.forEach(ally => {
      if (ally.currentHp < ally.maxHp) {
        const healAmount = Math.floor(ally.maxHp * 0.15); // Heals 15% max HP
        ally.currentHp += healAmount;
        if (ally.currentHp > ally.maxHp) ally.currentHp = ally.maxHp;
      }
    });
    showTemporaryText(`${enemy.name} heals all allies!`);
    drawBattleUI();
  }

  if (!enemy.stunned) {
    normalAttack(enemy);
  }
}

  const MOUNTAIN_PEN_CONFIG = {
  penRespawnIntervalMs: 10000,   // spawn a pen every 10s (if none present)
  sheepSummonIntervalMs: 3000,   // each pen summons a sheep every 3s (or choose a value)
  sheepLifetimeMs: 3000,         // sheep exist for 3s then are "eaten"
  sheepHealPercent: 0.05         // heal boss for 5% of its maxHp when a sheep is eaten
};
  
// Take enemy turn actions
function takeTurn() {
  if (!inBattle) return;

  passiveArmorHeal();

  activeEnemies.forEach(enemy => {
    if (!enemy.stunned) {
      let target = playerStats;
      if (activeAlly && activeAlly.currentHp > 0) {
        target = (Math.random() < 0.5) ? playerStats : activeAlly;
      }

      const behavior = enemyTypes[enemy.type]?.behavior || 'normalAttack';
if (behavior === 'normalAttack') {
  normalAttack(enemy, target);
} else if (behavior === 'sniperAttack') {
  sniperAttack(enemy, target);
} else if (behavior === 'caveBossBehavior') {
  caveBossBehavior(enemy, target);
} else if (behavior === 'bossBehavior') {
  bossBehavior(enemy, target);
} else if (behavior === 'summonerBehavior') {
  summonerBehavior(enemy, target);
} else if (behavior === 'secondStageBossBehavior') {
  secondStageBossBehavior(enemy, target);
} else if (behavior === 'factoryBehavior') {
  factoryBehavior(enemy, target);
} else if (behavior === 'lifeCoreBehavior') {
  lifeCoreBehavior(enemy, target);
} else if (behavior === 'iceBossBehavior') {
  iceBossBehavior(enemy, target);
} else if (behavior === 'lifeStealBossBehavior') {
  lifeStealBossBehavior(enemy, target);
} else if (behavior === 'critBossBehavior') {
  critBossBehavior(enemy, target);
} else if (behavior === 'islandBossBehavior') {
  islandBossBehavior(enemy, target);
} else if (behavior === 'mountainBossBehavior') {
  mountainBossBehavior(enemy, target);
} else if (behavior === 'ghostBossBehavior') {
  ghostBossBehavior(enemy, target);
} else if (behavior === 'finalBossStage1Behavior') {
  finalBossStage1Behavior(enemy, target);
} else if (behavior === 'finalBossStage2Behavior') {
  finalBossStage2Behavior(enemy, target);
} else if (behavior === 'finalBossStage3Behavior') {
  finalBossStage3Behavior(enemy, target);
} else if (behavior === 'shadowOrbBehavior') {
  shadowOrbBehavior(enemy, target);
} else if (behavior === 'lightOrbBehavior') {
  lightOrbBehavior(enemy, target);
} else if (behavior === 'healerBehavior') {
  healerBehavior(enemy, target);
}
    }
  if (!canGoBelow1Hp() && playerStats.currentHp <= 1) {
    playerStats.currentHp = 1;
  }
  updateHp(playerStats.currentHp);
  drawBattleUI();
  drawPlayerBattleStatus();
  drawPartyStatus();

  if (playerStats.currentHp <= 0) {
    endBattle('lose');
    hideBattleBlackout();
  }
    });
}

function startDarkTimer() {
  if (darkTimerActive) return;
  darkTimerActive = true;
  darkTimerMs = 0;
  updateProgressiveDarknessUI();
  if (darkTimerTickInterval) clearInterval(darkTimerTickInterval);
  darkTimerTickInterval = setInterval(() => {
    if (!inBattle) { stopDarkTimer(); return; }
    darkTimerMs += darkTimerTickMs;
    updateProgressiveDarknessUI();
    if (darkTimerMs >= darkTimerLimitMs) {
      clearInterval(darkTimerTickInterval);
      darkTimerTickInterval = null;
      showTemporaryText('The darkness consumes you...');
      playerStats.currentHp = 0;
      updateHp(0);
      stopDarkTimer();
      endBattle('lose');
    }
  }, darkTimerTickMs);
}

function stopDarkTimer() {
  darkTimerActive = false;
  darkTimerMs = 0;
  if (darkTimerTickInterval) { clearInterval(darkTimerTickInterval); darkTimerTickInterval = null; }
  updateProgressiveDarknessUI();
  const hud = document.getElementById('dark-timer-hud');
  if (hud) hud.style.opacity = '0';
}

function reduceDarkTimer(ms) {
  if (!darkTimerActive) return;
  darkTimerMs = Math.max(0, darkTimerMs - ms);
  updateProgressiveDarknessUI();
  showTemporaryText(`Dark Timer reduced by ${Math.round(ms/1000)}s!`);
}

  
(function ensureAbilityButtons() {
  const controls = document.getElementById('battle-controls');
  if (!controls) return;

  // helper to create a button with overlay
  function makeBtn(id, text) {
    if (document.getElementById(id)) return document.getElementById(id);
    const btn = document.createElement('button');
    btn.id = id;
    btn.className = 'ability-button';
    btn.style.position = 'relative';
    btn.style.overflow = 'hidden';
    btn.style.minWidth = '90px';
    btn.style.fontSize = '10px';
    btn.textContent = text;
    // cooldown overlay
    const overlay = document.createElement('div');
    overlay.className = id + '-overlay';
    overlay.style.position = 'absolute';
    overlay.style.left = '0';
    overlay.style.top = '0';
    overlay.style.width = '100%';
    overlay.style.height = '100%';
    overlay.style.background = 'rgba(0,0,0,0.6)';
    overlay.style.display = 'none';
    overlay.style.pointerEvents = 'none';
    overlay.style.transition = 'width 0.2s linear';
    overlay.style.zIndex = '100';
    btn.appendChild(overlay);
    controls.insertBefore(btn, controls.querySelector('#inventory-battle-button')); // place before inventory button
    return btn;
  }

  makeBtn('ability-block', 'Block');
  makeBtn('ability-counter', 'Counter');
  makeBtn('ability-cleanse', 'Cleanse');
})();

// Update ability buttons UI (disabled, overlay)
function updateAbilityButtonsUI() {
  const now = Date.now();
  ['block','counter','cleanse'].forEach(name => {
    const btn = document.getElementById(`ability-${name}`);
    if (!btn) return;
    const overlay = btn.querySelector(`.${btn.id}-overlay`);
    const cd = abilityCooldowns[name] || 0;
    if (cd <= 0) {
      btn.disabled = false;
      if (overlay) overlay.style.display = 'none';
      btn.style.opacity = '1';
    } else {
      btn.disabled = true;
      if (overlay) {
        overlay.style.display = 'block';
        // width corresponds to fraction remaining
        const frac = Math.max(0, Math.min(1, cd / ABILITIES[name].cooldownMs));
        overlay.style.width = `${frac * 100}%`;
      }
      btn.style.opacity = '0.6';
    }
  });

  // show active indicators for block/counter windows
  const blockBtn = document.getElementById('ability-block');
  if (blockBtn) blockBtn.style.boxShadow = blockActive ? '0 0 10px 3px rgba(0,200,255,0.7)' : '';
  const counterBtn = document.getElementById('ability-counter');
  if (counterBtn) counterBtn.style.boxShadow = counterWindowActive ? '0 0 10px 3px rgba(255,200,0,0.7)' : '';
}

// Start per-battle ability regeneration loop
function startAbilityRegen() {
  if (abilityRegenIntervalId) clearInterval(abilityRegenIntervalId);
  // tick every 200ms for smoother overlay updates
  abilityRegenIntervalId = setInterval(() => {
    let changed = false;
    ['block','counter','cleanse'].forEach(name => {
      if (abilityCooldowns[name] > 0) {
        abilityCooldowns[name] = Math.max(0, abilityCooldowns[name] - 200);
        changed = true;
      } else {
        // ensure it's clamped to zero
        abilityCooldowns[name] = 0;
      }
    });
    if (changed) updateAbilityButtonsUI();
  }, 200);
}

// Stop regen when battle ends
function stopAbilityRegen() {
  if (abilityRegenIntervalId) {
    clearInterval(abilityRegenIntervalId);
    abilityRegenIntervalId = null;
  }
}

  function resetAbilitiesForBattle() {
  abilityCooldowns.block = 0;
  abilityCooldowns.counter = 0;
  abilityCooldowns.cleanse = 0;
  blockActive = false;
  counterWindowActive = false;
  updateAbilityButtonsUI();
  startAbilityRegen();
}
  function pauseBattleTimersForDialog() {
  _battleDialogPausedState = {
    enemyAttackIntervalId,
    staminaRegenIntervalId,
    abilityRegenIntervalId,
    allyAttackTimerId: activeAlly && activeAlly.attackTimerId ? activeAlly.attackTimerId : null
  };

  if (enemyAttackIntervalId) { clearInterval(enemyAttackIntervalId); enemyAttackIntervalId = null; }
  if (staminaRegenIntervalId) { clearInterval(staminaRegenIntervalId); staminaRegenIntervalId = null; }
  if (abilityRegenIntervalId) { clearInterval(abilityRegenIntervalId); abilityRegenIntervalId = null; }
  if (activeAlly && activeAlly.attackTimerId) { clearInterval(activeAlly.attackTimerId); activeAlly.attackTimerId = null; }



  const attackBtn = document.getElementById('attack-button');
  const sp1 = document.getElementById('special-attack-button-1');
  const sp2 = document.getElementById('special-attack-button-2');
  const invBtn = document.getElementById('inventory-battle-button');
  if (attackBtn) attackBtn.disabled = true;
  if (sp1) sp1.disabled = true;
  if (sp2) sp2.disabled = true;
  if (invBtn) invBtn.disabled = true;
}

function resumeBattleTimersAfterDialog() {
  if (!inBattle) return;
  if (!_battleDialogPausedState) return;

  if (!enemyAttackIntervalId) enemyAttackIntervalId = setInterval(takeTurn, ENEMY_ATTACK_DELAY);
  if (!staminaRegenIntervalId) {
    staminaRegenIntervalId = setInterval(() => { updateStamina(playerStats.currentStamina + 1); drawPlayerBattleStatus(); }, 100);
  }
  if (!abilityRegenIntervalId) startAbilityRegen();
  if (_battleDialogPausedState.allyAttackTimerId && activeAlly && !activeAlly.attackTimerId) startAllyAttacking();
 

  const attackBtn = document.getElementById('attack-button');
  const sp1 = document.getElementById('special-attack-button-1');
  const sp2 = document.getElementById('special-attack-button-2');
  const invBtn = document.getElementById('inventory-battle-button');
  if (attackBtn) attackBtn.disabled = false;
  if (sp1) sp1.disabled = false;
  if (sp2) sp2.disabled = false;
  if (invBtn) invBtn.disabled = false;

  _battleDialogPausedState = null;
}

  
function enemyAttack(enemy, target) {
  const damage = enemy.damage || 0;
  if (target === playerStats) {
    playerTakeDamage(damage);
    showTemporaryText(`${enemy.name} attacks you for ${damage} damage!`);
  } else if (target === activeAlly) {
    activeAlly.currentHp -= damage;
    if (activeAlly.currentHp < 0) activeAlly.currentHp = 0;
    showTemporaryText(`${enemy.name} attacks ${activeAlly.name} for ${damage} damage!`);
    if (activeAlly.currentHp === 0) {
      showTemporaryText(`${activeAlly.name} has been defeated!`);
      clearInterval(activeAlly.attackTimerId);
      activeAlly.attackTimerId = null;
    }
  }
}
  function passiveArmorHeal() {
  if (equippedArmor && armorTypes[equippedArmor] && armorTypes[equippedArmor].passiveHealPercent) {
    const healAmount = Math.ceil(playerStats.maxHp * armorTypes[equippedArmor].passiveHealPercent);
    playerStats.currentHp = Math.min(playerStats.currentHp + healAmount, playerStats.maxHp);
    updateHp(playerStats.currentHp);
    showTemporaryText(`Passive heal: +${healAmount} HP`);
  }
}
  function playerTakeDamage(amount) {
  if (equippedArmor === "haunted") {
    const blockChance = armorTypes["haunted"].blockChance || 0;
    if (Math.random() < blockChance) {
      showTemporaryText("Haunted Armor blocked the attack!");
      return; // no damage taken
    }
  }

    if (typeof playerTakeDamage === 'function') {
  const _orig_playerTakeDamage = playerTakeDamage;
  playerTakeDamage = function(amount, attacker) {
    // If block active -> ignore damage
    if (blockActive) {
      showTemporaryText('Blocked incoming damage!');
      return;
    }

    // If counter window active -> reflect and stun attacker
    if (counterWindowActive) {
      showTemporaryText('Counter! Damage reflected!');
      // reflect to attacker if valid object reference with hp
      if (attacker && typeof attacker.currentHp === 'number') {
        attacker.currentHp = Math.max(0, attacker.currentHp - amount);
        // stun attacker if possible
        attacker.stunned = true;
        // schedule unstun
        setTimeout(() => { if (attacker) attacker.stunned = false; drawBattleUI(); }, ABILITIES.counter.stunMs);
        if (attacker.currentHp === 0) {
          handleEnemyDeath(attacker);
        }
        drawBattleUI();
      } else {
        const targetAtt = activeEnemies[selectedEnemyIndex];
        if (targetAtt) {
          targetAtt.currentHp = Math.max(0, targetAtt.currentHp - amount);
          targetAtt.stunned = true;
          setTimeout(() => { if (targetAtt) targetAtt.stunned = false; drawBattleUI(); }, ABILITIES.counter.stunMs);
          if (targetAtt.currentHp === 0) handleEnemyDeath(targetAtt);
          drawBattleUI();
        }
      }
      
      return;
    }

    // Else normal behavior
    return _orig_playerTakeDamage(amount);
  };
}
    
  playerStats.currentHp -= amount;

  // If Extra Life active, prevent death and clamp HP at 1
  if (!canGoBelow1Hp() && playerStats.currentHp <= 0) {
    playerStats.currentHp = 1;
  }

  if (playerStats.currentHp < 0) {
    playerStats.currentHp = 0;
  }

  updateHp(playerStats.currentHp);

  if (playerStats.currentHp <= 0) {
    endBattle('lose');
  }
}
  function handleEnemyDeath(enemy) {
  // Stage1 -> Stage2 special handling
  if (!enemy) return;



(function installFinalBossDeathWrapper() {
  if (typeof handleEnemyDeath !== 'function') {
    console.warn('FinalBoss module: handleEnemyDeath not found to wrap.');
    return;
  }
  if (handleEnemyDeath._isWrapped) return;

  const __orig_handleEnemyDeath = handleEnemyDeath;

  handleEnemyDeath = function(arg0, arg1) {
    try {
      // Resolve arguments: allow (enemy), (enemy, idx) or (idx)
      let enemy = arg0;
      let idx = (typeof arg1 === 'number') ? arg1 : undefined;
      if (typeof arg0 === 'number') { idx = arg0; enemy = Array.isArray(activeEnemies) ? activeEnemies[idx] : null; }

      console.log('[FinalBossHook] wrapper enter. enemyExists=', !!enemy, 'enemyType=', enemy ? enemy.type : '<<none>>', 'resolvedIdx=', typeof idx === 'number' ? idx : '<<none>>');

      // If no usable enemy and no valid index, delegate
      if (!enemy && (typeof idx !== 'number' || idx < 0 || idx >= (activeEnemies && activeEnemies.length || 0))) {
        return __orig_handleEnemyDeath(arg0, arg1);
      }
      if (!enemy && typeof idx === 'number') enemy = activeEnemies[idx];
      if (!enemy) return __orig_handleEnemyDeath(arg0, arg1);

      // Prevent duplicate processing
      if (!enemy._deathHandled) enemy._deathHandled = true;

      // Compute a safe insert index (use provided idx if valid, else find enemy index)
      let insertIndex = (typeof idx === 'number' && idx >= 0 && idx <= activeEnemies.length) ? idx : activeEnemies.indexOf(enemy);
      if (insertIndex === -1) insertIndex = activeEnemies.length;

      function placeSpawnAt(index, obj) {
        if (typeof index === 'number' && index >= 0 && index < activeEnemies.length) {
          activeEnemies.splice(index, 1, obj);
        } else {
          activeEnemies.push(obj);
        }
      }

      // -- simple dialog example (keeps behavior) --
      if (enemy.type === 'MountainBoss') {
        console.log('[FinalBossHook] MountainBoss dialog for', enemy.name);
        if (typeof showBattleDialog === 'function') {
          try {
            showBattleDialog(
              [
                { speaker: enemy.name, text: "Nooo..." },
                { speaker: '8-Bit', text: "More test code?" }
              ],
              null,
              { style: 'boss' }
            );
          } catch (e) {
            console.warn('[FinalBossHook] showBattleDialog threw for MountainBoss', e);
          }
        }
        // allow original to continue after
      }

      // -- FinalBossStage1 -> FinalBossStage2: sentinel technique to keep battle open synchronously --
      if (enemy.type === 'FinalBossStage1' && !enemy._stageProgressed) {
        enemy._stageProgressed = true;

        const dialogArr = [
          { speaker: enemy.name, text: "Insolent robot. Do you see what happens when you mess with true power?" },
          { speaker: '8-Bit', text: "What? What the hell did you do to my friends? Come on!" },
          { speaker: '8-Bit', text: "Wake up! We gotta kill him! Please!" },
          { speaker: enemy.name, text: "They couldn't handle the dark power. Do not worry, dear 8-Bit. They are alive, barely. You will soon join them." },
          { speaker: '8-Bit', text: "I'll never surrender to you! You know that! Bring it on! Let's fight!" }
        ];

        // Build Stage2 synchronously
        const base = (enemyTypes && enemyTypes.FinalBossStage2) || { name: 'FinalBossStage2', maxHp:1, damage:0 };
        const mult = (typeof getDifficultyMultipliers === 'function') ? getDifficultyMultipliers() : { enemyHp:1, enemyDmg:1 };
        const realStage2 = {
          type: 'FinalBossStage2',
          name: base.name || 'FinalBossStage2',
          maxHp: Math.max(1, Math.floor((base.maxHp||1) * mult.enemyHp)),
          currentHp: Math.max(1, Math.floor((base.maxHp||1) * mult.enemyHp)),
          damage: Math.max(0, Math.floor((base.damage||0) * mult.enemyDmg)),
          xpReward: base.xpReward || 0,
          shieldActive: false, stunned: false, poisoned: false,
          resistances: base.defaultResistances || {}
        };
        realStage2._finalBossSpawn = true;
        realStage2._canSpawnOrbs = true;

        // Capture and temporarily override endBattle so original cleanup can't call victory
        const origEndBattle = (typeof endBattle === 'function') ? endBattle : null;
        let endBattleWasCalled = false;
        let endBattleArgs = null;

        const suppressEndBattle = function(...args) {
          endBattleWasCalled = true;
          endBattleArgs = args;
          console.log('[FinalBossHook] suppressed endBattle call', args);
          // do nothing else so battle won't close
        };

        try {
          if (origEndBattle) window.endBattle = suppressEndBattle;

          // Call original handler synchronously to perform the usual removal/XPs
          try { __orig_handleEnemyDeath(enemy, idx); } catch (e) { console.error('[FinalBossHook] original handleEnemyDeath threw', e); }

          // Determine safe insert index (use idx if valid else append)
          let safeIndex = (typeof idx === 'number' && idx >= 0 && idx <= activeEnemies.length) ? idx : activeEnemies.indexOf(enemy);
          if (safeIndex === -1) safeIndex = activeEnemies.length;

          // Insert Stage2 synchronously so the battle never sees zero enemies
          if (safeIndex >= 0 && safeIndex < activeEnemies.length) {
            activeEnemies.splice(safeIndex, 0, realStage2);
          } else {
            activeEnemies.push(realStage2);
          }

          // Post-insert effects (knock out ally, timers, UI)
          showTemporaryText(`${realStage2.name} descends from the dark sigil!`);
          if (activeAlly) {
            activeAlly.currentHp = 0;
            if (activeAlly.attackTimerId) { clearInterval(activeAlly.attackTimerId); activeAlly.attackTimerId = null; }
            showTemporaryText(`${activeAlly.name} is struck down by the dark power!`);
            activeAlly = null;
            if (typeof drawPartyStatus === 'function') drawPartyStatus();
          }
          if (typeof startDarkTimer === 'function') startDarkTimer();

          inBattle = true;
          if (enemyAttackIntervalId) clearInterval(enemyAttackIntervalId);
          enemyAttackIntervalId = setInterval(takeTurn, ENEMY_ATTACK_DELAY);

          drawBattleUI();
          drawPlayerBattleStatus();
          drawPartyStatus();

          // Show dialog now (Stage2 is already present)
          if (typeof showBattleDialog === 'function') {
            try {
              showBattleDialog(dialogArr, function(){ /* no-op */ }, { style: 'dialog' });
            } catch (e) {
              console.warn('[FinalBossHook] showBattleDialog threw', e);
            }
          }

          // If endBattle was called by original handler, ignore it (we want to keep battle open).
          if (endBattleWasCalled) {
            console.log('[FinalBossHook] original handler attempted to end battle; suppressed to allow Stage2 spawn.');
          }

        } finally {
          // Restore original endBattle
          if (origEndBattle) window.endBattle = origEndBattle;
        }

        return; // avoid calling original handler again
      }

      // ShadowOrb -> LightOrb conversion (keep conversion but DO NOT reduce dark timer here)
      if (enemy && enemy.type === 'ShadowOrb' && !enemy._lightSpawned) {
        enemy._lightSpawned = true;
        console.log('[FinalBossHook] converting ShadowOrb -> LightOrb for', enemy.name);

        // clear any running timers from the ShadowOrb
        if (enemy._poisonIntervalId) { clearInterval(enemy._poisonIntervalId); enemy._poisonIntervalId = null; }
        if (enemy._spectralIntervalId) { clearInterval(enemy._spectralIntervalId); enemy._spectralIntervalId = null; }
        if (enemy._shardIntervalId) { clearInterval(enemy._shardIntervalId); enemy._shardIntervalId = null; }

        const lightBase = (enemyTypes && enemyTypes.LightOrb) || { name: 'Light Orb', maxHp: 40, damage: 0, xpReward: 0, defaultResistances: {} };
        const mult = (typeof getDifficultyMultipliers === 'function') ? getDifficultyMultipliers() : { enemyHp: 1 };
        const light = {
          type: 'LightOrb',
          name: lightBase.name || 'Light Orb',
          maxHp: Math.max(1, Math.floor((lightBase.maxHp || 40) * mult.enemyHp)),
          currentHp: Math.max(1, Math.floor((lightBase.maxHp || 40) * mult.enemyHp)),
          damage: lightBase.damage || 0,
          xpReward: lightBase.xpReward || 0,
          shieldActive: false, stunned: false, poisoned: false,
          resistances: lightBase.defaultResistances || {}
        };

        // Determine index of the corpse (prefer provided insertIndex)
        let corpseIdx = (typeof insertIndex === 'number' && insertIndex >= 0 && insertIndex < activeEnemies.length)
          ? insertIndex
          : activeEnemies.indexOf(enemy);
        if (corpseIdx === -1) corpseIdx = activeEnemies.length;

        // Remove corpse slot first to avoid later cleanup removing the wrong object
        if (corpseIdx >= 0 && corpseIdx < activeEnemies.length && activeEnemies[corpseIdx] === enemy) {
          activeEnemies.splice(corpseIdx, 1);
        }

        // Insert the LightOrb at the former corpse position
        if (corpseIdx >= activeEnemies.length) {
          activeEnemies.push(light);
        } else {
          activeEnemies.splice(corpseIdx, 0, light);
        }

        // Important: DO NOT reduce the dark timer here. LightOrb reduction happens when a LightOrb dies (see below).

        showTemporaryText('A Shadow Orb collapses into a Light Orb!');
        drawBattleUI();
        console.log('[FinalBossHook] ShadowOrb converted. activeEnemies:', activeEnemies.map(e => e && e.type).join(','));
      }

      // LightOrb death -> reduce dark timer (ONLY LightOrb should reduce)
      if (enemy && enemy.type === 'LightOrb') {
        // guard to only reduce once per LightOrb instance
        if (!enemy._darkReduced) {
          enemy._darkReduced = true;

          // Reduce the dark timer by 5 seconds if helper exists, else attempt other fallbacks
          try {
            if (typeof reduceDarkTimer === 'function') {
              reduceDarkTimer(5000);
              console.log('[FinalBossHook] reduced dark timer by 5000ms via reduceDarkTimer() (LightOrb)');
            } else if (typeof darkTimerMs === 'number' && typeof darkTimerLimitMs === 'number') {
              // your code uses darkTimerMs / darkTimerLimitMs elsewhere; attempt to reduce darkTimerMs directly
              darkTimerMs = Math.max(0, (typeof darkTimerMs === 'number' ? darkTimerMs : 0) - 5000);
              updateProgressiveDarknessUI && updateProgressiveDarknessUI();
              console.log('[FinalBossHook] reduced darkTimerMs by 5000ms directly (LightOrb)');
            } else if (typeof darkTimerRemaining === 'number') {
              darkTimerRemaining = Math.max(0, darkTimerRemaining - 5000);
              console.log('[FinalBossHook] reduced darkTimerRemaining by 5000ms (LightOrb)');
            } else if (typeof darkTimer === 'number') {
              darkTimer = Math.max(0, darkTimer - 5000);
              console.log('[FinalBossHook] reduced darkTimer by 5000ms (LightOrb)');
            } else {
              console.log('[FinalBossHook] no dark timer API found to reduce for LightOrb');
            }
          } catch (e) {
            console.error('[FinalBossHook] error reducing dark timer on LightOrb death', e);
          }

          showTemporaryText('A Light Orb pulses and the darkness recedes!');
        } // end _darkReduced guard
      }

      // -- FinalBossStage2 -> Stage3 or other special conversions can use earlier patterns --
      if (enemy.type === 'FinalBossStage2' && !enemy._stageProgressed) {
        enemy._stageProgressed = true;

        showBattleDialog(
              [
                { speaker: enemy.name, text: "Did you think that was the end of me?" },
                { speaker: '8-Bit', text: "You're... still alive." },
                { speaker: enemy.name, text: "Darn right! You have helped me reach my most powerful form!" },
                { speaker: enemy.name, text: "Meet:" },
                { speaker: 'Corruptus Calinigis Aeternae', text: "The corrupted one!" }
              ],
              null,
              { style: 'dialog' }
            );

        // Clear intervals on old object
        if (enemy._shardIntervalId) { clearInterval(enemy._shardIntervalId); enemy._shardIntervalId = null; }
        if (enemy._blackoutIntervalId) { clearInterval(enemy._blackoutIntervalId); enemy._blackoutIntervalId = null; }

        // Build stage3 then insert synchronously (similar to earlier)
        const base3 = (enemyTypes && enemyTypes.FinalBossStage3) || { name: 'FinalBossStage3', maxHp:1, damage:0 };
        const mult3 = (typeof getDifficultyMultipliers === 'function') ? getDifficultyMultipliers() : { enemyHp:1, enemyDmg:1 };
        const stage3 = {
          type: 'FinalBossStage3',
          name: base3.name || 'FinalBossStage3',
          maxHp: Math.max(1, Math.floor((base3.maxHp||1) * mult3.enemyHp)),
          currentHp: Math.max(1, Math.floor((base3.maxHp||1) * mult3.enemyHp)),
          damage: Math.max(0, Math.floor((base3.damage||0) * mult3.enemyDmg)),
          xpReward: base3.xpReward || 0,
          shieldActive: false, stunned: false, poisoned: false,
          resistances: base3.defaultResistances || {}
        };

        // pause timers before popup
        if (typeof pauseBattleTimersForDialog === 'function') pauseBattleTimersForDialog();

        placeSpawnAt(insertIndex, stage3);
        showTemporaryText(`${stage3.name} rises from the shadows!`);
        drawBattleUI();

        stopDarkTimer();

        // find spawned battle enemy reference
        let spawned = (typeof insertIndex === 'number' && insertIndex >= 0 && insertIndex < activeEnemies.length)
          ? activeEnemies[insertIndex]
          : activeEnemies.find(e => e && e.type === 'FinalBossStage3');

        if (spawned && typeof startFinalBossBulletHell === 'function') {
          // delay the popup by 1 second without blocking the game loop
          setTimeout(() => {
            startFinalBossBulletHell({
              bossEnemy: spawned,
              onEnd: (mode) => {
                if (typeof resumeBattleTimersAfterDialog === 'function') resumeBattleTimersAfterDialog();

                if (mode === 'victory') {
                  // keep the battle enemy present but mark defeated and set visible HP to 1
                  try {
                    if (typeof spawned.currentHp === 'number') spawned.currentHp = 1;
                    if (typeof spawned.maxHp === 'number' && spawned.maxHp < 1) spawned.maxHp = 1;
                    spawned._defeated = true;
                    // sync any global enemy object if present
                    if (typeof enemyObj === 'object' && enemyObj) {
                      if (typeof enemyObj.currentHp === 'number') enemyObj.currentHp = 1;
                      enemyObj._defeated = true;
                    }
                    // grant XP safely if you want the player rewarded now
                    if (typeof grantXpToPlayer === 'function') {
                      try { grantXpToPlayer(spawned.xpReward || 0); } catch (e) {}
                    }
                  } catch (e) {
                    console.error('[FinalBossHook] onEnd victory handler error', e);
                  }
                }

                // UI refresh
                try { drawBattleUI(); drawPlayerBattleStatus(); } catch (e) {}
              }
            });
          }, 5000);
        } else {
          if (typeof resumeBattleTimersAfterDialog === 'function') resumeBattleTimersAfterDialog();
        }

        // do not call original handler here because original should have been applied when enemy died
        return;
      }

    } catch (e) {
      console.error('[FinalBossHook] wrapper error', e);
    }

    // Default: delegate to original handler for normal cleanup
    return __orig_handleEnemyDeath(arg0, arg1);
  };

  handleEnemyDeath._isWrapped = true;
})();


  if (enemy.type === 'MountainBoss') {
  showBattleDialog(
    [
      { speaker: enemy.name, text: "Nooo..." },
      { speaker: '8-Bit', text: "More test code?" }
    ],
    null,
    { style: 'boss' }
  );
  }
  // Stage1 special: explode and spawn Stage2 (explosion happens when Stage1 dies)
  if (enemy.type === "SecondStageBossStage1") {
    // Explosion damage: 5% of player's max HP (rounded up)
    const explosionDamage = Math.max(1, Math.ceil(playerStats.maxHp * 0.05));

    // Apply damage to player (respect extra-life/invincibility flags)
    if (inBattle) {
      // Player
      if (playerStats && typeof playerStats.currentHp === 'number') {
        playerStats.currentHp -= explosionDamage;
        // If Extra Life active, ensure we don't kill below 1 (existing helper)
        if (!canGoBelow1Hp() && playerStats.currentHp <= 0) {
          playerStats.currentHp = 1;
        }
        if (playerStats.currentHp < 0) playerStats.currentHp = 0;
        updateHp(playerStats.currentHp);
      }
      showTemporaryText(`${enemy.name} explodes on defeat for ${explosionDamage} damage!`);

      // Active ally also takes explosion damage (if present)
      if (activeAlly && typeof activeAlly.currentHp === 'number') {
        activeAlly.currentHp = Math.max(0, activeAlly.currentHp - explosionDamage);
        showTemporaryText(`${activeAlly.name} takes ${explosionDamage} explosion damage!`);
        // Ally death handling
        if (activeAlly.currentHp === 0 && activeAlly.attackTimerId) {
          clearInterval(activeAlly.attackTimerId);
          activeAlly.attackTimerId = null;
        }
      }
    }

    // Now spawn Stage2
    const stage2Base = enemyTypes[enemyTypes.SecondStageBossStage1.secondStageType];
    const stage2Stats = scaleEnemyStats(stage2Base);
    const stage2Enemy = {
      type: "SecondStageBossStage2",
      name: stage2Stats.name,
      maxHp: stage2Stats.maxHp,
      currentHp: stage2Stats.maxHp,
      damage: stage2Stats.damage,
      xpReward: stage2Stats.xpReward,
      shieldActive: false,
      shieldCooldownEnd: 0,
      rocketActive: false,
      rocketTicksLeft: 0,
      stunned: false,
      poisoned: false,
      resistances: stage2Base.defaultResistances || {}
    };

    // Remove the dead stage1 and insert stage2
    activeEnemies = activeEnemies.filter(e => e !== enemy);
    activeEnemies.push(stage2Enemy);

    // Re-init enemy attack loop if needed
    showTemporaryText(`${stage2Enemy.name} emerges from the core!`);
    drawBattleUI();
    drawPlayerBattleStatus();
    drawPartyStatus();

    // Ensure battle continues
    inBattle = true;
    if (enemyAttackIntervalId) clearInterval(enemyAttackIntervalId);
    enemyAttackIntervalId = setInterval(takeTurn, ENEMY_ATTACK_DELAY);

    return;
  }

if (enemy._shardIntervalId) { clearInterval(enemy._shardIntervalId); enemy._shardIntervalId = null; }
if (enemy._blackoutIntervalId) { clearInterval(enemy._blackoutIntervalId); enemy._blackoutIntervalId = null; }
enemy._blackoutRunning = false;
enemy._isBlackout = false;


const willHideBattleBlackout = (() => {
  
  const others = activeEnemies.filter(e => e && e !== enemy);
  // if any other enemy has _blackoutIntervalId or _blackoutRunning truthy, keep overlay
  return !others.some(e => e && (e._blackoutIntervalId || e._blackoutRunning || e._isBlackout));
})();
if (willHideBattleBlackout) {
  hideBattleBlackout();
}
  // award XP immediately
  if (enemy && enemy.xpReward) gainXP(enemy.xpReward);

  // cleanup behavior timers if any
  if (enemy.behaviorTimers && enemy.behaviorTimers.length) {
    enemy.behaviorTimers.forEach(id => clearInterval(id));
    enemy.behaviorTimers = [];
  }

  // remove the enemy from activeEnemies
  const idx = activeEnemies.indexOf(enemy);
  if (idx > -1) activeEnemies.splice(idx, 1);

  try {
  const DROP_CHANCE = 0.10;
  if (enemy.type === 'Sniperbot' && Math.random() < DROP_CHANCE) {
    const currentBolts = inventory.get('bolts') || 0;
    inventory.set('bolts', currentBolts + 1);
  }
    if (enemy.type === 'Puncherbot' && Math.random() < DROP_CHANCE) {
    const currentBolts = inventory.get('bolts') || 0;
    inventory.set('bolts', currentBolts + 1);
  }
} catch (e) {
  console.warn('Bolt drop failed:', e);
}
  achievementsMap['kill_enemies'].progress++;
  achievementsMap['kill_enemies2'].progress++;
  achievementsMap['kill_enemies3'].progress++;
  if (enemy.type === 'BossBot' && gameSettings.difficulty === 'ultimate') achievementsMap['kill_bossbot'].progress = 1;
  if (enemy.type === 'IceBoss' && gameSettings.difficulty === 'ultimate') achievementsMap['kill_icebot'].progress = 1;
  if (enemy.type === 'LifeStealBoss' && gameSettings.difficulty === 'ultimate') achievementsMap['kill_lifestealboss'].progress = 1;
  if (enemy.type === 'CritBoss' && gameSettings.difficulty === 'ultimate') achievementsMap['kill_critboss'].progress = 1;
  if (enemy.type === 'CaveBoss' && gameSettings.difficulty === 'ultimate') achievementsMap['kill_caveboss'].progress = 1;
  if (enemy.type === 'MountainBoss' && gameSettings.difficulty === 'ultimate') achievementsMap['kill_mountainboss'].progress = 1;
  if (enemy.type === 'GhostBoss' && gameSettings.difficulty === 'ultimate') achievementsMap['kill_ghostboss'].progress = 1;
  if (enemy.type === 'SecondStageBossStage2' && gameSettings.difficulty === 'ultimate') achievementsMap['kill_factoryboss'].progress = 1;
  if (enemy.type === 'IslandBoss' && gameSettings.difficulty === 'ultimate') achievementsMap['kill_islandboss'].progress = 1;
  if (enemy.type === 'FinalBossStage3' && gameSettings.difficulty === 'ultimate') achievementsMap['kill_finaleboss'].progress = 1;
  if (enemy.type === 'Dummy') achievementsMap['kill_tutorial_dummy'].progress = 1;
  checkAchievements();

  if (enemy._stunTimeout) {
    clearTimeout(enemy._stunTimeout);
    enemy._stunTimeout = null;
  }
  if (enemy._poisonIntervalId) {
    clearInterval(enemy._poisonIntervalId);
    enemy._poisonIntervalId = null;
  }
  enemy.stunned = false;
  enemy.poisoned = false;

  // if no enemies remain, either end the battle round (endBattle('win') will check rounds) or spawn next round is handled in endBattle
  if (activeEnemies.length === 0) {
    endBattle('win');
  } else {
    drawBattleUI();
    drawPlayerBattleStatus();
    drawPartyStatus();
  }
}
    
function healAllyAfterBattle() {
  if (activeAlly && activeAlly.currentHp > 0) {
    const healAmount = Math.ceil(activeAlly.maxHp * 0.33);
    activeAlly.currentHp = Math.min(activeAlly.currentHp + healAmount, activeAlly.maxHp);
    showTemporaryText(`${activeAlly.name} healed for ${healAmount} HP after battle.`);
  }
}
// End battle and clean up
function endBattle(outcome) {

  try { stopDarkTimer(); } catch (e) {}

  // If win and there are rounds remaining, move to next round instead of ending.
  if (outcome === 'win') {
    
    battleRounds--;
    if (battleRounds > 0) {
      currentRoundIndex++;
      // small pause/message then spawn next round
      showTemporaryText(`Round ${currentRoundIndex + 1} begins!`);
      spawnRound(currentRoundIndex);
      draw();
      return; // continue battle
    }
  }
  if (activeEnemies.length === 0) {
  // If a hidden ghost was prepared (from spawnRound) and still hidden, reveal it instead of ending battle.
  const ghost = window._lastGhostRef;
  if (ghost && ghost._isHidden) {
    // Reveal ghost now (don't end battle). Ensure ghost stats were scaled earlier (see spawnRound fix below).
    if (!activeEnemies.includes(ghost)) activeEnemies.push(ghost);
    ghost._isHidden = false;
    ghost._hostTrainSpawned = false;

    // Start ghost's spectral minion spawner if not running
    if (ghost._spectralIntervalId) clearInterval(ghost._spectralIntervalId);
    ghost._spectralIntervalId = setInterval(() => {
      if (!inBattle || !activeEnemies.includes(ghost) || ghost.currentHp <= 0) {
        if (ghost._spectralIntervalId) { clearInterval(ghost._spectralIntervalId); ghost._spectralIntervalId = null; }
        return;
      }
      const base = enemyTypes.SpectralMinion;
      const m = {
        type: 'SpectralMinion',
        name: base.name,
        maxHp: Math.max(1, Math.floor(base.maxHp * getDifficultyMultipliers().enemyHp)),
        currentHp: Math.max(1, Math.floor(base.maxHp * getDifficultyMultipliers().enemyHp)),
        damage: Math.max(0, Math.floor(base.damage * getDifficultyMultipliers().enemyDmg)),
        xpReward: base.xpReward || 0,
        shieldActive: false, stunned: false, poisoned: false
      };
      activeEnemies.push(m);
      showTemporaryText('A spectral minion emerges!');
      drawBattleUI();
    }, 3000);

    // ensure selection index safe and continue battle
    selectedEnemyIndex = Math.max(0, Math.min(selectedEnemyIndex, activeEnemies.length - 1));
    inBattle = true;
    if (enemyAttackIntervalId) clearInterval(enemyAttackIntervalId);
    enemyAttackIntervalId = setInterval(takeTurn, ENEMY_ATTACK_DELAY);
    drawBattleUI();
    drawPlayerBattleStatus();
    return; // bail out of normal end flow
  }
  }
  // --- Normal battle end cleanup (no rounds left or lost) ---
  inBattle = false;
  document.getElementById('battle-overlay').style.display = 'none';
  if (window._raft) {
  window._raft = null;
}
  if (typeof endBattle === 'function') {
  const _orig_endBattle = endBattle;
  endBattle = function(outcome) {
    // cleanup active ability windows
    blockActive = false;
    counterWindowActive = false;
    stopAbilityRegen();
    updateAbilityButtonsUI();
    return _orig_endBattle(outcome);
  };
}

  if (staminaRegenIntervalId) { clearInterval(staminaRegenIntervalId); staminaRegenIntervalId = null; }
  if (enemyAttackIntervalId) { clearInterval(enemyAttackIntervalId); enemyAttackIntervalId = null; }
  if (activeAlly && activeAlly.attackTimerId) {
    clearInterval(activeAlly.attackTimerId);
    activeAlly.attackTimerId = null;
  }

  if (outcome === 'win') {
    // XP from any remaining enemies (defensive)
    let totalXp = activeEnemies.reduce((sum, enemy) => sum + (enemy.xpReward || 0), 0);
    gainXP(totalXp);
    playerStats.currentHp = playerStats.maxHp;
    updateHp(playerStats.currentHp);
    if (defeatedZone) removeZone(defeatedZone);
    healAllyAfterBattle();
  } else if (outcome === 'lose') {
    showGameOver();
  }

  activeEnemies = [];
  defeatedZone = null;
  activeAlly = null;
  draw();
  drawPartyStatus();
  const pbs = document.getElementById('player-battle-status');
  if (pbs) pbs.innerHTML = "";
}

function initiateBattle(zoneType, zoneObject) {
  inBattle = true;
  defeatedZone = { type: zoneType, object: zoneObject };
  resetAbilitiesForBattle();

  // stamina regen
  staminaRegenIntervalId = setInterval(() => {
    updateStamina(playerStats.currentStamina + 1);
    drawPlayerBattleStatus();
  }, 100);
  
setInterval(() => {
  if (inBattle) updateAbilityButtonsUI();
}, 250);

  if (zoneObject && Array.isArray(zoneObject.encounter) && Array.isArray(zoneObject.encounter[0])) {
    currentRoundEncounters = zoneObject.encounter.map(round => Array.isArray(round) ? round.slice() : []);
  } else {
    currentRoundEncounters = [(zoneObject && zoneObject.encounter) ? zoneObject.encounter.slice() : []];
  }
  battleRounds = currentRoundEncounters.length;
  currentRoundIndex = 0;

  // Spawn first round
  spawnRound(currentRoundIndex);

  const _orig_initiateBattle = typeof initiateBattle === 'function' ? initiateBattle : null;
initiateBattle = function(zoneType, zoneObject) {
  if (_orig_initiateBattle) _orig_initiateBattle(zoneType, zoneObject);
  // reset and start per-battle ability regen
  resetAbilitiesForBattle();
};
  
  // Setup activeAlly if equipped
  if (equippedAllyId && unlockedAllies.has(equippedAllyId)) {
    const allyBase = alliesData.find(a => a.id === equippedAllyId);
    activeAlly = {
      id: allyBase.id,
      name: allyBase.name,
      maxHp: allyBase.baseMaxHp,
      currentHp: allyBase.baseMaxHp,
      damage: allyBase.baseDamage,
      attackIntervalMs: allyBase.attackIntervalMs,
      level: allyBase.level,
      xp: allyBase.xp,
      xpToNextLevel: allyBase.xpToNextLevel,
      attackTimerId: null,
      stunned: false
    };
    startAllyAttacking();
    drawPartyStatus();
  } else {
    activeAlly = null;
  }

  selectedEnemyIndex = 0;
  drawBattleUI();
  drawPlayerBattleStatus();

  if (enemyAttackIntervalId) clearInterval(enemyAttackIntervalId);
  enemyAttackIntervalId = setInterval(takeTurn, ENEMY_ATTACK_DELAY);
}

function spawnRound(roundIdx) {
  const encounter = currentRoundEncounters[roundIdx] || [];
  const mult = getDifficultyMultipliers();

  
  const built = encounter.map(enemyData => {
    if (!enemyData) return null;

    // Special-case GhostBoss
   if (enemyData.type === 'GhostBoss') {
    const baseStats = enemyTypes['GhostBoss'] || {};
    const mult = getDifficultyMultipliers();
    const baseHp = (baseStats.maxHp != null) ? baseStats.maxHp : 450;
    const baseDmg = (baseStats.damage != null) ? baseStats.damage : 3;
      const ghost = {
        ...enemyData,
        type: 'GhostBoss',
        name: baseStats.name || 'The Maestro',
        maxHp: Math.max(1, Math.floor(baseHp * mult.enemyHp)),
        currentHp: Math.max(1, Math.floor(baseHp * mult.enemyHp)),
        damage: Math.max(0, Math.floor(baseDmg * mult.enemyDmg)),
        xpReward: baseStats.xpReward || enemyData.xpReward || 180,
        shieldActive: false,
        stunned: false,
        poisoned: false,
        _isHidden: true,
        _hiddenInIndex: Math.floor(Math.random() * 3),
        _hostTrainSpawned: false
      };

    
      window._lastGhostRef = ghost;

     
      return null;
    }

    
    const baseStats = enemyTypes[enemyData.type] || {};
    const baseHp = (baseStats.maxHp != null) ? baseStats.maxHp : (baseStats.maxHP != null ? baseStats.maxHP : (enemyData.maxHp || 1));
    const baseDmg = (baseStats.damage != null) ? baseStats.damage : (enemyData.damage || 1);

    const finalMaxHp = Math.max(1, Math.floor(baseHp * mult.enemyHp));
    const finalDamage = Math.max(0, Math.floor(baseDmg * mult.enemyDmg));

    return {
      ...enemyData,
      type: enemyData.type,
      name: baseStats.name || enemyData.type,
      maxHp: finalMaxHp,
      currentHp: finalMaxHp,
      damage: finalDamage,
      xpReward: baseStats.xpReward || enemyData.xpReward || 0,
      shieldActive: false,
      shieldCooldownEnd: 0,
      rocketActive: false,
      rocketTicksLeft: 0,
      stunned: false,
      poisoned: false,
      resistances: (enemyData.resistances || baseStats.defaultResistances) || { stun: false, poison: false },
      isBoss: !!baseStats.isBoss
    };
  });

  // Assign built enemies (filter out nulls)
  activeEnemies = built.filter(Boolean);

  // If a GhostBoss ref was prepared earlier, spawn its trains now (so they are not overwritten)
  if (window._lastGhostRef && window._lastGhostRef._isHidden && !window._lastGhostRef._hostTrainSpawned) {
    spawnGhostTrains(window._lastGhostRef);
    // mark spawned
    window._lastGhostRef._hostTrainSpawned = true;
    // ensure ghost object itself is preserved (it stays in window._lastGhostRef for later reveal)
  }
  
if (IslandBossPresent()) {
  // global per-battle raft state
  window._raft = { maxHp: 12, hp: 12 };
} else {
  // clear any leftover raft state
  window._raft = null;
}

  selectedEnemyIndex = 0;
  if (enemyAttackIntervalId) clearInterval(enemyAttackIntervalId);
  enemyAttackIntervalId = setInterval(takeTurn, ENEMY_ATTACK_DELAY);

  drawBattleUI();
  drawPlayerBattleStatus();
}
  // Unlock an ally and update UI/save state
function unlockAlly(allyId) {
  if (!allyId) return;
  if (unlockedAllies.has(allyId)) {
    showTemporaryText(`${alliesData.find(a => a.id === allyId)?.name || allyId} is already unlocked.`);
    return;
  }
  const ally = alliesData.find(a => a.id === allyId);
  if (!ally) {
    console.warn('unlockAlly: unknown allyId', allyId);
    showTemporaryText('Unknown ally.');
    return;
  }

  unlockedAllies.add(allyId);
  // Auto-equip if nothing equipped yet
  if (!equippedAllyId) {
    equippedAllyId = allyId;
    showTemporaryText(`${ally.name} has joined and was auto-equipped.`);
  } else {
    showTemporaryText(`${ally.name} has joined your party!`);
  }
const ach = achievementsMap[`ally_unlock_${allyId}`];
  if (ach && !ach.unlocked) {
    ach.progress = 1;
    checkAchievements();
  }
  
  drawPartyList();
  drawPartyStatus();
}

function checkAchievements() {
  achievements.forEach(ach => {
    if (!ach.unlocked && ach.checkCondition()) {
      ach.unlocked = true;
      showAchievementUnlocked(ach);
      drawAchievementsUI();
    }
  });
}
function triggerAbilityCooldown(name) {
  if (!ABILITIES[name]) return;
  abilityCooldowns[name] = ABILITIES[name].cooldownMs;
  updateAbilityButtonsUI();
}

// Implement ability effects
function doBlock() {
  if (abilityCooldowns.block > 0 || blockActive) {
    showTemporaryText('Block not ready.');
    return;
  }
  triggerAbilityCooldown('block');
  blockActive = true;
  showTemporaryText('Block active! No damage for 1s.');
  updateAbilityButtonsUI();
  setTimeout(() => {
    blockActive = false;
    showTemporaryText('Block ended.');
    updateAbilityButtonsUI();
  }, ABILITIES.block.effectMs);
}

// Counter: opens a small timing window where incoming damage is countered
function doCounter() {
  if (abilityCooldowns.counter > 0 || counterWindowActive) {
    showTemporaryText('Counter not ready.');
    return;
  }
  triggerAbilityCooldown('counter');
  counterWindowActive = true;
  showTemporaryText('Counter window open! Time it well (~0.7s).');
  updateAbilityButtonsUI();

  setTimeout(() => {
    counterWindowActive = false;
    showTemporaryText('Counter window closed.');
    updateAbilityButtonsUI();
  }, ABILITIES.counter.windowMs);
}

// Cleanse: remove fire/burn/poison status from player and ally
function doCleanse() {
  if (abilityCooldowns.cleanse > 0) {
    showTemporaryText('Cleanse not ready.');
    return;
  }
  triggerAbilityCooldown('cleanse');

  // remove player status flags (poisoned, burned, burning etc)
  const removed = [];
  if (playerStats && playerStats._burned) { playerStats._burned = false; removed.push('burn'); }
  if (playerStats && playerStats._poisoned) { playerStats._poisoned = false; removed.push('poison'); }
  // other code in your project may use flags like playerStats.burning; clear common names.
  ['burned','burning','poisoned'].forEach(k => {
    if (playerStats && playerStats[k]) { playerStats[k] = false; if (!removed.includes(k)) removed.push(k); }
  });

  if (activeAlly) {
    if (activeAlly._burned) { activeAlly._burned = false; removed.push(`${activeAlly.name}: burn`); }
    if (activeAlly._poisoned) { activeAlly._poisoned = false; removed.push(`${activeAlly.name}: poison`); }
    ['burned','burning','poisoned'].forEach(k => {
      if (activeAlly && activeAlly[k]) { activeAlly[k] = false; if (!removed.includes(k)) removed.push(k); }
    });
  }

  // Also remove DOT intervals attached to player if you used any (example: player._burnIntervalId)
  if (playerStats && playerStats._burnIntervalId) {
    clearInterval(playerStats._burnIntervalId);
    playerStats._burnIntervalId = null;
  }
  if (activeAlly && activeAlly._burnIntervalId) {
    clearInterval(activeAlly._burnIntervalId);
    activeAlly._burnIntervalId = null;
  }

  showTemporaryText(removed.length ? `Cleanse removed: ${removed.join(', ')}` : 'Nothing to cleanse.');
  updateAbilityButtonsUI();
  drawPlayerBattleStatus();
  drawPartyStatus();
}

  (function wireAbilityButtons() {
  const b = document.getElementById('ability-block');
  const c = document.getElementById('ability-counter');
  const cl = document.getElementById('ability-cleanse');
  if (b) b.addEventListener('click', doBlock);
  if (c) c.addEventListener('click', doCounter);
  if (cl) cl.addEventListener('click', doCleanse);
})();

  // FINAL BOSS BULLETHELL MODULE
(function() {
  // Config
  const POPUP_ID = 'final-boss-bullethell';
  const SHOOT_COOLDOWN = 200; // ms (0.2s)
  const PLAYER_RADIUS = 12;
  const PLAYER_SPEED = 220; // px/s
  const PROJECTILE_SPEED = 420; // px/s (player bullets go up)
  const PLAYER_BULLET_COLOR = '#3aa0ff';
  const BOSS_RADIUS = 48; // big hitbox radius
  const BOSS_SPEED = 280; // px/s while moving toward target
  const WORLD_PADDING = 20; // wall padding inside popup
  const SPIKE_SPEED = 200;
  const BALL_SPEED = 200;
  const HOMING_SPEED = 75;
  const TICK_MS = 16; // ~60fps

  // Internal state
  let popup, canvas, ctx, lastTs, rafId, tickInterval;
  let player = null;
  let keys = {};
  let canShoot = true;
  let playerBullets = [];
  let bossObj = null;
  let enemyObj = null;
  let bounds = null;
  let activeHazards = [];
  let running = false;
  let onEndCallback = null;
  let _lastPlayerHitAt = 0;

  // Utility
  function clamp(v,a,b){return Math.max(a,Math.min(b,v));}
  function now() { return performance.now(); }
  function randInt(a,b){return Math.floor(a + Math.random()*(b-a+1));}
  function distance(a,b){const dx=a.x-b.x, dy=a.y-b.y; return Math.hypot(dx,dy);}
  function normalize(vx,vy){const L=Math.hypot(vx,vy)||1; return {x:vx/L,y:vy/L};}

  // DOM create
  function createPopup() {
    // prevent creating twice
    if (document.getElementById(POPUP_ID)) return document.getElementById(POPUP_ID);

    popup = document.createElement('div');
    popup.id = POPUP_ID;
    Object.assign(popup.style, {
      position: 'fixed',
      left: 0, top: 0, right: 0, bottom: 0,
      zIndex: 999999,
      background: 'rgba(0,0,0,0.85)',
      display: 'flex',
      alignItems: 'center',
      justifyContent: 'center'
    });

    canvas = document.createElement('canvas');
    canvas.width = Math.min(window.innerWidth - 80, 1200);
    canvas.height = Math.min(window.innerHeight - 80, 800);
    Object.assign(canvas.style, {
      background: '#06060a',
      boxShadow: '0 0 30px rgba(0,0,0,0.8)',
      borderRadius: '6px'
    });

    popup.appendChild(canvas);
    document.body.appendChild(popup);
    ctx = canvas.getContext('2d');
    bounds = { x: WORLD_PADDING, y: WORLD_PADDING, w: canvas.width - WORLD_PADDING*2, h: canvas.height - WORLD_PADDING*2 };
    return popup;
  }

  // Input
  function onKeyDown(e){ if (e.code === 'Space') { keys.space = true; e.preventDefault(); } }
  function onKeyUp(e){ if (e.code === 'Space') { keys.space = false; e.preventDefault(); } }

  // Start function to call externally
  window.startFinalBossBulletHell = function({ bossEnemy, onEnd } = {}) {
    if (enemyAttackIntervalId) { clearInterval(enemyAttackIntervalId); enemyAttackIntervalId = null; }
    if (running) return;
    enemyObj = bossEnemy || null;
    onEndCallback = typeof onEnd === 'function' ? onEnd : null;

    createPopup();
    initEntities();
    attachListeners();
    running = true;
    lastTs = now();
    tickInterval = setInterval(tick, TICK_MS);
  };

  // Stop / cleanup
  function stopFinalBoss(mode) {
    running = false;
    if (tickInterval) { clearInterval(tickInterval); tickInterval = null; }
    if (document.getElementById(POPUP_ID)) {
      document.getElementById(POPUP_ID).remove();
    }
    detachListeners();
    playerBullets = [];
    activeHazards = [];
    bossObj = null;
    enemyObj = null;
    if (onEndCallback) onEndCallback(mode || 'ended');
  }

  // Initialize player and boss
  function initEntities() {
    const cx = canvas.width/2, cy = canvas.height - 120;
    player = {
      x: cx, y: cy, vx:0, vy:0,
      radius: PLAYER_RADIUS,
      hp: (playerStats && playerStats.currentHp) || 100,
      dmg: (playerStats && playerStats.damage) || 10
    };

    // Boss spawn center
    bossObj = {
      x: canvas.width/2,
      y: 120,
      vx: 0, vy: 0,
      radius: BOSS_RADIUS,
      hp: enemyObj && typeof enemyObj.currentHp === 'number' ? enemyObj.currentHp : 500,
      maxHp: enemyObj && enemyObj.maxHp ? enemyObj.maxHp : 500,
      dmg: enemyObj && typeof enemyObj.damage === 'number' ? enemyObj.damage : 10,
      state: 'idle',
      // movement target when bouncing to wall
      moveTarget: null,
      // attack timers
      lastBallOrSpillAt: 0,
      lastCircleOrHomingAt: 0
    };
  }

  // Listeners
  function attachListeners() {
    window.addEventListener('keydown', onKeyDown);
    window.addEventListener('keyup', onKeyUp);
    canvas.addEventListener('mousemove', onMouseMove);
    // WASD movement for player
    window.addEventListener('keydown', onMovementKey);
    window.addEventListener('keyup', onMovementKeyUp);

    // basic pause by pressing ESC to exit
    window.addEventListener('keydown', function escExit(e){ if (e.key === 'Escape') { stopFinalBoss('escape'); }});
  }

  function detachListeners() {
    window.removeEventListener('keydown', onKeyDown);
    window.removeEventListener('keyup', onKeyUp);
    canvas.removeEventListener('mousemove', onMouseMove);
    window.removeEventListener('keydown', onMovementKey);
    window.removeEventListener('keyup', onMovementKeyUp);
  }

  // Player keyboard movement (arrow keys or WASD)
  let moveState = { left:false, right:false, up:false, down:false };
  function onMovementKey(e){
    if (e.code === 'KeyA' || e.code === 'ArrowLeft') moveState.left = true;
    if (e.code === 'KeyD' || e.code === 'ArrowRight') moveState.right = true;
    if (e.code === 'KeyW' || e.code === 'ArrowUp') moveState.up = true;
    if (e.code === 'KeyS' || e.code === 'ArrowDown') moveState.down = true;
  }
  function onMovementKeyUp(e){
    if (e.code === 'KeyA' || e.code === 'ArrowLeft') moveState.left = false;
    if (e.code === 'KeyD' || e.code === 'ArrowRight') moveState.right = false;
    if (e.code === 'KeyW' || e.code === 'ArrowUp') moveState.up = false;
    if (e.code === 'KeyS' || e.code === 'ArrowDown') moveState.down = false;
  }

  function onMouseMove(e) {
    const rect = canvas.getBoundingClientRect();
    const mx = e.clientX - rect.left;
    const my = e.clientY - rect.top;
    // allow optional mouse aim later
  }

  // Main tick
  function tick() {
    const nowTs = now();
    const dt = Math.min(200, nowTs - lastTs) / 1000;
    lastTs = nowTs;

    updatePlayer(dt);
    handleShooting(nowTs);
    updateBullets(dt);
    updateBoss(dt, nowTs);
    cleanupOutOfBounds();
    resolveCollisions();
    render();
  }

  // Player movement update
  function updatePlayer(dt) {
    let ax = 0, ay = 0;
    if (moveState.left) ax -= 1;
    if (moveState.right) ax += 1;
    if (moveState.up) ay -= 1;
    if (moveState.down) ay += 1;
    if (ax !== 0 || ay !== 0) {
      const norm = normalize(ax, ay);
      player.vx = norm.x * PLAYER_SPEED;
      player.vy = norm.y * PLAYER_SPEED;
    } else {
      player.vx = 0; player.vy = 0;
    }
    player.x += player.vx * dt;
    player.y += player.vy * dt;

    // keep inside walls
    player.x = clamp(player.x, bounds.x + player.radius, bounds.x + bounds.w - player.radius);
    player.y = clamp(player.y, bounds.y + player.radius, bounds.y + bounds.h - player.radius);
  }

  // Shooting handling (space to shoot)
  let lastShotAt = 0;
  function handleShooting(nowMs) {
    if (keys.space) {
      if (nowMs - lastShotAt >= SHOOT_COOLDOWN) {
        lastShotAt = nowMs;
        spawnPlayerBullet();
      }
    }
  }

  function spawnPlayerBullet() {
    const b = {
      x: player.x,
      y: player.y - player.radius - 6,
      vx: 0,
      vy: -PROJECTILE_SPEED,
      radius: 6,
      color: PLAYER_BULLET_COLOR,
      owner: 'player',
      dmg: player.dmg || 1
    };
    playerBullets.push(b);
  }

  // Bullets update
  function updateBullets(dt) {
    // player bullets
    for (let i = playerBullets.length - 1; i >= 0; i--) {
      const p = playerBullets[i];
      p.x += p.vx * dt;
      p.y += p.vy * dt;
      // remove out of bounds
      if (p.x < bounds.x - 50 || p.x > bounds.x + bounds.w + 50 || p.y < bounds.y - 50 || p.y > bounds.y + bounds.h + 50) {
        playerBullets.splice(i,1);
      }
    }

    // hazards update
    for (let i = activeHazards.length - 1; i >= 0; i--) {
      const h = activeHazards[i];
      h.x += (h.vx||0) * dt;
      h.y += (h.vy||0) * dt;
      // lifetime expiration
      if (h.ttl && (now() - h.spawnAt) > h.ttl) {
        activeHazards.splice(i,1);
        continue;
      }
      // remove on OOB
      if (h.x < bounds.x - 30 || h.x > bounds.x + bounds.w + 30 || h.y < bounds.y - 30 || h.y > bounds.y + bounds.h + 30) {
        activeHazards.splice(i,1);
      }
      // homing adjustments
      if (h.homing) {
        const dir = normalize(player.x - h.x, player.y - h.y);
        h.vx = dir.x * h.speed;
        h.vy = dir.y * h.speed;
      }
    }
  }

  // Boss movement & attacks
  function updateBoss(dt, nowMs) {
  if (!bossObj) return;

  // ensure boss has an initial movement vector on first tick
  if (bossObj._initMovement !== true) {
    bossObj._initMovement = true;
    // aim roughly toward center or random direction so it will hit a wall soon
    const startDir = normalize((player.x || (canvas.width/2)) - bossObj.x, (player.y || 100) - bossObj.y);
    bossObj.vx = startDir.x * BOSS_SPEED;
    bossObj.vy = startDir.y * BOSS_SPEED;
    bossObj.moveTarget = { x: bossObj.x + bossObj.vx * 2, y: bossObj.y + bossObj.vy * 2 };
  }

  // advance boss
  bossObj.x += bossObj.vx * dt;
  bossObj.y += bossObj.vy * dt;

  // bounds for boss center
  const left = bounds.x + bossObj.radius, right = bounds.x + bounds.w - bossObj.radius;
  const top = bounds.y + bossObj.radius, bottom = bounds.y + bounds.h - bossObj.radius;
  let hitWall = false;
  if (bossObj.x <= left) { bossObj.x = left; hitWall = true; }
  if (bossObj.x >= right) { bossObj.x = right; hitWall = true; }
  if (bossObj.y <= top) { bossObj.y = top; hitWall = true; }
  if (bossObj.y >= bottom) { bossObj.y = bottom; hitWall = true; }

  // On hit wall, compute a straight-line trajectory toward the current player pos
  // and keep that vx/vy until the next wall collision
  if (hitWall) {
    const target = { x: player.x, y: player.y };
    const dir = normalize(target.x - bossObj.x, target.y - bossObj.y);
    bossObj.vx = dir.x * BOSS_SPEED;
    bossObj.vy = dir.y * BOSS_SPEED;
    bossObj.moveTarget = { x: bossObj.x + bossObj.vx * 1000, y: bossObj.y + bossObj.vy * 1000 };
  }

  // If boss somehow stopped (zero velocity), give it a small nudge toward player
  if (Math.abs(bossObj.vx) < 1e-3 && Math.abs(bossObj.vy) < 1e-3) {
    const n = normalize(player.x - bossObj.x, player.y - bossObj.y);
    bossObj.vx = n.x * (BOSS_SPEED * 0.8);
    bossObj.vy = n.y * (BOSS_SPEED * 0.8);
  }

  // Attacks scheduling
  if (!bossObj.lastBallOrSpillAt) bossObj.lastBallOrSpillAt = nowMs;
  if (!bossObj.lastCircleOrHomingAt) bossObj.lastCircleOrHomingAt = nowMs;

  if (nowMs - bossObj.lastBallOrSpillAt >= randInt(1000,3000)) {
    bossObj.lastBallOrSpillAt = nowMs;
    if (Math.random() < 0.5) bossSpillSpikes(); else bossThrowBall();
  }

  if (nowMs - bossObj.lastCircleOrHomingAt >= randInt(3000,5000)) {
    bossObj.lastCircleOrHomingAt = nowMs;
    if (Math.random() < 0.5) bossCircleTelegraph(); else bossHomingSpikes();
  }
}


  // Attack: spill 16 spikes from boss position outwards (deload OOB)
  function bossSpillSpikes() {
    const count = 16;
    for (let i=0;i<count;i++){
      const ang = (Math.PI*2) * (i/count);
      const dir = { x: Math.cos(ang), y: Math.sin(ang) };
      activeHazards.push({
        x: bossObj.x + dir.x*(bossObj.radius+8),
        y: bossObj.y + dir.y*(bossObj.radius+8),
        vx: dir.x * SPIKE_SPEED,
        vy: dir.y * SPIKE_SPEED,
        speed: SPIKE_SPEED,
        radius: 9,
        dmg: bossObj.dmg,
        spawnAt: now(),
        ttl: 7000
      });
    }
  }

  // Attack: throw a ball in straight line to player; after moderate travel spawn 8 small spikes from its endpoint
  function bossThrowBall() {
    const dir = normalize(player.x - bossObj.x, player.y - bossObj.y);
    const ball = {
      type: 'ball',
      x: bossObj.x,
      y: bossObj.y,
      vx: dir.x * BALL_SPEED,
      vy: dir.y * BALL_SPEED,
      speed: BALL_SPEED,
      radius: 16,
      dmg: Math.max(1, Math.floor(bossObj.dmg * 1.2)),
      traveled: 0,
      spawnAt: now(),
      explodeAfter: 600 // ms approximate travel before explode
    };
    activeHazards.push(ball);

    // schedule explosion after travel time check inside update loop: we implement explode check in hazards processing
    ball._explodeAt = now() + ball.explodeAfter;
    ball.postExploded = false;

    // explosion check done in hazards handling
    // when explosion triggers, spawn 8 spikes outward from ball location
    // spikes will be removed OOB as usual
  }

  // Attack: telegraphed circle at player's current location
  function bossCircleTelegraph() {
    const teleX = clamp(player.x, bounds.x + 20, bounds.x + bounds.w - 20);
    const teleY = clamp(player.y, bounds.y + 20, bounds.y + bounds.h - 20);
    // telegraph: show red circle for 1s, then active damage area for 5s
    const tele = {
      type: 'telegraphCircle',
      x: teleX, y: teleY, r: 72,
      spawnAt: now(),
      state: 'telegraph', // telegraph -> active
      teleMs: 1000,
      activeMs: 5000
    };
    activeHazards.push(tele);
  }

  // Attack: homing spikes for 9s lifespan
  function bossHomingSpikes() {
    const count = 6;
    for (let i=0;i<count;i++){
      const dir = normalize(Math.random()-0.5, Math.random()-0.5);
      const h = {
        x: bossObj.x,
        y: bossObj.y,
        vx: dir.x * HOMING_SPEED,
        vy: dir.y * HOMING_SPEED,
        speed: HOMING_SPEED,
        radius: 10,
        dmg: Math.max(1, Math.floor(bossObj.dmg * 0.9)),
        spawnAt: now(),
        ttl: 9000,
        homing: true
      };
      activeHazards.push(h);
    }
  }

  // Clean up OOB hazards and do ball explosion check
  function cleanupOutOfBounds() {
    for (let i = activeHazards.length - 1; i >= 0; i--) {
      const h = activeHazards[i];
      // ball explosion check
      if (h.type === 'ball' && !h.postExploded) {
        if (now() >= h._explodeAt) {
          // explode: spawn 8 spikes outward
          for (let j=0;j<8;j++){
            const ang = (Math.PI*2) * (j/8);
            const dir = { x: Math.cos(ang), y: Math.sin(ang) };
            activeHazards.push({
              x: h.x,
              y: h.y,
              vx: dir.x * SPIKE_SPEED,
              vy: dir.y * SPIKE_SPEED,
              speed: SPIKE_SPEED,
              radius: 5,
              dmg: Math.max(1, Math.floor(bossObj.dmg * 0.8)),
              spawnAt: now(),
              ttl: 7000
            });
          }
          h.postExploded = true;
          // remove the ball itself
          activeHazards.splice(i,1);
          continue;
        } else {
          // advance ball travel for explosion timing
          h.x += h.vx * (TICK_MS/1000);
          h.y += h.vy * (TICK_MS/1000);
        }
      }

      // other hazards moved in updateBullets; here we just remove OOB
      if (h.x < bounds.x - 40 || h.x > bounds.x + bounds.w + 40 || h.y < bounds.y - 40 || h.y > bounds.y + bounds.h + 40) {
        activeHazards.splice(i,1);
      }
    }
  }

  // Collision resolution: bullets vs boss/hazards vs player
  function resolveCollisions() {
  // player bullets hitting boss
  for (let i = playerBullets.length - 1; i >= 0; i--) {
    const b = playerBullets[i];
    if (bossObj && distance(b, bossObj) <= (b.radius + bossObj.radius)) {
      bossObj.hp = Math.max(0, bossObj.hp - (b.dmg || 1));
      playerBullets.splice(i, 1);

      // boss death from player bullets
      if (bossObj.hp <= 0) {
        // sync with global enemy object if present
        if (typeof enemyObj === 'object' && enemyObj) {
          if (typeof enemyObj.currentHp === 'number') enemyObj.currentHp = 1;
        }
        stopFinalBoss && stopFinalBoss('victory');
        return;
      }
      continue;
    }
  }

  // hazards hitting player
  const nowMs = now();
  for (let i = activeHazards.length - 1; i >= 0; i--) {
    const h = activeHazards[i];

    // telegraphed circle handling
    if (h.type === 'telegraphCircle') {
      const elapsed = nowMs - (h.spawnAt || 0);
      if (elapsed >= (h.teleMs || 1000) && elapsed < ((h.teleMs || 1000) + (h.activeMs || 5000))) {
        if (distance(h, player) <= (h.r + player.radius)) {
          // telegraph damage scale
          const dmg = h.dmg || Math.max(1, Math.floor((bossObj && bossObj.dmg) ? bossObj.dmg * 0.6 : 2));
          applyDamageToPlayer(dmg);
        }
      }
      // remove telegraph after full duration
      if (elapsed >= ((h.teleMs || 1000) + (h.activeMs || 5000))) {
        activeHazards.splice(i, 1);
      }
      continue;
    }

    // basic collision radius check
    if (distance(h, player) <= ((h.radius || 0) + player.radius)) {
      // homing hazards may have an activation delay
      const spawnAt = h.spawnAt || 0;
      const elapsed = nowMs - spawnAt;
      const activeAfter = h.activeAfter || 0;

      // prevent immediate damage for very-new homers
      if (h.homing && activeAfter && elapsed < activeAfter) {
        // warmup period; ignore collision for damage
        continue;
      }

      // simple player invulnerability after a hit to avoid instant death from clustered hazards
      const invulWindow = 400; // ms
      if (typeof window._lastPlayerHitAt === 'undefined') window._lastPlayerHitAt = 0;
      if ((nowMs - window._lastPlayerHitAt) < invulWindow) {
        // still invulnerable
        continue;
      }

      // apply damage
      const dmg = h.dmg || Math.max(1, Math.floor((bossObj && bossObj.dmg) ? bossObj.dmg * 0.6 : 2));
      applyDamageToPlayer(dmg);
      window._lastPlayerHitAt = nowMs;

      // remove most hazards on hit (spikes, homers, small projectiles)
      activeHazards.splice(i, 1);

      // check player death handled inside applyDamageToPlayer -> stopFinalBoss('defeat') will be called there
      continue;
    }
  }
}

  function applyDamageToPlayer(dmg) {
    // keep player's hp/damage persistent with original game state
    if (playerStats) {
      playerStats.currentHp = Math.max(0, playerStats.currentHp - dmg);
    }
    player.hp = Math.max(0, player.hp - dmg);
    showTemporaryText && showTemporaryText(`You take ${dmg} damage!`);
    if (player.hp <= 0 || (playerStats && playerStats.currentHp <= 0)) {
      stopFinalBoss('defeat');
      showGameOver();
    }
  }

  // Rendering
  function render() {
    if (!ctx) return;
    // clear
    ctx.clearRect(0,0,canvas.width,canvas.height);

    // draw bounds area
    ctx.fillStyle = '#0b0b10';
    ctx.fillRect(bounds.x, bounds.y, bounds.w, bounds.h);

    // draw wall border
    ctx.strokeStyle = '#999';
    ctx.lineWidth = 2;
    ctx.strokeRect(bounds.x, bounds.y, bounds.w, bounds.h);

    // draw player
    ctx.fillStyle = '#ffd76b';
    ctx.beginPath();
    ctx.arc(player.x, player.y, player.radius, 0, Math.PI*2);
    ctx.fill();

    // draw player bullets
    for (let b of playerBullets) {
      ctx.fillStyle = b.color || PLAYER_BULLET_COLOR;
      ctx.beginPath();
      ctx.arc(b.x, b.y, b.radius, 0, Math.PI*2);
      ctx.fill();
    }

    // draw boss (big)
    ctx.fillStyle = '#4ab9ff';
    ctx.beginPath();
    ctx.arc(bossObj.x, bossObj.y, bossObj.radius, 0, Math.PI*2);
    ctx.fill();

    // boss HP bar
    const barW = 160, barH = 10;
    const bx = canvas.width - barW - 20, by = 20;
    ctx.fillStyle = '#333';
    ctx.fillRect(bx, by, barW, barH);
    ctx.fillStyle = '#ff0000';
    ctx.fillRect(bx, by, barW * (bossObj.hp / bossObj.maxHp), barH);

    // draw hazards
    for (let h of activeHazards) {
      if (h.type === 'telegraphCircle') {
        const elapsed = now() - h.spawnAt;
        if (elapsed < h.teleMs) {
          // telegraph red translucent
          ctx.fillStyle = 'rgba(255, 60, 60, 0.45)';
        } else {
          ctx.fillStyle = 'rgba(36, 76, 146, 0.8)';
        }
        ctx.beginPath();
        ctx.arc(h.x, h.y, h.r, 0, Math.PI*2);
        ctx.fill();
      } else {
        // simple projectile draw
        ctx.fillStyle = '#509b6c';
        ctx.beginPath();
        ctx.arc(h.x, h.y, h.radius || 5, 0, Math.PI*2);
        ctx.fill();
      }
    }

    // draw HUD: player hp
    ctx.fillStyle = '#fff';
    ctx.font = '20px sans-serif';
    const hpText = `HP: ${player.hp}${playerStats ? ' / ' + (playerStats.currentHp || player.hp) : ''}`;
    ctx.fillText(hpText, 20, canvas.height - 20);
  }

  // Expose stop function for manual cleanup
  window.stopFinalBossBulletHell = stopFinalBoss;

  // small tick to handle ball explosion movement and hazard homing motion every TICK_MS
  // implement continuous update to move hazards toward their velocities
  (function hazardMoverLoop(){
    setInterval(() => {
      if (!running) return;
      // advance hazards that are not 'ball' (balls handled in cleanupOutOfBounds earlier)
      for (let h of activeHazards) {
        if (h.type === 'ball') continue;
        if (h.homing) {
          const dir = normalize(player.x - h.x, player.y - h.y);
          h.vx = dir.x * h.speed;
          h.vy = dir.y * h.speed;
        }
        h.x += (h.vx||0) * (TICK_MS/1000);
        h.y += (h.vy||0) * (TICK_MS/1000);
      }
      // move boss separately if needed (some movement handled in updateBoss)
    }, TICK_MS);
  })();

})();
  
//------ let's go gambling ----
  (() => {
  const slotPopup = document.getElementById('slot-machine-popup');
  const slotLeft = document.getElementById('slot-left');
  const slotMiddle = document.getElementById('slot-middle');
  const slotRight = document.getElementById('slot-right');
  const slotMsg = document.getElementById('slot-msg');
  const slotPlayBtn = document.getElementById('slot-play-button');
  const slotCloseBtn = document.getElementById('slot-close-button');

  const PATTERN = [1, 3, 7, 4, 5, 9, 8, 6, 2];
  const BET = 5;
  let cycleIntervals = [null, null, null];
  let indices = [0, 0, 0];
  let locked = [false, false, false];
  let currentSlot = 0;
  let numbers = [null, null, null];
  let playing = false;

  function startCycle(slotIdx) {
    if (cycleIntervals[slotIdx]) clearInterval(cycleIntervals[slotIdx]);
    indices[slotIdx] = Math.floor(Math.random() * PATTERN.length);
    locked[slotIdx] = false;
    const slotEl = [slotLeft, slotMiddle, slotRight][slotIdx];
    cycleIntervals[slotIdx] = setInterval(() => {
      indices[slotIdx] = (indices[slotIdx] + 1) % PATTERN.length;
      slotEl.textContent = PATTERN[indices[slotIdx]];
    }, 150);
  }

  function stopCycle(slotIdx) {
    if (cycleIntervals[slotIdx]) {
      clearInterval(cycleIntervals[slotIdx]);
      cycleIntervals[slotIdx] = null;
    }
    locked[slotIdx] = true;
    numbers[slotIdx] = PATTERN[indices[slotIdx]];
  }

  function resetSlots() {
    numbers = [null, null, null];
    locked = [false, false, false];
    currentSlot = 0;
    slotLeft.textContent = '-';
    slotMiddle.textContent = '-';
    slotRight.textContent = '-';
    slotMsg.textContent = 'Press Space to lock LEFT slot';
  }

  function calculatePayout() {
    const [a, b, c] = numbers;
    if (a == null || b == null || c == null) return 0;
    let payout = 0;
    if (a === b && b === c) payout = BET * 25;
    else if (a === b || b === c || a === c) payout = BET * 5;
    return payout;
  }

  function openSlotMachine() {
    if ((inventory.get('bolts') || 0) < BET) {
      showTemporaryText("Not enough bolts to play slot machine.");
      return;
    }
    playing = true;
    slotPopup.style.display = 'flex';
    resetSlots();
    startCycle(0);
  }

  function closeSlotMachine() {
    playing = false;
    slotPopup.style.display = 'none';
    cycleIntervals.forEach((id, idx) => {
      if (id) clearInterval(id);
      cycleIntervals[idx] = null;
    });
    draw();
  }

  function onSlotMachineKeyDown(e) {
    if (!playing) return;
    if (e.code === 'Space' || e.key === ' ') {
      e.preventDefault();
      if (!locked[currentSlot]) {
        stopCycle(currentSlot);
        currentSlot++;
        if (currentSlot < 3) {
          startCycle(currentSlot);
          const names = ['LEFT', 'MIDDLE', 'RIGHT'];
          slotMsg.textContent = `Press Space to lock ${names[currentSlot]} slot`;
        } else {
          const payout = calculatePayout();
          if (payout > 0) {
            const curBolts = inventory.get('bolts') || 0;
            inventory.set('bolts', curBolts + payout);
            slotMsg.textContent = `You won ${payout} bolts!`;
          } else {
            slotMsg.textContent = 'No win this time. Try again!';
          }
          playing = false;
        }
      }
    }
  }

  slotPlayBtn.addEventListener('click', () => {
    if (playing) return;
    if ((inventory.get('bolts') || 0) < BET) {
      showTemporaryText("Not enough bolts to play slot machine.");
      return;
    }
    const curBolts = inventory.get('bolts') || 0;
    inventory.set('bolts', curBolts - BET);
    drawInventoryBattlePopup?.();
    drawGeneralInventory?.();
    openSlotMachine();
  });

  slotCloseBtn.addEventListener('click', () => {
    closeSlotMachine();
  });

  window.addEventListener('keydown', (e) => {
    if (slotPopup.style.display === 'flex') {
      onSlotMachineKeyDown(e);
    }
  });

  window.openSlotMachine = () => {
    if ((inventory.get('bolts') || 0) < BET) {
      showTemporaryText("Not enough bolts to play slot machine.");
      return;
    }
    const curBolts = inventory.get('bolts') || 0;
    inventory.set('bolts', curBolts - BET);
    drawInventoryBattlePopup?.();
    drawGeneralInventory?.();
    openSlotMachine();
  };
})();

// ---------------------- Slap Jack minigame ----------------------
(function installSlapJack() {
  const overlay = document.getElementById('slapjack-overlay');
  const btnLock = document.getElementById('sj-lock-wager');
  const btnStart = document.getElementById('sj-start');
  const btnSlap = document.getElementById('sj-slap');
  const btnClose = document.getElementById('sj-close');
  const wagerInput = document.getElementById('sj-wager-input');
  const sjPlayerBolts = document.getElementById('sj-player-bolts');
  const sjYouCounter = document.getElementById('sj-you-counter');
  const sjMidCounter = document.getElementById('sj-mid-counter');
  const sjLastPlayer = document.getElementById('sj-last-player');
  const sjStatus = document.getElementById('sj-status');

  // Game state
  let sjActive = false;
  let sjWager = 0;
  let sjMyCards = 10; // Start with 10 cards
  let sjPile = 0;
  let sjPlayers = ['NPC1','NPC2','You','NPC3']; // turn order
  let sjTurnIndex = 0;
  let sjNpcCards = { NPC1: 10, NPC2: 10, NPC3: 10 }; // NPCs start with 10 cards
  let sjNpcActive = { NPC1: true, NPC2: true, NPC3: true };
  let sjInterval = null;
  let sjCardPlayIntervalMs = 1000; // each turn 1s
  let sjJackChance = 0.10; // chance the played card is a Jack
  let sjJackActive = false;
  let sjJackPlayedBy = null;
  let sjJackWindowTimeout = null;
  let sjNpcSlapTimers = [];
  const WIN_TARGET = 30;
  const WRONG_SLAP_PENALTY = 3;

  function updateUi() {
    sjPlayerBolts.textContent = (inventory.get('bolts') || 0);
    sjYouCounter.textContent = `Cards: ${sjMyCards}`;
    sjMidCounter.textContent = `Pile: ${sjPile}`;
    sjStatus.textContent = sjActive ? (sjJackActive ? 'JACK! SLAP!' : 'In game') : 'Wager bolts to play';
    sjLastPlayer.textContent = `Last: ${sjJackPlayedBy || '—'}`;
    document.getElementById('sj-npc-top').textContent = `NPC 1\n(${sjNpcActive.NPC1? sjNpcCards.NPC1 : 'out'})`;
    document.getElementById('sj-npc-right').textContent = `NPC 2\n(${sjNpcActive.NPC2? sjNpcCards.NPC2 : 'out'})`;
    document.getElementById('sj-npc-left').textContent = `NPC 3\n(${sjNpcActive.NPC3? sjNpcCards.NPC3 : 'out'})`;
    btnStart.disabled = !sjWager || (inventory.get('bolts') || 0) < sjWager || sjActive;
    btnSlap.disabled = !sjActive; // can press slap anytime while game active
  }

  function openSlapJack() {
    overlay.style.display = 'flex';
    updateUi();
  }
  function closeSlapJack() {
    overlay.style.display = 'none';
    stopGame();
  }

  btnLock.addEventListener('click', () => {
    const val = Math.max(1, Math.floor(Number(wagerInput.value) || 0));
    if (val <= 0) { showTemporaryText('Enter at least 1 bolt'); return; }
    if ((inventory.get('bolts') || 0) < val) { showTemporaryText('Not enough bolts'); return; }
    sjWager = val;
    wagerInput.value = val;
    wagerInput.disabled = true;
    btnLock.disabled = true;
    showTemporaryText(`Wager locked: ${val} bolts`);
    updateUi();
  });

  btnStart.addEventListener('click', () => {
    if (sjActive) return;
    const bolts = inventory.get('bolts') || 0;
    if (sjWager <= 0 || bolts < sjWager) { showTemporaryText('Lock a valid wager first'); return; }
    inventory.set('bolts', bolts - sjWager);
    showTemporaryText(`Wager placed: ${sjWager} bolts`);
    // reset state for new game
    sjNpcCards = { NPC1: 10, NPC2: 10, NPC3: 10 };
    sjNpcActive = { NPC1: true, NPC2: true, NPC3: true };
    sjMyCards = 10;
    sjPile = 0;
    sjTurnIndex = 0;
    sjJackActive = false;
    sjJackPlayedBy = null;
    clearAllNpcSlapTimers();
    sjActive = true;
    btnStart.disabled = true;
    wagerInput.disabled = true;
    btnLock.disabled = true;
    updateUi();
    sjInterval = setInterval(playCardToPile, sjCardPlayIntervalMs);
    // immediate first play
    playCardToPile();
  });

  function stopGame() {
    sjActive = false;
    if (sjInterval) { clearInterval(sjInterval); sjInterval = null; }
    if (sjJackWindowTimeout) { clearTimeout(sjJackWindowTimeout); sjJackWindowTimeout = null; }
    clearAllNpcSlapTimers();
    wagerInput.disabled = false; btnLock.disabled = false; btnStart.disabled = false;
    sjWager = 0;
    updateUi();
  }

  function clearAllNpcSlapTimers() {
    while (sjNpcSlapTimers.length) {
      const id = sjNpcSlapTimers.pop();
      clearTimeout(id);
    }
  }

  function advanceTurnIndex() {
    const MAX = sjPlayers.length;
    for (let i=1;i<=MAX;i++){
      const idx = (sjTurnIndex + i) % MAX;
      const p = sjPlayers[idx];
      if (p === 'You' || sjNpcActive[p]) { sjTurnIndex = idx; return; }
    }
    // fallback
    sjTurnIndex = sjPlayers.indexOf('You');
  }

  function playCardToPile() {
    if (!sjActive) return;

    const actor = sjPlayers[sjTurnIndex];

    // If actor is You: you must have a card to play; if you have none you skip
    if (actor === 'You') {
      if (sjMyCards > 0) {
        sjMyCards -= 1;
        sjPile += 1;
        sjLastPlayer.textContent = 'Last: You';
        // if you drop to zero you can still play 0 (zero doesn't add)
      } else {
        // you have no cards; skip
      }
    } else {
      if (!sjNpcActive[actor]) {
        advanceTurnIndex();
        return;
      }
      if ((sjNpcCards[actor] || 0) > 0) {
        sjNpcCards[actor] -= 1;
        sjPile += 1;
        sjLastPlayer.textContent = `Last: ${actor}`;
        if (sjNpcCards[actor] <= 0) {
          sjNpcActive[actor] = false;
          showTemporaryText(`${actor} ran out of cards`);
        }
      } else {
        sjNpcActive[actor] = false;
      }
    }

    // Show which card was played in the pile UI (simple textual indicator)
    // Randomly decide whether it's a Jack
    const isJack = !sjJackActive && (Math.random() < sjJackChance);
    if (isJack) {
      sjJackActive = true;
      sjJackPlayedBy = actor;
      // schedule NPC slap attempts (they race to slap)
      scheduleNpcSlaps();
      // set a window timeout after which Jack is considered missed if no one slaps
      if (sjJackWindowTimeout) clearTimeout(sjJackWindowTimeout);
      sjJackWindowTimeout = setTimeout(() => {
        if (sjJackActive) {
          sjJackActive = false;
          sjJackPlayedBy = null;
          showTemporaryText('Jack window expired');
          clearAllNpcSlapTimers();
          updateUi();
        }
      }, 900); // 900ms window
    } else {
      // not a Jack: show normal card label
      showTemporaryText(`${actor} played a card`);
    }

    // update visuals
    updateUi();

    // Check if anyone reached target (NPC win)
    for (const npc of ['NPC1','NPC2','NPC3']) {
      if (sjNpcCards[npc] >= WIN_TARGET) {
        // NPC wins -> you lose immediately
        showTemporaryText(`${npc} reached ${WIN_TARGET} cards — you lose the wager.`);
        // no refund
        stopGame();
        return;
      }
    }

    // Check if you reached target (shouldn't usually happen because you take pile; kept for symmetry)
    if (sjMyCards >= WIN_TARGET) {
      // you win
      showTemporaryText('You reached 30 cards and win!');
      // award double wager
      const cur = inventory.get('bolts') || 0;
      inventory.set('bolts', cur + (sjWager * 2));
      stopGame();
      return;
    }

    // Move to next player
    advanceTurnIndex();
    updateUi();
  }

  function scheduleNpcSlaps() {
    clearAllNpcSlapTimers();
    // each NPC attempts to slap after a small random delay; the earliest to fire takes it if still active
    ['NPC1','NPC2','NPC3'].forEach(npc => {
      if (!sjNpcActive[npc]) return;
      const delay = 500 + Math.floor(Math.random() * 500); //
      const t = setTimeout(() => {
        if (!sjJackActive) return;
        // NPC attempts to slap now
        if (!sjActive) return;
        // NPC "slap" resolves: they take the pile
        const taken = sjPile;
        sjPile = 0;
        sjNpcCards[npc] = (sjNpcCards[npc] || 0) + taken;
        sjJackActive = false;
        sjJackPlayedBy = null;
        clearAllNpcSlapTimers();
        if (sjJackWindowTimeout) { clearTimeout(sjJackWindowTimeout); sjJackWindowTimeout = null; }
        showTemporaryText(`${npc} slapped first and grabbed ${taken} cards!`);
        updateUi();

        // Check NPC win
        if (sjNpcCards[npc] >= WIN_TARGET) {
          showTemporaryText(`${npc} reached ${WIN_TARGET} cards — you lose.`);
          stopGame();
        }
      }, delay);
      sjNpcSlapTimers.push(t);
    });
  }

  // Player pressing SLAP
  btnSlap.addEventListener('click', () => {
    if (!sjActive) return;
    if (sjJackActive) {
      // Player slapped successfully and takes the pile
      const taken = sjPile;
      sjPile = 0;
      sjMyCards += taken;
      sjJackActive = false;
      sjJackPlayedBy = null;
      if (sjJackWindowTimeout) { clearTimeout(sjJackWindowTimeout); sjJackWindowTimeout = null; }
      clearAllNpcSlapTimers();
      showTemporaryText(`You slapped first and took ${taken} cards!`);
      updateUi();

      // Check win
      if (sjMyCards >= WIN_TARGET) {
        const cur = inventory.get('bolts') || 0;
        inventory.set('bolts', cur + (sjWager * 2));
        showTemporaryText('You achieved 30 cards — you win!');
        stopGame();
      }
      return;
    } else {
      // Wrong slap: penalty
      sjMyCards = Math.max(0, sjMyCards - WRONG_SLAP_PENALTY);
      showTemporaryText(`Wrong slap! -${WRONG_SLAP_PENALTY} cards`);
      updateUi();
      return;
    }
  });

  function winSlapJack() {
    const current = inventory.get('bolts') || 0;
    inventory.set('bolts', current + (sjWager * 2));
    showTemporaryText(`You win! Collected ${sjMyCards} cards. Earned ${sjWager * 2} bolts`);
    stopGame();
  }

  btnClose.addEventListener('click', () => {
  if (sjActive) {
    showTemporaryText('Wager forfeited');
  }
  closeSlapJack();
  draw();
});


  window.openSlapJack = openSlapJack;

  // Initialize UI values
  updateUi();
})();
  
// --- Simple Shop Popup (buy bandaid, emp_grenade, extra_life, poison_vial) ---
(function installSimpleShop() {
  if (document.getElementById('simple-shop-popup')) return;

  
  const shopPrices = {
    bandaid: 4,
    emp_grenade: 12,
    extra_life: 24,
    poison_vial: 7
  };

  // Create DOM
  const shopOverlay = document.createElement('div');
  shopOverlay.id = 'simple-shop-popup';
  Object.assign(shopOverlay.style, {
    display: 'none',
    position: 'fixed',
    inset: '0',
    zIndex: 5000,
    background: 'rgba(0,0,0,0.8)',
    alignItems: 'center',
    justifyContent: 'center'
  });

  const shopBox = document.createElement('div');
  Object.assign(shopBox.style, {
    width: '320px',
    maxWidth: '90vw',
    background: '#002591',
    border: '2px solid black',
    padding: '12px',
    boxSizing: 'border-box',
    fontFamily: "'Press Start 2P', sans-serif",
    color: 'white',
    textAlign: 'center'
  });

  shopBox.innerHTML = `
    <div style="margin-bottom:8px;"><strong>Battle Shop</strong></div>
    <div id="simple-shop-items" style="display:flex;flex-direction:column;gap:8px;margin-bottom:8px;"></div>
    <div style="display:flex;gap:8px;justify-content:center;">
      <button id="simple-shop-close" style="padding:8px;border:2px solid white;background:#333;color:white;cursor:pointer;">Close</button>
    </div>
    <div id="simple-shop-message" style="margin-top:8px;font-size:11px;color:#ffd"></div>
  `;

  shopOverlay.appendChild(shopBox);
  document.body.appendChild(shopOverlay);

  const itemsContainer = shopBox.querySelector('#simple-shop-items');
  const msgEl = shopBox.querySelector('#simple-shop-message');
  const closeBtn = shopBox.querySelector('#simple-shop-close');

  // Build item rows
  function renderShopItems() {
    itemsContainer.innerHTML = '';
    Object.keys(shopPrices).forEach(key => {
      const price = shopPrices[key];
      const displayName = key.replace(/_/g, ' ').replace(/\b\w/g, c => c.toUpperCase());
      const row = document.createElement('div');
      Object.assign(row.style, { display: 'flex', justifyContent: 'space-between', alignItems: 'center', gap: '8px' });
      row.innerHTML = `
        <div style="text-align:left;">
          <div style="font-size:11px;">${displayName}</div>
          <div style="font-size:10px;opacity:0.85;">Price: ${price} bolts</div>
        </div>
      `;
      const buyBtn = document.createElement('button');
      buyBtn.textContent = 'Buy';
      buyBtn.className = 'item-use-button';
      buyBtn.style.padding = '6px 8px';
      buyBtn.addEventListener('click', () => buyItem(key, price));
      row.appendChild(buyBtn);
      itemsContainer.appendChild(row);
    });
  }

  function buyItem(itemKey, price) {
    const bolts = inventory.get('bolts') || 0;
    if (bolts < price) {
      showShopMessage('Not enough bolts!');
      return;
    }
    // Deduct bolts and add item to inventory (or increase quantity)
    inventory.set('bolts', bolts - price);
    const current = inventory.get(itemKey) || 0;
    inventory.set(itemKey, current + 1);

    // UI updates
    showTemporaryText(`Bought ${itemKey.replace(/_/g,' ')} +1`);
    showShopMessage(`Purchased ${itemKey.replace(/_/g,' ')} for ${price} bolts.`);
    console.log(`Shop: bought ${itemKey}, new qty: ${inventory.get(itemKey)}, bolts left: ${inventory.get('bolts')}`);
    // refresh any inventory UIs that may be visible
    try { drawInventoryBattlePopup(); drawGeneralInventory(); } catch (e) {}
    updateHp(playerStats.currentHp); // in case you show bolts somewhere inside hud
  }

  function showShopMessage(s) {
    if (!msgEl) return;
    msgEl.textContent = s;
    setTimeout(() => { if (msgEl) msgEl.textContent = ''; }, 2200);
  }

  closeBtn.addEventListener('click', () => {
    shopOverlay.style.display = 'none';
    draw(); // refresh canvas/hud
  });

  // Expose open function
  window.openShop = function() {
    renderShopItems();
    shopOverlay.style.display = 'flex';
  };

  // Example: add a quick keyboard toggle (press 'p' to open shop) - optional, remove if undesired
  document.addEventListener('keydown', (e) => {
    if (e.key.toLowerCase() === 'p') {
      if (shopOverlay.style.display === 'none') window.openShop();
      else shopOverlay.style.display = 'none';
    }
  });

  // initial render
  renderShopItems();
})();
  
  // ---------- Target Practice Mini-game ----------
(function installTargetPractice() {
  // Tunables
  const TP_DURATION_MS = 30_000;         // 30s round
  const TP_MIN_SPAWN_MS = 700;           // spawn interval min
  const TP_MAX_SPAWN_MS = 1200;          // spawn interval max
  const TP_TARGET_LIFETIME_MS = 1500;    // normal target lifetime
  const TP_GOLD_LIFETIME_MS = 750;       // golden target lifetime
  const TP_NORMAL_SCORE = 100;
  const TP_GOLD_SCORE = 300;
  const TP_ATTEMPTS_MAX = 5;
  const TP_GOAL_FIXED = 4500;            // fixed hard goal (used if TP_GOAL_RANDOMIZE false)
  const TP_GOAL_RANDOMIZE = false;
  const TP_GOAL_MIN = 1200;
  const TP_GOAL_MAX = 1800;
  const GOLD_TIMES = [10_000, 20_000];   // golden spawn times (ms)
  const WAVE_COUNT = 12;                 // number of targets in final 3s burst
  const WAVE_SPREAD_MS = 40;             // base delay between burst spawns
  const WAVE_JITTER_MS = 80;             // added random jitter per spawn

  // State
  let tpAttemptsLeft = TP_ATTEMPTS_MAX;
  let tpActive = false;
  let tpTimerId = null;
  let tpSpawnTimeout = null;
  let tpRoundStart = 0;
  let tpScore = 0;
  let tpGoal = 0;
  let tpRemainingTimeMs = TP_DURATION_MS;
  let tpWon = false;
  let tpGoldenSpawnedAt = new Set();
  let tpThreeSecondWaveSpawned = false;

  // Elements
  const overlay = document.getElementById('target-practice-overlay');
  const playfield = document.getElementById('tp-playfield');
  const timerEl = document.getElementById('tp-timer');
  const scoreEl = document.getElementById('tp-score');
  const goalEl = document.getElementById('tp-goal');
  const attemptsEl = document.getElementById('tp-attempts');
  const restartBtn = document.getElementById('tp-restart');
  const closeBtn = document.getElementById('tp-close');

  function randBetween(a, b) { return a + Math.random() * (b - a); }
  function randInt(a, b) { return Math.floor(randBetween(a, b + 1)); }

  function openTargetPractice() {
    if (tpWon) { showTemporaryText && showTemporaryText('You already beat this challenge!'); return; }
    if (tpAttemptsLeft <= 0) {
      showDialog && showDialog(
        ["Looks like you couldn't beat my score. It's okay, they don't call me the sharpest shooter in the west for nothin"],
        null,
        { style: 'unit', speaker: typeof Unit318920 !== 'undefined' ? Unit318920 : null }
      );
      return;
    }
    overlay && (overlay.style.display = 'flex');
    startRound();
  }

  function closeTargetPractice() {
    stopRound();
    overlay && (overlay.style.display = 'none');
  }

  function startRound() {
    stopRound(); // reset any existing timers/targets
    tpActive = true;
    tpRoundStart = performance.now();
    tpScore = 0;
    tpRemainingTimeMs = TP_DURATION_MS;
    tpGoldenSpawnedAt.clear();
    tpThreeSecondWaveSpawned = false;
    tpGoal = TP_GOAL_RANDOMIZE ? randInt(TP_GOAL_MIN, TP_GOAL_MAX) : TP_GOAL_FIXED;
    scoreEl && (scoreEl.textContent = `Score: ${tpScore}`);
    goalEl && (goalEl.textContent = `Goal: ${tpGoal}`);
    attemptsEl && (attemptsEl.textContent = tpAttemptsLeft);
    updateTimerDisplay(tpRemainingTimeMs);
    scheduleNextSpawn();
    tpTimerId = setInterval(tickRound, 100);
  }

  function stopRound() {
    tpActive = false;
    if (tpTimerId) { clearInterval(tpTimerId); tpTimerId = null; }
    if (tpSpawnTimeout) { clearTimeout(tpSpawnTimeout); tpSpawnTimeout = null; }
    clearAllTargets();
  }

  function tickRound() {
    const elapsed = performance.now() - tpRoundStart;
    tpRemainingTimeMs = Math.max(0, TP_DURATION_MS - elapsed);
    updateTimerDisplay(tpRemainingTimeMs);

    // Golden spawns at configured times
    for (const t of GOLD_TIMES) {
      if (elapsed >= t && !tpGoldenSpawnedAt.has(t)) {
        tpGoldenSpawnedAt.add(t);
        spawnTarget(true);
      }
    }

    // Final 3-second burst: spawn WAVE_COUNT normal targets once
    if (!tpThreeSecondWaveSpawned && tpRemainingTimeMs <= 3000) {
      tpThreeSecondWaveSpawned = true;
      for (let i = 0; i < WAVE_COUNT; i++) {
        setTimeout(() => { if (tpActive) spawnTarget(false); }, i * WAVE_SPREAD_MS + Math.floor(Math.random() * WAVE_JITTER_MS));
      }
    }

    if (tpRemainingTimeMs <= 0) {
      endRound();
    }
  }

  function updateTimerDisplay(ms) {
    const sec = Math.ceil(ms / 1000);
    timerEl && (timerEl.textContent = String(sec));
  }

  function scheduleNextSpawn() {
    const delay = randBetween(TP_MIN_SPAWN_MS, TP_MAX_SPAWN_MS);
    tpSpawnTimeout = setTimeout(() => {
      if (!tpActive) return;
      spawnTarget(false);
      scheduleNextSpawn();
    }, delay);
  }

  function spawnTarget(isGolden) {
    if (!playfield) return;
    const pfRect = playfield.getBoundingClientRect();
    const pad = 8;
    const tw = isGolden ? 72 : 64;
    const th = isGolden ? 72 : 64;
    const maxX = Math.max(0, pfRect.width - tw - pad);
    const maxY = Math.max(0, pfRect.height - th - pad);
    const x = randBetween(pad, maxX);
    const y = randBetween(pad, maxY);
    const el = document.createElement('div');
    el.className = `tp-target ${isGolden ? 'golden' : 'normal'}`;
    el.style.left = `${Math.round(x)}px`;
    el.style.top = `${Math.round(y)}px`;
    const label = document.createElement('div');
    label.className = 'tp-target-label';
    label.textContent = isGolden ? String(TP_GOLD_SCORE) : String(TP_NORMAL_SCORE);
    el.appendChild(label);
    playfield.appendChild(el);

    const life = isGolden ? TP_GOLD_LIFETIME_MS : TP_TARGET_LIFETIME_MS;
    let removed = false;
    const remove = () => { if (!removed) { removed = true; el.remove(); } };
    const lifeTimer = setTimeout(remove, life);

    function onClick() {
      if (!tpActive) return;
      clearTimeout(lifeTimer);
      remove();
      el.removeEventListener('click', onClick);
      const gained = isGolden ? TP_GOLD_SCORE : TP_NORMAL_SCORE;
      tpScore += gained;
      scoreEl && (scoreEl.textContent = `Score: ${tpScore}`);
      showTemporaryText && showTemporaryText(`+${gained}`);
      if (tpScore >= tpGoal) {
        endRound(true);
      }
    }
    el.addEventListener('click', onClick);
  }

  function clearAllTargets() {
    if (!playfield) return;
    while (playfield.firstChild) playfield.firstChild.remove();
  }

  function endRound(didWin = false) {
    if (!tpActive) return;
    stopRound();
    if (didWin || tpScore >= tpGoal) {
      tpWon = true;
      // award achievement if exists
      if (achievementsMap && achievementsMap['tp_beat_master']) {
        achievementsMap['tp_beat_master'].progress = 1;
        checkAchievements && checkAchievements();
      } else if (achievementsMap) {
        achievementsMap['tp_beat_master'] = {
          id: 'tp_beat_master',
          name: 'Sharp Shooter',
          description: 'Beat Unit318920s score in Target Practice',
          target: 1,
          progress: 1,
          unlocked: false,
          checkCondition: function() { return this.progress >= 1; }
        };
        checkAchievements && checkAchievements();
      }
      showTemporaryText && showTemporaryText('You beat the goal! Achievement unlocked!');
      tpAttemptsLeft = 0;
      attemptsEl && (attemptsEl.textContent = tpAttemptsLeft);
      setTimeout(() => overlay && (overlay.style.display = 'none'), 1300);
    } else {
      // failed attempt
      tpAttemptsLeft = Math.max(0, tpAttemptsLeft - 1);
      attemptsEl && (attemptsEl.textContent = tpAttemptsLeft);
      if (tpAttemptsLeft <= 0) {
        showDialog && showDialog(
          ["Looks like you couldn't beat my score. It's okay, they don't call me the sharpest shooter in the west for nothin"],
          null,
          { style: 'unit', speaker: typeof Unit318920 !== 'undefined' ? Unit318920 : null }
        );
        overlay && (overlay.style.display = 'none');
      } else {
        showTemporaryText && showTemporaryText('Attempt failed. Restart or close.');
      }
    }
  }

  // UI wiring
  if (restartBtn) restartBtn.addEventListener('click', () => {
    if (tpAttemptsLeft <= 0 || tpWon) { showTemporaryText && showTemporaryText('No more attempts.'); return; }
    startRound();
  });
  if (closeBtn) closeBtn.addEventListener('click', () => {
    closeTargetPractice();
  });

  // Key binding: 'x' opens overlay when not in battle
  document.addEventListener('keydown', (e) => {
  if (e.key.toLowerCase() === 'x') {
    e.preventDefault();
    const obj = checkInteraction(x - 16, y) || checkInteraction(x + 16, y) || checkInteraction(x, y - 16) || checkInteraction(x, y + 16) || checkInteraction(x, y);
    if (obj && obj.action === 'target_practice') openTargetPractice();
    else if (obj) handleInteraction(obj);
    else {
      const zone = findNearbyDialogZone(x, y);
      if (zone) showDialog(zone.text, zone.id, { style: zone.style || 'dialog', speaker: zone.speaker || null });
      else showTemporaryText('.');
    }
  }
});


  // Expose functions
  window.openTargetPractice = openTargetPractice;
  window.closeTargetPractice = closeTargetPractice;
})();



function drawAchievementsUI() {
  achievementsPopup.innerHTML = '';
  achievements.forEach(ach => {
    const div = document.createElement('div');
    div.textContent = ach.unlocked ? `✓ ${ach.name}` : `🔒 ${ach.name}`;
    div.title = ach.unlocked ? '' : ach.description; // Hover text only if locked
    div.style.cursor = ach.unlocked ? 'default' : 'help';
    div.style.padding = '4px 0';
    if (ach.unlocked) div.style.color = 'lightgreen';
    else div.style.color = 'gray';
    achievementsPopup.appendChild(div);
  });
}

  function showAchievementUnlocked(ach) {
  showTemporaryText(`Achievement unlocked: ${ach.name}!`);
}
// Check collision with interactables
function checkInteraction(checkX, checkY) {
  const hitboxX = checkX + hitboxOffsetX;
  const hitboxY = checkY + hitboxOffsetY;
  if (!currentLevel.interactables) return null;
  for (const object of currentLevel.interactables) {
    const r = object.interactRect || { x: object.x, y: object.y, width: object.width, height: object.height };
    if (
      hitboxX < r.x + r.width &&
      hitboxX + hitboxWidth > r.x &&
      hitboxY < r.y + r.height &&
      hitboxY + hitboxHeight > r.y
    ) return object;
  }
  return null;
}


// Handle interaction actions
function handleInteraction(object) {
  if (!object) return;
  // inside handleInteraction(object) add a branch for action === "recruit"
if (object.action === "recruit") {
  // optional short dialog before unlocking
  const preText = object.recruitDialog || [`You meet ${object.displayName || 'someone'}.`, 'They might help you.'];
  // showDialog accepts text or lines; here we mark the dialog id so it's not retriggered
  showDialog(preText, object.id, { style: object.dialogStyle || 'dialog', speaker: object.speaker || null });

  // unlock immediately so the player can equip right away after dialog closes
  // store the allyId on the object as object.allyId (set in level data)
  if (object.allyId) {
    // if you want the unlock to happen only after dialog confirmed, move this call into dialog-next handler by checking overlay._markId
    unlockAlly(object.allyId);
  } else {
    console.warn('recruit object missing allyId', object);
    showTemporaryText('Nothing happened.');
  }

  // remove the interactable so it can't be recruited repeatedly
  currentLevel.interactables = currentLevel.interactables.filter(o => o !== object);
  draw();
  return;
}
  if (object.action === "item_gate") {
    if (object.opened) {
      showDialog(object.messages?.opened || "You may go now.", object.dialogId);
      return;
    }

    // check required items
    const missingItems = (object.requiredItems || []).filter(item => (inventory.get(item) || 0) <= 0);
    if (missingItems.length > 0) {
      showDialog(object.messages?.needItems || "You need items to pass!", object.dialogId);
      return;
    }

    object.opened = true;
    if (object.wallId) {
      // remove wall by id from currentLevel.walls
      currentLevel.walls = currentLevel.walls.filter(wall => wall.id !== object.wallId);
    }
    showDialog(object.messages?.opened || "You may go now.", object.dialogId);
    draw();
    return;
  }
   if (object.action === "photo") {
      showDialog([
  { speaker: '8-Bit', text: "It's a photo of my friends!", style: 'dialog' },
  { speaker: '8-Bit', text: "Where are they? They should be somewhere near, I have to assume.", style: 'dialog' },
  { speaker: '8-Bit', text: "Oh... man, I hope nothing happened to them.", style: 'dialog' }
]);
      return;
    }
      if (object.action === "arcadekey") {
      showDialog([
  { speaker: '8-Bit', text: "Oh, yeah, it's a key.", style: 'dialog' },
  { speaker: '8-Bit', text: "I'm going to leave it there.", style: 'dialog' }
]);
      return;
    }
if (object.action === "arcadetrophy") {
      showDialog([
  { speaker: '8-Bit', text: "We won this little bad boy from a competition.", style: 'dialog' },
  { speaker: '8-Bit', text: "A gaming competition.", style: 'dialog' },
  { speaker: '8-Bit', text: "Us three, we make a great team.", style: 'dialog' }
]);
      return;
    }
  
if (object.action === 'target_practice' && object.name === 'target_board') {
  openTargetPractice();
  return;
}
 if (object.action === 'shop') {
  window.openShop();
  return;
} 
  if (object.action === 'slot_machine') {
  if (window.openSlotMachine) window.openSlotMachine();
  return;
}
if (object.action === 'slap_jack') {
  // Open Slap Jack UI (wagering done in UI)
  if (window.openSlapJack) window.openSlapJack();
  return;
}


// Lever interactions
if (object.action === 'lever') {
  // ensure runtime state exists
  if (typeof object.currentState === 'undefined') object.currentState = !!object.initialState;
  object.currentState = !object.currentState;
  showTemporaryText(object.currentState ? 'Lever turned on.' : 'Lever turned off.');
  // Single lever toggles its linked wall: design choice -> when lever ON remove wall
  if (object.leverType === 'single') {
    if (object.linkedWallId) {
      const targetLevelIndex = (typeof object.linkedLevelIndex === 'number') ? object.linkedLevelIndex : currentLevelIndex;
      toggleWallById(object.linkedWallId, !object.currentState, targetLevelIndex);
    }
  }
  // Multi lever flips and triggers group evaluation
  if (object.leverType === 'multi' && object.groupId) {
    evaluateMultiLeverGroup(object.groupId);
  }
  draw();
  return;
}


if (object.action === 'lever_controller') {
  if (object.groupId) {
    evaluateMultiLeverGroup(object.groupId, object);
  } else {
    showTemporaryText('Controller not linked to a group.');
  }
  return;
}



  if (object.action === "use_drill") {
  if ((inventory.get("drill") || 0) > 0) {
    showTemporaryText("You use the drill to break through the crack!");
    loadLevel(object.destLevel, object.destX, object.destY);
  } else {
    showTemporaryText("You need a drill to break through here.");
  }
  return;
}
  
  if (object.action === 'open_door' && !object.requiresKeycard) {
  loadLevel(object.destLevel, object.destX, object.destY);
  draw();
  return;
}


  if (object.requiresKeycard) {
    if ((inventory.get('keycard') || 0) > 0) {
      showTemporaryText("You used a keycard to activate this.");
      // Implement whatever action keycard triggers here, e.g., open door, disable alarm
      if (object.action === 'open_door') {
        loadLevel(object.destLevel, object.destX, object.destY);
      }
      // Remove or disable object after use if needed
      currentLevel.interactables = currentLevel.interactables.filter(o => o !== object);
      draw();
    } else {
      showTemporaryText("You need a keycard to use this.");
    }
    return;
  }
  if (object.action === "password_door") {
  openPasswordPopup(object);
  return;
}
  
  if (object.name === "power_box") {
    if (!gameFlags.isPowered) {
      gameFlags.isPowered = true;
      showTemporaryText("You pressed something on the box. The arcade machine flickers to life, barely.");
      draw();
    } else {
      showTemporaryText("The power is already on.");
    }
    return;
  }

  if (object.name === "arcade_machine") {
    if (gameFlags.isPowered) {
      initiateBattle('interactable', object);
    } else {
      showTemporaryText("The machine is turned off ...");
    }
    return;
  }

  if (object.action === "break") {
  const tool = object.requiredItem;
  if ((inventory.get(tool) || 0) > 0) {
    // Remove interactable first
    currentLevel.interactables = currentLevel.interactables.filter(o => o !== object);

    // Remove matching walls and track removed wall IDs
    currentLevel.walls = currentLevel.walls.filter(wall => {
      if (
        wall.x === object.x &&
        wall.y === object.y &&
        wall.width === object.width &&
        wall.height === object.height
      ) {
        removedWallIds.add(wall.id);
        return false;
      }
      return true;
    });
  }
}


  
if (object.action === "chest") {
  // if already opened, show a short message and return
  if (object.opened) {
    showDialog("The chest is empty.", null, { speaker: null });
    return;
  }

  // mark opened so it won't grant again
  object.opened = true;

  // grant rewards (rewards is array of [key, qty])
  const rewardLines = [];
  if (Array.isArray(object.rewards)) {
    for (const [key, qty] of object.rewards) {
      const current = inventory.get(key) || 0;
      inventory.set(key, current + (qty || 1));
      rewardLines.push(`+${qty || 1} ${key}`);
    }
  }

  achievementsMap['open_chests'].progress++;
  checkAchievements();
  // Build a dialog that lists all rewards (guaranteed)
  const dialogText = ["You opened the chest!", "You received:"].concat(rewardLines);
  showDialog(dialogText, object.id, { speaker: null });

  // optionally update UI immediately
  draw();
  return;
}

  if (object.action === "pickup") {
    const key = object.itemName;
    const current = inventory.get(key) || 0;
    inventory.set(key, current + 1);
    currentLevel.interactables = currentLevel.interactables.filter(o => o !== object);
    currentLevel.walls = currentLevel.walls.filter(w =>
      !(w.x === object.x && w.y === object.y && w.width === object.width && w.height === object.height)
    );
    showTemporaryText(`Picked up a ${key}!`);
    return;
  }
}
  
document.addEventListener('DOMContentLoaded', () => {
  // Elements
  const settingsButton = document.getElementById('settings-button');
  const settingsPopup = document.getElementById('settings-popup');
  const inventoryPopup = document.getElementById('inventory-popup');
  const partyPopup = document.getElementById('party-popup');
  const statsPopup = document.getElementById('stats-popup');

  if (!settingsButton) return console.error('Settings wiring: missing #settings-button in DOM');
  if (!settingsPopup) return console.error('Settings wiring: missing #settings-popup in DOM');

  // Safe defaults for gameSettings if not present
  window.gameSettings = window.gameSettings || { difficulty: 'normal', showZones: false };

  // Toggle behavior (matches other HUD popup logic)
  settingsButton.addEventListener('click', () => {
    try {
      const hidden = window.getComputedStyle(settingsPopup).display === 'none';
      if (inventoryPopup) inventoryPopup.style.display = 'none';
      if (partyPopup) partyPopup.style.display = 'none';
      if (statsPopup) statsPopup.style.display = 'none';
      settingsPopup.style.display = hidden ? 'block' : 'none';
    } catch (e) {
      console.error('Settings wiring: toggle error', e);
    }
  });

  // Initialize UI controls
  const difficultySelect = document.getElementById('difficulty-select');
  const toggleZones = document.getElementById('toggle-zones');

  if (difficultySelect) difficultySelect.value = window.gameSettings.difficulty || 'normal';
  if (toggleZones) toggleZones.checked = !!window.gameSettings.showZones;

  // Change handlers (guarded so missing helpers won't break)
  if (difficultySelect) {
    difficultySelect.addEventListener('change', (e) => {
      window.gameSettings.difficulty = e.target.value;
      if (typeof saveSettings === 'function') try { saveSettings(); } catch(_) {}
      if (typeof showTemporaryText === 'function') showTemporaryText(`Difficulty set to ${window.gameSettings.difficulty}`);
      else console.log(`Difficulty set to ${window.gameSettings.difficulty}`);
    });
  } else {
    console.warn('Settings wiring: no #difficulty-select found');
  }

  if (toggleZones) {
    toggleZones.addEventListener('change', (e) => {
      window.gameSettings.showZones = !!e.target.checked;
      if (typeof saveSettings === 'function') try { saveSettings(); } catch(_) {}
      if (typeof draw === 'function') draw();
      else console.log('Toggled showZones to', window.gameSettings.showZones);
    });
  } else {
    console.warn('Settings wiring: no #toggle-zones found');
  }
  
const mobileToggle = document.getElementById('toggle-mobile-mode');
const mobileControls = document.getElementById('mobile-controls');

mobileToggle.addEventListener('change', (e) => {
  if (e.target.checked) {
    mobileControls.style.display = 'block';
    canvas.blur(); // optionally remove keyboard focus when mobile controls active
  } else {
    mobileControls.style.display = 'none';
  }
});

  function movePlayer(dx, dy) {
  if (inBattle || isGameOver) return;
  let nextX = x + dx * speed;
  let nextY = y + dy * speed;

  // Insert your existing collision, door, battle zone, water, poison checks here
  // Example:
  if (isInWater(nextX, nextY) && (inventory.get('raft') || 0) <= 0) {
    showTemporaryText("You need a raft to cross water!");
    return;
  }
  if (isInPoison(nextX, nextY) && (inventory.get('gas_mask') || 0) <= 0) {
    showTemporaryText("You need a gas mask to cross poison!");
    return;
  }
  if (!isCollidingWithWall(nextX, nextY)) {
    const door = checkDoorCollision(nextX, nextY);
    if (door) {
      loadLevel(door.destLevel, door.destX, door.destY);
      return;
    }
    const battleZone = findBattleZone(nextX, nextY);
    if (battleZone) {
      initiateBattle('battleZone', battleZone);
      return;
    }
    x = nextX;
    y = nextY;

    const dialogZone = findDialogZone(nextX, nextY);
    if (dialogZone && dialogZone.autoShow) {
      showDialog(dialogZone.text, dialogZone.id, { style: dialogZone.style || 'dialog', speaker: dialogZone.speaker || null });
      return;
    }
  }
  draw();
}

document.getElementById('btn-up').addEventListener('click', () => movePlayer(0, -1));
document.getElementById('btn-down').addEventListener('click', () => movePlayer(0, 1));
document.getElementById('btn-left').addEventListener('click', () => movePlayer(-1, 0));
document.getElementById('btn-right').addEventListener('click', () => movePlayer(1, 0));

document.getElementById('btn-interact').addEventListener('click', () => {
  if (inBattle || isGameOver) return;
  // Simulate pressing 'x' key interaction:
  const interactableObject =
    checkInteraction(x - 16, y) ||
    checkInteraction(x + 16, y) ||
    checkInteraction(x, y - 16) ||
    checkInteraction(x, y + 16) ||
    checkInteraction(x, y);
  if (interactableObject) handleInteraction(interactableObject);
});
  // Save/load slot buttons (guarded)
  function bindSlot(id, fn) {
    const el = document.getElementById(id);
    if (!el) { console.warn(`Settings wiring: missing ${id}`); return; }
    el.addEventListener('click', fn);
  }

  bindSlot('save-slot-1', () => { if (typeof saveToSlot === 'function') saveToSlot(1); else console.warn('saveToSlot not defined'); });
  bindSlot('save-slot-2', () => { if (typeof saveToSlot === 'function') saveToSlot(2); else console.warn('saveToSlot not defined'); });
  bindSlot('save-slot-3', () => { if (typeof saveToSlot === 'function') saveToSlot(3); else console.warn('saveToSlot not defined'); });

  bindSlot('load-slot-1', () => { if (typeof loadFromSlot === 'function') loadFromSlot(1); else if (typeof loadSlot === 'function') loadSlot(1); else console.warn('loadFromSlot not defined'); });
  bindSlot('load-slot-2', () => { if (typeof loadFromSlot === 'function') loadFromSlot(2); else console.warn('loadFromSlot not defined'); });
  bindSlot('load-slot-3', () => { if (typeof loadFromSlot === 'function') loadFromSlot(3); else console.warn('loadFromSlot not defined'); });

  console.log('Settings wiring installed');
});


const achievementsButton = document.getElementById('achievements-button');
const achievementsPopup = document.getElementById('achievements-popup');

achievementsButton.addEventListener('click', () => {
  if (achievementsPopup.style.display === 'none') {
    drawAchievementsUI();
    achievementsPopup.style.display = 'block';
  } else {
    achievementsPopup.style.display = 'none';
  }
});
  
// Attack buttons event listeners
document.getElementById('attack-button').addEventListener('click', () => {
  if (!inBattle || !activeEnemies.length) return;
  const targetEnemy = activeEnemies[selectedEnemyIndex];
  if (!targetEnemy) return;

  if (targetEnemy.shieldActive) {
    showTemporaryText(`${targetEnemy.name}'s shield blocks your attack!`);
  } else {
    // Always deal damage regardless of poison status
    targetEnemy.currentHp -= playerStats.damage;
    if (targetEnemy.currentHp < 0) targetEnemy.currentHp = 0;
  }
  if (targetEnemy.currentHp === 0) {
    handleEnemyDeath(targetEnemy);
    // adjust selected index if needed
    if (selectedEnemyIndex >= activeEnemies.length) selectedEnemyIndex = Math.max(0, activeEnemies.length - 1);
    return;
  }

  // Remove dead enemies
  activeEnemies = activeEnemies.filter(enemy => enemy.currentHp > 0);

  // If no enemies left, end battle
  if (activeEnemies.length === 0) {
    endBattle('win');
    return;
  }

  drawBattleUI();
  drawPartyStatus();
  drawPlayerBattleStatus();
});

document.getElementById('special-attack-button-1').addEventListener('click', () => {
  const staminaCost = 100;
  if (!inBattle || !activeEnemies.length || playerStats.currentStamina < staminaCost) {
    showTemporaryText("Not enough stamina!");
    return;
  }
  updateStamina(playerStats.currentStamina - staminaCost);
  const targetEnemy = activeEnemies[selectedEnemyIndex];
  if (!targetEnemy) return;
  targetEnemy.currentHp -= (playerStats.damage * 10);
  if (targetEnemy.currentHp < 0) targetEnemy.currentHp = 0;
  if (targetEnemy.currentHp === 0) {
    handleEnemyDeath(targetEnemy);
    // adjust selected index if needed
    if (selectedEnemyIndex >= activeEnemies.length) selectedEnemyIndex = Math.max(0, activeEnemies.length - 1);
    return;
  }
  let remainingEnemies = activeEnemies.filter(enemy => enemy.currentHp > 0);
  if (remainingEnemies.length === 0) {
    endBattle('win');
    return;
  }
  activeEnemies = remainingEnemies;
  if (selectedEnemyIndex >= activeEnemies.length) selectedEnemyIndex = 0;
  drawBattleUI();
  drawPartyStatus();
  drawPlayerBattleStatus();
});

document.getElementById('special-attack-button-2').addEventListener('click', () => {
  const staminaCost = 200;
  if (!inBattle || playerStats.currentStamina < staminaCost) {
    showTemporaryText("Not enough stamina!");
    return;
  }
  updateStamina(playerStats.currentStamina - staminaCost);

  if (equippedWeapon === "virus") {
    // Virus weapon special attack: example - hits all enemies with  damage + poison effect
    activeEnemies.forEach(enemy => {
      enemy.currentHp -= playerStats.damage * 30;
      if (enemy.currentHp < 0) enemy.currentHp = 0;

      // Apply poison if not boss
      if (!enemy.isBoss && !enemy.poisoned) {
        enemy.poisoned = false;
        // Start poison interval here similar to poison vial effect
        // (You can reuse your poison vial code here)
      }
    });
  } else {
    // Default special attack: damage all enemies with 20x damage (as your current code)
    activeEnemies.forEach(enemy => {
      enemy.currentHp -= playerStats.damage * 20;
      if (enemy.currentHp < 0) enemy.currentHp = 0;
    });
  }

  // Remove dead enemies
  activeEnemies = activeEnemies.filter(enemy => enemy.currentHp > 0);

  if (activeEnemies.length === 0) {
    endBattle('win');
    return;
  }
  if (selectedEnemyIndex >= activeEnemies.length) selectedEnemyIndex = 0;
  drawBattleUI();
  drawPartyStatus();
  drawPlayerBattleStatus();
});

// Handle enemy selection click
document.getElementById('enemy-display').addEventListener('click', (event) => {
  const button = event.target.closest('.enemy-target');
  if (button) {
    selectedEnemyIndex = parseInt(button.dataset.enemyIndex);
    drawBattleUI();
  }
});

// Stats popup toggle
document.getElementById('stats-button').addEventListener('click', () => {
  if (statsPopup.style.display === 'none') {
    updateStatsPopup();
    statsPopup.style.display = 'block';
  } else {
    statsPopup.style.display = 'none';
  }
});

updateHp(playerStats.currentHp);

// Inventory button in battle toggle
document.getElementById('inventory-battle-button').addEventListener('click', () => {
  const inventoryPopupBattle = document.getElementById('inventory-battle-popup');
  if (inventoryPopupBattle.style.display === 'none') {
    drawInventoryBattlePopup();
    inventoryPopupBattle.style.display = 'block';
  } else {
    inventoryPopupBattle.style.display = 'none';
  }
});

  const dialogNextBtn = document.getElementById('dialog-next');
if (dialogNextBtn) {
  dialogNextBtn.addEventListener('click', () => {
    const overlay = document.getElementById('dialog-overlay');
    const textDiv = document.getElementById('dialog-text');
    const box = document.getElementById('dialog-box');

    // 1) Battle dialog queue takes priority
    if (Array.isArray(_battleDialogQueue) && _battleDialogQueue.length > 0) {
      const line = _battleDialogQueue.shift();
      applyDialogStyle(box, line.style || 'dialog');
      if (line.speaker) textDiv.innerHTML = `<strong>${line.speaker}</strong>\n\n${line.text}`;
      else textDiv.textContent = line.text;
      return;
    }

    // 2) Normal dialog queue (try common variable names safely)
    // Your project used several names in different places; check them in order.
    const normalQueue = (typeof dialogQueue !== 'undefined' && Array.isArray(dialogQueue)) ? dialogQueue
                      : (typeof _dialogQueue !== 'undefined' && Array.isArray(_dialogQueue)) ? _dialogQueue
                      : (typeof _dialogQueue_ !== 'undefined' && Array.isArray(_dialogQueue_)) ? _dialogQueue_
                      : null;

    if (normalQueue && normalQueue.length > 0) {
      const line = normalQueue.shift();
      applyDialogStyle(box, line.style || 'dialog');
      if (line.speaker) textDiv.innerHTML = `<strong>${line.speaker}</strong>\n\n${line.text}`;
      else textDiv.textContent = line.text;
      return;
    }

    // 3) Nothing left to show -> close overlay and mark shown dialog id if present
    const id = overlay._markId;
    overlay._markId = null;
    overlay.style.display = 'none';
    draw();
    if (id) shownDialogs.add(id);

    // 4) If we were in battle-dialog mode, resume battle timers and refresh UI
    if (inBattle) {
      resumeBattleTimersAfterDialog();
      drawBattleUI();
      drawPlayerBattleStatus();
      if (typeof drawPartyStatus === 'function') drawPartyStatus();
    }
  });
}


document.addEventListener('keydown', function(e) {
  if (isGameOver && e.key.toLowerCase() === 'r') {
    location.reload();
  }
});

function loadLevel(index, newX = x, newY = y) {
  currentLevelIndex = index;
  currentLevel = levels[currentLevelIndex];

  bgImg = new Image();
  bgImg.onload = () => draw();
  bgImg.src = currentLevel.bgSrc;

  x = newX;
  y = newY;

  draw();
}

function isInZone(zones, px, py) {
  if (!zones) return false;
  const hitboxX = px + hitboxOffsetX;
  const hitboxY = py + hitboxOffsetY;
  for (const zone of zones) {
    if (
      hitboxX < zone.x + zone.width &&
      hitboxX + hitboxWidth > zone.x &&
      hitboxY < zone.y + zone.height &&
      hitboxY + hitboxHeight > zone.y
    ) {
      return true;
    }
  }
  return false;
}

function isInWater(px, py) {
  return isInZone(currentLevel.waterZones, px, py);
}

function isInPoison(px, py) {
  return isInZone(currentLevel.poisonZones, px, py);
}
function isInIce(px, py) {
  if (!currentLevel.iceZones) return false;
  const hitboxX = px + hitboxOffsetX;
  const hitboxY = py + hitboxOffsetY;
  for (const zone of currentLevel.iceZones) {
    if (
      hitboxX < zone.x + zone.width &&
      hitboxX + hitboxWidth > zone.x &&
      hitboxY < zone.y + zone.height &&
      hitboxY + hitboxHeight > zone.y
    ) return true;
  }
  return false;
}

// Wall collision detection
function isCollidingWithWall(newX, newY) {
  const newHitboxX = newX + hitboxOffsetX;
  const newHitboxY = newY + hitboxOffsetY;
  for (const wall of currentLevel.walls) {
    if (
      newHitboxX < wall.x + wall.width &&
      newHitboxX + hitboxWidth > wall.x &&
      newHitboxY < wall.y + wall.height &&
      newHitboxY + hitboxHeight > wall.y
    ) {
      return true;
    }
  }
  return false;
}

  function startSlide(dx, dy) {
  if ((inventory.get('ice_boots') || 0) > 0) return;
  sliding = true;
  slidingDirection = { dx: Math.sign(dx), dy: Math.sign(dy) };
  if (slidingIntervalId) { clearInterval(slidingIntervalId); slidingIntervalId = null; }

  slidingIntervalId = setInterval(() => {
    if (!sliding) { stopSlide(); return; }

    const nextX = x + slidingDirection.dx * speed;
    const nextY = y + slidingDirection.dy * speed;

    if (isCollidingWithWall(nextX, nextY)) { stopSlide(); return; }

    const door = checkDoorCollision(nextX, nextY);
    if (door) { loadLevel(door.destLevel, door.destX, door.destY); stopSlide(); return; }

    const battleZone = findBattleZone(nextX, nextY);
    if (battleZone) { x = nextX; y = nextY; initiateBattle('battleZone', battleZone); stopSlide(); return; }

    // commit move
    x = nextX;
    y = nextY;

    // stop sliding if we left ice
    if (!isInIce(x, y)) { stopSlide(); return; }

    draw();
  }, SLIDE_STEP_MS);
}

  function stopSlide() {
  if (!sliding) return;
  sliding = false;
  slidingDirection = { dx: 0, dy: 0 };
  if (slidingIntervalId) {
    clearInterval(slidingIntervalId);
    slidingIntervalId = null;
  }
  draw();
}
function tryEnterSlideIfNeeded(oldX, oldY, newX, newY, dx, dy) {
  if ((inventory.get('ice_boots') || 0) > 0) return false;
  const wasInIce = isInIce(oldX, oldY);
  const nowInIce = isInIce(newX, newY);
  if (!wasInIce && nowInIce) {
    startSlide(dx, dy);
    return true;
  }
  return false;
}
  
// Door collision detection
function checkDoorCollision(newX, newY) {
  const newHitboxX = newX + hitboxOffsetX;
  const newHitboxY = newY + hitboxOffsetY;
  for (const door of currentLevel.doors) {
    if (
      newHitboxX < door.x + door.width &&
      newHitboxX + hitboxWidth > door.x &&
      newHitboxY < door.y + door.height &&
      newHitboxY + hitboxHeight > door.y
    ) {
      return door;
    }
  }
  return null;
}

// Draw game world and player
function draw() {
  if (inBattle || isGameOver) return;

  // clear canvas first
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  // draw background only when the image is ready
  if (bgImg && bgImg.complete && bgImg.naturalWidth > 0) {
    ctx.drawImage(bgImg, 0, 0, canvas.width, canvas.height);
  } else {
    // optional: fill a temporary background so canvas isn't visually stale
    ctx.fillStyle = "#737373";
    ctx.fillRect(0, 0, canvas.width, canvas.height);
  }
  ctx.fillStyle = "rgba(0,0,0,0.0)";
  for (const wall of currentLevel.walls) {
    ctx.fillRect(wall.x, wall.y, wall.width, wall.height);
  }
  if (currentLevel && currentLevel.battleZones) {
  currentLevel.battleZones.forEach(zone => {
    if (!zone.sprite) return;
    const sprite = zoneSprites[zone.sprite];
    if (!sprite) return;
    // determine dest rect: scale down or up as you like
    const spriteW = Math.min(zone.width, 100); // cap to avoid oversized sprites
    const spriteH = Math.min(zone.height, 100);
    const destX = zone.x + (zone.width - spriteW) / 2;
    const destY = zone.y + (zone.height - spriteH) / 2;
    if (sprite.complete && sprite.naturalWidth > 0) {
      ctx.drawImage(sprite, destX, destY, spriteW, spriteH);
    } else {
      // fallback visual while sprite loads
      ctx.fillStyle = 'rgba(255,0,0,0.0)';
      ctx.fillRect(destX, destY, spriteW, spriteH);
    }
  });
}
  if (useImage && img.complete && img.naturalWidth > 0) {
    ctx.drawImage(img, x, y, imageSize, imageSize);
  } else {
    ctx.fillStyle = "#0090ff";
    ctx.fillRect(x, y, imageSize, imageSize);
  }
  ctx.fillStyle = "rgba(0,0,0,0.0)";
  ctx.fillRect(x + hitboxOffsetX, y + hitboxOffsetY, hitboxWidth, hitboxHeight);
  // debug: draw player hitbox & label when zones are visible
if (window.gameSettings && window.gameSettings.showZones) {
  ctx.save();
  ctx.strokeStyle = 'yellow';
  ctx.lineWidth = 2;
  ctx.strokeRect(x + hitboxOffsetX + 0.5, y + hitboxOffsetY + 0.5, hitboxWidth, hitboxHeight);
}

  if (tempText) {
    ctx.fillStyle = "white";
    ctx.font = "12px 'Press Start 2P'";
    ctx.textAlign = "center";
    const maxWidth = canvas.width - 40;
    const lineHeight = 15;
    const startY = canvas.height - 100;
    wrapText(ctx, tempText, canvas.width / 2, startY, maxWidth, lineHeight);
  }
// in draw(), after drawing normal walls and interactables add:
if (gameSettings.showZones) {
  // walls outline
  ctx.save();
  ctx.strokeStyle = 'rgba(255,255,0,0.9)';
  ctx.lineWidth = 2;
  currentLevel.walls.forEach(w => {
    ctx.strokeRect(w.x + 0.5, w.y + 0.5, w.width, w.height);
  });
  // interactable boxes
  ctx.strokeStyle = 'rgba(0,255,255,0.9)';
  currentLevel.interactables.forEach(obj => {
    ctx.strokeRect(obj.x + 0.5, obj.y + 0.5, obj.width, obj.height);
  });
  // battle zones
  ctx.strokeStyle = 'rgba(255,0,0,0.9)';
  (currentLevel.battleZones || []).forEach(z => {
    ctx.strokeRect(z.x + 0.5, z.y + 0.5, z.width, z.height);
  });
  ctx.restore();
}

  currentLevel.interactables.forEach(obj => {
  if (obj.action === "pickup") {
    // Draw key items with their images
    let imgToDraw = null;
    if (obj.name === "hammer") imgToDraw = hammerImg;
    else if (obj.name === "keycard") imgToDraw = keycardImg;
    else if (obj.name === "gas_mask") imgToDraw = gasMaskImg;
    else if (obj.name === "laser_cutter") imgToDraw = laserCutterImg;
    else if (obj.name === "raft") imgToDraw = raftImg;
    else if (obj.name === "torch") imgToDraw = torchImg;
    else if (obj.name === "drill") imgToDraw = drillImg;

    if (imgToDraw && imgToDraw.complete) {
      ctx.drawImage(imgToDraw, obj.x, obj.y, obj.width, obj.height);
    } else {
      ctx.fillStyle = "#cc9900"; // fallback color
      ctx.fillRect(obj.x, obj.y, obj.width, obj.height);
    }
  } else if (obj.action === "break" && obj.name === "steel_block") {
    if (steelBlockImg.complete) {
      ctx.drawImage(steelBlockImg, obj.x, obj.y, obj.width, obj.height);
    } else {
      ctx.fillStyle = "#888"; // fallback gray
      ctx.fillRect(obj.x, obj.y, obj.width, obj.height);
    }
  }
});

  // Draw levers and controllers
(currentLevel.interactables || []).forEach(obj => {
  if (!obj) return;
  if (obj.action === 'lever') {
    if (typeof obj.currentState === 'undefined') obj.currentState = !!obj.initialState;
    const imgToDraw = obj.currentState ? leverOnImg : leverOffImg;
    if (imgToDraw && imgToDraw.complete && imgToDraw.naturalWidth > 0) {
      // draw using object rect if provided, otherwise use image size
      const w = obj.width || 16;
      const h = obj.height || 16;
      ctx.drawImage(imgToDraw, obj.x, obj.y, w, h);
    } else {
      ctx.fillStyle = obj.currentState ? '#00cc00' : '#663300';
      ctx.fillRect(obj.x, obj.y, obj.width || 12, obj.height || 12);
    }
  } else if (obj.action === 'lever_controller') {
    // simple controller visual
    ctx.fillStyle = '#8844ff';
    ctx.fillRect(obj.x, obj.y, obj.width || 12, obj.height || 12);
    ctx.fillStyle = 'white';
    ctx.font = '10px "Press Start 2P"';
    ctx.textAlign = 'center';
    ctx.fillText('C', (obj.x + (obj.width || 12) / 2), obj.y + (obj.height || 12) / 1.4);
  }
});

currentLevel.interactables.forEach(obj => {
  if (obj.action === "chest") {
    if (obj.opened) {
      // open chest sprite (or fallback)
      if (openChestImg && openChestImg.complete) ctx.drawImage(openChestImg, obj.x, obj.y, obj.width, obj.height);
      else { ctx.fillStyle = "#775533"; ctx.fillRect(obj.x, obj.y, obj.width, obj.height); }
    } else {
      // closed chest sprite (or fallback)
      if (closedChestImg && closedChestImg.complete) ctx.drawImage(closedChestImg, obj.x, obj.y, obj.width, obj.height);
      else { ctx.fillStyle = "#aa7722"; ctx.fillRect(obj.x, obj.y, obj.width, obj.height); }
    }
  }
});
  if (currentLevel.waterZones) {
  ctx.fillStyle = "rgba(0, 0, 255, 0.9)";
  currentLevel.waterZones.forEach(zone => {
    ctx.fillRect(zone.x, zone.y, zone.width, zone.height);
  });
}
  if (currentLevel.iceZones) {
  ctx.fillStyle = "rgba(0, 255, 255, 0.3)";
  currentLevel.iceZones.forEach(zone => {
    ctx.fillRect(zone.x, zone.y, zone.width, zone.height);
  });
}
function isInDarkZone(px, py) {
  if (!currentLevel.darkZones) return false;
  const hitboxX = px + hitboxOffsetX;
  const hitboxY = py + hitboxOffsetY;
  for (const zone of currentLevel.darkZones) {
    if (
      hitboxX < zone.x + zone.width &&
      hitboxX + hitboxWidth > zone.x &&
      hitboxY < zone.y + zone.height &&
      hitboxY + hitboxHeight > zone.y
    ) {
      return true;
    }
  }
  return false;
}
// Draw poison zones
if (currentLevel.poisonZones) {
  ctx.fillStyle = "rgba(0, 255, 0, 0.4)"; // semi-transparent green
  currentLevel.poisonZones.forEach(zone => {
    ctx.fillRect(zone.x, zone.y, zone.width, zone.height);
  });
}
  // After all normal drawing is done
if (isInDarkZone(x, y) && (inventory.get("torch") || 0) <= 0) {
  // Draw solid black overlay to simulate darkness
  ctx.fillStyle = "black";
  ctx.fillRect(0, 0, canvas.width, canvas.height);
}

  // draw smashable stones (name matches what you added earlier)
  currentLevel.interactables.forEach(obj => {
    if (obj.name === "big_stone" || obj.name === "bigStone") {
      if (stoneImg.complete) ctx.drawImage(stoneImg, obj.x, obj.y, obj.width, obj.height);
      else { ctx.fillStyle = "#888"; ctx.fillRect(obj.x, obj.y, obj.width, obj.height); }
    }
  });
}

  // === Settings storage and defaults ===
const SETTINGS_KEY = '8bitsAdventureSettings';
const SAVE_SLOT_PREFIX = '8bitsAdventureSave_slot_'; // followed by 1,2,3

const defaultSettings = {
  difficulty: 'normal', // normal | hard | ultimate
  showZones: false // false by default
};

let gameSettings = Object.assign({}, defaultSettings);

// load settings on start
function loadSettings() {
  try {
    const raw = localStorage.getItem(SETTINGS_KEY);
    if (raw) {
      const parsed = JSON.parse(raw);
      Object.assign(gameSettings, parsed);
    }
  } catch (e) {
    console.error('Failed to load settings', e);
  }
  // apply UI initial values
  const sel = document.getElementById('difficulty-select');
  const chk = document.getElementById('toggle-zones');
  if (sel) sel.value = gameSettings.difficulty || 'normal';
  if (chk) chk.checked = !!gameSettings.showZones;
}
function saveSettings() {
  try {
    localStorage.setItem(SETTINGS_KEY, JSON.stringify(gameSettings));
  } catch (e) {
    console.error('Failed to save settings', e);
  }
}

// === Save slot helpers ===
function saveToSlot(slotNumber) {
  const key = SAVE_SLOT_PREFIX + slotNumber;
  const allInteractables = levels.map(level => (level.interactables || []).map(obj => ({ ...obj })));
  const saveData = {
    playerStats,
    inventory: Array.from(inventory.entries()),
    currentLevelIndex,
    playerPosition: { x, y },
    allInteractables,
    shownDialogs: Array.from(shownDialogs),
    unlockedAllies: Array.from(unlockedAllies),
    settings: gameSettings
  };
  localStorage.setItem(key, JSON.stringify(saveData));
  showTemporaryText(`Saved to slot ${slotNumber}`);
}
function loadFromSlot(slotNumber) {
  const key = SAVE_SLOT_PREFIX + slotNumber;
  const raw = localStorage.getItem(key);
  if (!raw) {
    showTemporaryText(`No save in slot ${slotNumber}`);
    return;
  }
  try {
    const saveData = JSON.parse(raw);
    Object.assign(playerStats, saveData.playerStats);
    inventory.clear();
    saveData.inventory.forEach(([k, v]) => inventory.set(k, v));
    if (Array.isArray(saveData.allInteractables)) {
      saveData.allInteractables.forEach((arr, idx) => {
        if (levels[idx]) levels[idx].interactables = arr.map(o => ({ ...o }));
      });
    }
    shownDialogs = new Set(saveData.shownDialogs || []);
    unlockedAllies = new Set(saveData.unlockedAllies || []);
    // restore settings from save if present
    if (saveData.settings) {
      Object.assign(gameSettings, saveData.settings);
      const sel = document.getElementById('difficulty-select');
      const chk = document.getElementById('toggle-zones');
      if (sel) sel.value = gameSettings.difficulty;
      if (chk) chk.checked = !!gameSettings.showZones;
    }
    loadLevel(saveData.currentLevelIndex, saveData.playerPosition.x, saveData.playerPosition.y);
    drawPartyList();
    drawPartyStatus();
    updateHp(playerStats.currentHp);
    updateStatsPopup();
    showTemporaryText(`Loaded slot ${slotNumber}`);
  } catch (e) {
    console.error('Failed to load slot', e);
    showTemporaryText('Failed to load save');
  }
}

// === Hook up settings UI buttons ===
document.getElementById('save-slot-1').addEventListener('click', () => saveToSlot(1));
document.getElementById('save-slot-2').addEventListener('click', () => saveToSlot(2));
document.getElementById('save-slot-3').addEventListener('click', () => saveToSlot(3));
document.getElementById('load-slot-1').addEventListener('click', () => loadFromSlot(1));
document.getElementById('load-slot-2').addEventListener('click', () => loadFromSlot(2));
document.getElementById('load-slot-3').addEventListener('click', () => loadFromSlot(3));

// difficulty selector
document.getElementById('difficulty-select').addEventListener('change', (e) => {
  gameSettings.difficulty = e.target.value;
  saveSettings();
  showTemporaryText(`Difficulty set to ${gameSettings.difficulty}`);
});

// toggle zones
document.getElementById('toggle-zones').addEventListener('change', (e) => {
  gameSettings.showZones = !!e.target.checked;
  saveSettings();
  draw(); // redraw overlays
});

// initialize settings on load
loadSettings();

// Save game state to localStorage
function saveGame() {
  // Save interactables for all levels
  const allInteractables = levels.map(level => {
    // Save a deep copy of interactables array for each level
    return level.interactables.map(obj => ({ ...obj }));
  });

  const saveData = {
  playerStats,
  inventory: Array.from(inventory.entries()),
  currentLevelIndex,
  playerPosition: { x, y },
  allInteractables,
  shownDialogs: Array.from(shownDialogs),
  alliesData: alliesData.filter(a => unlockedAllies.has(a.id)).map(a => ({
    id: a.id,
    level: a.level,
    xp: a.xp,
    xpToNextLevel: a.xpToNextLevel,
    baseMaxHp: a.baseMaxHp,
    baseDamage: a.baseDamage
  })),
  unlockedAllies: Array.from(unlockedAllies),
  equippedAllyId,
  removedWallIds: Array.from(removedWallIds),
};
  saveData.achievements = achievements.map(a => ({
  id: a.id,
  progress: a.progress,
  unlocked: a.unlocked
}));
  localStorage.setItem('8bitsAdventureSave', JSON.stringify(saveData));
  showTemporaryText('Game saved!');
  console.log('Game saved:', saveData);
}

// Load game state from localStorage
function loadGame() {
  const saved = localStorage.getItem('8bitsAdventureSave');
  if (!saved) {
    showTemporaryText('No saved game found.');
    console.log('No saved game found.');
    return;
  }

  try {
    const saveData = JSON.parse(saved);
    Object.assign(playerStats, saveData.playerStats);
    inventory.clear();
    saveData.inventory.forEach(([key, value]) => inventory.set(key, value));

    // Restore interactables for all levels
    if (Array.isArray(saveData.allInteractables)) {
  saveData.allInteractables.forEach((interactablesArr, index) => {
    if (levels[index]) {
      levels[index].interactables = interactablesArr.map(o => ({ ...o }));
    }
  });
}
//rebuildWalls();

    loadLevel(saveData.currentLevelIndex, saveData.playerPosition.x, saveData.playerPosition.y);
    
    if (saveData.removedWallIds) {
  removedWallIds = new Set(saveData.removedWallIds);
}

// Reset walls to original full set from baseWalls or initial levels
levels.forEach(level => {
  level.walls = level.walls.map(w => ({ ...w })); // shallow copy to reset if needed
  level.walls = level.walls.filter(wall => !removedWallIds.has(wall.id));
});
    if (Array.isArray(saveData.shownDialogs)) {
      shownDialogs = new Set(saveData.shownDialogs);
    }
    if (Array.isArray(saveData.alliesData)) {
  saveData.alliesData.forEach(savedAlly => {
    const baseAlly = alliesData.find(a => a.id === savedAlly.id);
    if (baseAlly) {
      baseAlly.level = savedAlly.level;
      baseAlly.xp = savedAlly.xp;
      baseAlly.xpToNextLevel = savedAlly.xpToNextLevel;
      baseAlly.baseMaxHp = savedAlly.baseMaxHp;
      baseAlly.baseDamage = savedAlly.baseDamage;
    }
  });
}
unlockedAllies = new Set(saveData.unlockedAllies || []);
equippedAllyId = saveData.equippedAllyId || null;

// If equipped, restore activeAlly stats with updated data
if (equippedAllyId && unlockedAllies.has(equippedAllyId)) {
  const allyBase = alliesData.find(a => a.id === equippedAllyId);
  activeAlly = {
    id: allyBase.id,
    name: allyBase.name,
    maxHp: allyBase.baseMaxHp,
    currentHp: allyBase.baseMaxHp,
    damage: allyBase.baseDamage,
    attackIntervalMs: allyBase.attackIntervalMs,
    level: allyBase.level,
    xp: allyBase.xp,
    xpToNextLevel: allyBase.xpToNextLevel,
    attackTimerId: null
  };
} else {
  activeAlly = null;
}
    if (Array.isArray(saveData.achievements)) {
  saveData.achievements.forEach(savedAch => {
    const ach = achievementsMap[savedAch.id];
    if (ach) {
      ach.progress = savedAch.progress || 0;
      ach.unlocked = !!savedAch.unlocked;
    }
  });
}
drawAchievementsUI();


    updateHp(playerStats.currentHp);
    updateStatsPopup();
    showTemporaryText('Game loaded!');
    console.log('Game loaded:', saveData);

  } catch (e) {
    console.error('Failed to load save:', e);
    showTemporaryText('Failed to load save.');
  }
}

  function rebuildWalls() {
  levels.forEach(level => {
    if (!level.walls || !level.interactables) return;

    // Collect bounding boxes of current interactables that block movement
    const interactableRects = level.interactables.map(obj => ({
      x: obj.x,
      y: obj.y,
      width: obj.width,
      height: obj.height
    }));

    // Remove walls that overlap any interactable rect (obstacles)
    level.walls = level.walls.filter(wall => {
      return !interactableRects.some(rect => (
        wall.x === rect.x &&
        wall.y === rect.y &&
        wall.width === rect.width &&
        wall.height === rect.height
      ));
    });
  });
}

// Create Save and Load buttons after DOM is ready (script at bottom so safe)
const gameHud = document.getElementById('game-hud');
if (gameHud) {
  const saveButton = document.createElement('button');
  saveButton.textContent = 'Save Game';
  saveButton.style.fontFamily = "'Press Start 2P', sans-serif";
  saveButton.style.margin = '0 10px';
  saveButton.onclick = saveGame;
  gameHud.appendChild(saveButton);

  const loadButton = document.createElement('button');
  loadButton.textContent = 'Load Game';
  loadButton.style.fontFamily = "'Press Start 2P', sans-serif";
  loadButton.style.margin = '0 10px';
  loadButton.onclick = loadGame;
  gameHud.appendChild(loadButton);
}
  
// Keyboard movement and interaction
canvas.addEventListener('keydown', function(e) {
  if (inBattle || isGameOver) return;

  // ignore input while sliding
  if (sliding) return;

  let nextX = x, nextY = y;
  const key = e.key.toLowerCase();

  // movement keys: prevent default for arrows/wasd
  if (['arrowup','arrowdown','arrowleft','arrowright','w','a','s','d'].includes(key)) {
    e.preventDefault();
  }

  // interaction key
  if (key === 'x') {
    e.preventDefault();
    const interactableObject =
      checkInteraction(x - 16, y) ||
      checkInteraction(x + 16, y) ||
      checkInteraction(x, y - 16) ||
      checkInteraction(x, y + 16) ||
      checkInteraction(x, y);
    if (interactableObject) handleInteraction(interactableObject);
    return;
  }

  // compute directional intent (dirX/dirY)
  let dirX = 0, dirY = 0;
  if (key === 'arrowleft' || key === 'a') dirX = -1;
  if (key === 'arrowright' || key === 'd') dirX = 1;
  if (key === 'arrowup' || key === 'w') dirY = -1;
  if (key === 'arrowdown' || key === 's') dirY = 1;

  // if no movement key, ignore
  if (dirX === 0 && dirY === 0) return;

  // compute the intended next position
  nextX = x + dirX * speed;
  nextY = y + dirY * speed;

  // Check water crossing
  if (isInWater(nextX, nextY) && (inventory.get('raft') || 0) <= 0) {
    showTemporaryText("You need a raft to cross water!");
    return;
  }

  // Check poison crossing
  if (isInPoison(nextX, nextY) && (inventory.get('gas_mask') || 0) <= 0) {
    showTemporaryText("You need a gas mask to cross poison!");
    return;
  }

  // Existing collision checks
  if (!isCollidingWithWall(nextX, nextY)) {
    const door = checkDoorCollision(nextX, nextY);
    if (door) {
      loadLevel(door.destLevel, door.destX, door.destY);
      return;
    }

    const battleZone = findBattleZone(nextX, nextY);
    if (battleZone) {
      initiateBattle('battleZone', battleZone);
      return;
    }

    // Attempt to start sliding if stepping onto ice
    const startedSlide = tryEnterSlideIfNeeded(x, y, nextX, nextY, dirX, dirY);

    // move player immediately for snappy feedback; startSlide will continue movement if it started
    x = nextX;
    y = nextY;

    if (startedSlide) {
      // slide started: skip normal post-move interactions (dialogs etc) and redraw
      if (typeof updateHp === 'function') updateHp(playerStats.currentHp);
      draw();
      return;
    }

    // dialog auto-trigger (autoShow only) - only when not sliding
    const dialogZone = findDialogZone(nextX, nextY);
    if (dialogZone && dialogZone.autoShow) {
      showDialog(dialogZone.text, dialogZone.id, { style: dialogZone.style || 'dialog', speaker: dialogZone.speaker || null });
      return;
    }
  }

  draw();
});
  </script>
</body>
</html>
