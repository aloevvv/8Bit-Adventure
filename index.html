<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>8Bitâ€™s Adventure</title>
  <link rel="icon" type="image/png" href="favicon.png" />
  <!-- Google Font: Press Start 2P -->
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet" />
  <style>
    body {
      background: #333;
      color: white;
      font-family: "Press Start 2P", sans-serif;
      text-align: center;
      margin: 0;
    }
    canvas {
      background: #737373;
      display: block;
      margin: 2em auto;
      border: 2px solid white;
    }
    #game-hud {
      position: fixed;
      bottom: 0;
      left: 0;
      width: 100%;
      background-color: #002591;
      color: white;
      display: flex;
      justify-content: space-around;
      align-items: center;
      padding: 10px;
      box-sizing: border-box;
      border-top: 2px solid black;
    }
    .hud-section {
      text-align: center;
      padding: 0 1em;
      user-select: none;
    }
    #player-status {
      display: flex;
      align-items: center;
      gap: 10px;
    }
    #hp-bar-container {
      width: 150px;
      height: 20px;
      background-color: #555;
      border: 1px solid white;
      position: relative;
    }
    #hp-bar {
      width: 100%;
      height: 100%;
      background-color: #00FF00;
      transition: width 0.5s linear;
    }
    #hp-text {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 0.8em;
      text-shadow: 1px 1px 2px black;
    }
    #battle-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.8);
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      display: none;
      z-index: 2000;
    }
    #enemy-display {
      background-color: #555;
      padding: 20px;
      border: 2px solid white;
      margin-bottom: 20px;
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      justify-content: center;
    }
    #enemy-display button {
      background-color: #333;
      color: white;
      border: 1px solid white;
      cursor: pointer;
      padding: 10px;
      font-family: "Press Start 2P", sans-serif;
      min-width: 100px;
      user-select: none;
    }
    #enemy-display button.selected {
      border: 2px solid yellow;
      background-color: #555;
    }
    #battle-controls button {
      font-family: "Press Start 2P", sans-serif;
      padding: 10px 20px;
      cursor: pointer;
      margin: 5px;
      user-select: none;
    }
    #player-battle-status {
      background-color: #002591;
      color: white;
      border: 2px solid black;
      padding: 10px;
      margin-top: 20px;
      width: 250px;
      text-align: left;
      user-select: none;
    }
    #player-battle-status p {
      margin: 0;
      font-size: 1em;
    }
    #player-battle-status .hp-bar-container {
      width: 100%;
      height: 15px;
      background-color: #555;
      border: 1px solid white;
      position: relative;
      margin: 8px 0;
    }
    #player-battle-status .hp-bar {
      height: 100%;
      background-color: #00FF00;
    }
    #stats {
      position: relative;
    }
    .stats-popup {
      position: absolute;
      bottom: 100%;
      left: 0;
      width: 200px;
      background-color: #002591;
      border: 2px solid black;
      padding: 10px;
      color: white;
      text-align: left;
      z-index: 1000;
      font-size: 0.75em;
      line-height: 1.2em;
    }
    .enemy-target.stunned {
      filter: grayscale(100%);
      opacity: 0.6;
      border-color: #888;
    }
    .enemy-target.shielded {
      box-shadow: 0 0 10px 10px rgba(0, 150, 255, 0.8);
      border-color: #0096ff;
    }
    .enemy-target.poisoned {
      box-shadow: 0 0 10px 10px rgba(0, 120, 0, 0.8);
      border-color: #007800;
    }
    #player-battle-status .hp-bar-container:last-of-type .hp-bar {
      background-color: #00FFFF;
    }
    #player-battle-status .hp-text {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 0.7em;
      text-shadow: 1px 1px 2px black;
    }
    /* Inventory styling */
    #inventory-list {
      display: flex;
      flex-direction: row;
      gap: 10px;
      flex-wrap: wrap;
      justify-content: flex-start;
      max-height: 250px;
      overflow-y: auto;
    }
    .inventory-item {
      display: flex;
      flex-direction: column;
      padding: 5px;
      border: 1px solid #555;
      border-radius: 3px;
      background-color: #55260e;
      color: white;
      min-width: 90px;
      user-select: none;
    }
    .inventory-item-general {
      padding: 5px;
      border-bottom: 1px solid #555;
    }
    .inventory-item-general:last-child {
      border-bottom: none;
    }
    .inventory-popup {
      position: absolute;
      bottom: 200px;
      right: 100px;
      width: 250px;
      max-height: 300px;
      background-color: #55260e;
      border: 2px solid black;
      color: white;
      padding: 10px;
      text-align: left;
      overflow-y: auto;
      z-index: 1000;
      font-size: 0.75em;
    }
    .item-use-button {
      font-family: "Press Start 2P", sans-serif;
      font-size: 0.7em;
      padding: 2px 5px;
      cursor: pointer;
      margin-top: 5px;
      align-self: flex-start;
      background-color: #333;
      border: 1px solid white;
      color: white;
      user-select: none;
    }
    .item-use-button:hover {
      background-color: #555;
    }
    #game-over-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.8);
      display: flex;
      justify-content: center;
      align-items: center;
      text-align: center;
      z-index: 2000;
      display: none; /* Hide initially */
    }
    .game-over-content {
      color: white;
      font-family: "Press Start 2P", sans-serif;
    }
    /* Save and Load buttons styling */
    #game-hud button {
      font-family: "Press Start 2P", sans-serif;
      padding: 8px 15px;
      cursor: pointer;
      background-color: #0040ff;
      border: 2px solid white;
      color: white;
      user-select: none;
      transition: background-color 0.3s ease;
    }
    #game-hud button:hover {
      background-color: #0060ff;
    }
    #general-inventory-list {
        max-height: 200px;
        overflow-y: auto;
    }
  </style>
</head>
<body>
  <canvas id="game" width="640" height="480" tabindex="0"></canvas>

  <div id="game-hud">
    <div class="hud-section" id="stats">
      <p id="stats-button">Stats</p>
      <div id="stats-popup" class="stats-popup" style="display: none;">
        <h4>Player Stats</h4>
        <p>Level: <span id="popup-level"></span></p>
        <p>XP: <span id="popup-xp"></span></p>
        <p>Damage: <span id="popup-damage"></span></p>
      </div>
    </div>
    <div class="hud-section" id="player-status">
      <p>Player</p>
      <div id="hp-bar-container">
        <div id="hp-bar"></div>
        <div id="hp-text">8/8</div>
      </div>
    </div>
    <div class="hud-section" id="inventory">
      <p id="inventory-button">Inventory</p>
    </div>
  </div>

  <div id="inventory-popup" class="stats-popup" style="display: none;">
    <h4>Inventory</h4>
    <div id="general-inventory-list"></div>
  </div>

  <div id="battle-overlay">
    <div id="enemy-display"></div>
    <div id="player-battle-status"></div>
    <div id="battle-controls">
      <button id="attack-button">Attack</button>
      <button id="special-attack-button-1">Extra Credits (100 STM)</button>
      <button id="special-attack-button-2">Plasma Blast (200 STM)</button>
      <button id="inventory-battle-button">Inventory</button>
    </div>
    <div id="inventory-battle-popup" class="inventory-popup" style="display: none;">
      <h4>Inventory</h4>
      <div id="inventory-list"></div>
    </div>
  </div>
  
  <div id="game-over-overlay">
    <div class="game-over-content">
      <h1>Game Over</h1>
      <p>Press 'R' to Restart</p>
    </div>
  </div>

  <script>

        // Focus canvas for keyboard input
    canvas.focus();
    canvas.addEventListener('click', () => {
      canvas.focus();
    });

    // Player and game variables
    let isGameOver = false;
    let x = 150, y = 50;
    const speed = 20;
    const imageSize = 60;
    const hitboxWidth = 30;
    const hitboxHeight = 30;
    const hitboxOffsetX = (imageSize - hitboxWidth) / 2;
    const hitboxOffsetY = (imageSize - hitboxHeight) / 2;
    const useImage = true;
    const img = new Image();
    img.src = '8bit.png';

    const hpBar = document.getElementById('hp-bar');
    const hpText = document.getElementById('hp-text');

    let selectedEnemyIndex = 0;
    let isPowered = false;
    let tempText = "";
    let tempTextTimeout = null;
    let defeatedZone = null;
    const ENEMY_ATTACK_DELAY = 2000;
    let lastFrameTime = performance.now();
    let enemyAttackTimers = new Map();

    let inventory = new Map();

    let extraLifeTimerId = null;
    let extraLifeEndTime = 0;

    let playerStats = {
      level: 1,
      currentHp: 8,
      maxHp: 8,
      damage: 2,
      xp: 0,
      xpToNextLevel: 10,
      currentStamina: 50,
      maxStamina: 200,
    };

    let inBattle = false;
    let battleState = {
        lastAttackTime: 0,
        lastStaminaTime: 0,
        poisonedEnemies: new Map(), // New map to track poison effects per enemy
    };

    const enemyTypes = {
      Dummy: { name: "Dummy", maxHp: 12, damage: 1, xpReward: 3, behavior: "normalAttack", baseDamage: 1 },
      Sniperbot: { name: "Sniper", maxHp: 20, damage: 1, xpReward: 5, behavior: "sniperAttack", baseDamage: 1 },
      BossBot: { name: "BossRobot", maxHp: 100, damage: 4, xpReward: 50, isBoss: true, behavior: "bossBehavior", baseDamage: 4 }
    };

    const levels = [
      {
        bgSrc: "arcadebg.png",
        walls: [
          { x: 0, y: 0, width: 640, height: 20 },
          { x: 0, y: 460, width: 640, height: 20 },
          { x: 290, y: 150, width: 32, height: 200 },
          { x: 290, y: 150, width: 220, height: 20 },
          { x: 500, y: 150, width: 20, height: 200 },
          { x: 0, y: 0, width: 20, height: 480 },
        ],
        doors: [
          { x: 375, y: 340, width: 85, height: 10, destLevel: 1, destX: 300, destY: 375 }
        ],
        battleZones: [
          { x: 100, y: 100, width: 50, height: 50, encounter: [{ type: "BossBot" }] },
          { x: 400, y: 250, width: 70, height: 70, encounter: [{ type: "Sniperbot" }, { type: "Sniperbot" }] }
        ],
        interactables: []
      },
      {
        bgSrc: "arcadeinside.png",
        walls: [
          { x: 0, y: 0, width: 640, height: 32 },
          { x: 0, y: 460, width: 640, height: 20 },
          { x: 608, y: 0, width: 32, height: 480 },
          { x: 0, y: 0, width: 50, height: 480 },
        ],
        doors: [
          { x: 300, y: 450, width: 40, height: 60, destLevel: 0, destX: 400, destY: 400 }
        ],
        battleZones: [],
        interactables: [
          { name: "power_box", x: 20, y: 260, width: 100, height: 100, action: "power_on" },
          { name: "arcade_machine", x: 340, y: 80, width: 100, height: 100, action: "start_battle", encounter: [{ type: "Dummy" }] }
        ]
      }
    ];

    let currentLevelIndex = 0;
    let currentLevel = levels[currentLevelIndex];
    const bgImg = new Image();
    bgImg.src = currentLevel.bgSrc;
    bgImg.onload = function() { draw(); };

    let activeEnemies = [];

        // === NEW CENTRAL GAME LOOP ===
    function gameLoop(currentTime) {
      if (isGameOver) {
        return;
      }
      
      if (inBattle) {
        const deltaTime = (currentTime - lastFrameTime) / 1000; // Time in seconds

        // --- Update Battle State ---
        battleState.lastStaminaTime += deltaTime;
        if (battleState.lastStaminaTime >= 0.1) {
            updateStamina(playerStats.currentStamina + (10 * battleState.lastStaminaTime));
            battleState.lastStaminaTime = 0;
        }

        battleState.lastAttackTime += deltaTime;
        if (battleState.lastAttackTime >= ENEMY_ATTACK_DELAY / 1000) {
            takeTurn();
            battleState.lastAttackTime = 0;
        }

        // --- Poison Effect ---
        battleState.poisonedEnemies.forEach((effect, enemyName) => {
            effect.timeRemaining -= deltaTime;
            if (effect.timeRemaining <= 0) {
                const enemy = activeEnemies.find(e => e.name === enemyName);
                if(enemy) enemy.poisoned = false;
                battleState.poisonedEnemies.delete(enemyName);
            } else {
                const enemy = activeEnemies.find(e => e.name === enemyName);
                if(enemy) {
                    enemy.currentHp -= (effect.damagePerTick * deltaTime);
                }
            }
        });

        // --- Check Game Over ---
        if (!canGoBelow1Hp() && playerStats.currentHp <= 1) {
            playerStats.currentHp = 1;
        } else if (playerStats.currentHp <= 0) {
            endBattle('lose');
            showGameOver();
            return; // Exit the loop
        }

        drawBattleUI();
        drawPlayerBattleStatus();
      }

      lastFrameTime = currentTime;
      requestAnimationFrame(gameLoop);
    }

    // === BATTLE LOGIC ===
    function normalAttack(enemy) {
      playerStats.currentHp -= enemy.damage;
      showTemporaryText(`${enemy.name} attacks you for ${enemy.damage} damage!`);
    }

    function sniperAttack(enemy) {
      const isCritical = Math.random() < 0.3;
      const damage = isCritical ? enemy.damage * 3 : enemy.damage;
      playerStats.currentHp -= damage;
      showTemporaryText(`${enemy.name} ${isCritical ? 'snipes critically' : 'attacks'} for ${damage} damage!`);
    }

    function bossBehavior(enemy) {
        const bossTimer = enemyAttackTimers.get(enemy.name);
        if (!bossTimer) return;

        // Shield logic
        if (enemy.shieldActive) {
            const timeSinceActivation = performance.now() - bossTimer.shieldActivatedAt;
            if (timeSinceActivation >= 2000) {
                enemy.shieldActive = false;
                bossTimer.shieldCooldownEnd = performance.now() + 3000;
                showTemporaryText(`${enemy.name}'s shield fades.`);
            }
        } else if (performance.now() >= bossTimer.shieldCooldownEnd) {
            enemy.shieldActive = true;
            bossTimer.shieldActivatedAt = performance.now();
            showTemporaryText(`${enemy.name} activates a shield!`);
        }

        // Rocket attack logic
        if (enemy.rocketActive && enemy.rocketTicksLeft > 0) {
            if (performance.now() - bossTimer.lastRocketTick >= 500) {
                const rocketTickDamage = Math.ceil(playerStats.maxHp * 0.05);
                playerStats.currentHp -= rocketTickDamage;
                enemy.rocketTicksLeft--;
                showTemporaryText(`${enemy.name}'s rocket hits you for ${rocketTickDamage} damage!`);
                bossTimer.lastRocketTick = performance.now();
            }
            if (enemy.rocketTicksLeft === 0) {
                enemy.rocketActive = false;
                showTemporaryText(`The rocket damage ends.`);
            }
        } else if (!enemy.rocketActive && !enemy.shieldActive && Math.random() < 0.25) {
            enemy.rocketActive = true;
            enemy.rocketTicksLeft = 4;
            bossTimer.lastRocketTick = performance.now();
            showTemporaryText(`${enemy.name} launches a rocket!`);
        }

        // Normal attack
        if (!enemy.shieldActive && !enemy.rocketActive) {
            playerStats.currentHp -= enemy.damage;
            showTemporaryText(`${enemy.name} attacks you for ${enemy.damage} damage!`);
        }
    }

    function takeTurn() {
      activeEnemies.forEach(enemy => {
        if (!enemy.stunned) {
          const behavior = enemyTypes[enemy.type]?.behavior || 'normalAttack';
          if (behavior === 'normalAttack') normalAttack(enemy);
          else if (behavior === 'sniperAttack') sniperAttack(enemy);
          else if (behavior === 'bossBehavior') bossBehavior(enemy);
        }
      });
    }

    function endBattle(outcome) {
      inBattle = false;
      document.getElementById('battle-overlay').style.display = 'none';
      
      if (outcome === 'win') {
        let totalXp = activeEnemies.reduce((sum, enemy) => sum + (enemy.xpReward || 0), 0);
        gainXP(totalXp);
        playerStats.currentHp = playerStats.maxHp;
        updateHp(playerStats.currentHp);
        if (defeatedZone) {
          removeZone(defeatedZone);
        }
      } else if (outcome === 'lose') {
        // No need to call loadLevel, showGameOver handles this.
      }

      activeEnemies = [];
      defeatedZone = null;
      document.getElementById('player-battle-status').innerHTML = '';
      draw();
    }

    function initiateBattle(zoneType, zoneObject) {
      inBattle = true;
      defeatedZone = { type: zoneType, object: zoneObject };

      let encounter = zoneObject.encounter;
      activeEnemies = encounter.map(enemyData => {
        const baseStats = enemyTypes[enemyData.type];
        const scaledStats = scaleEnemyStats(baseStats);
        return {
          ...enemyData,
          ...scaledStats,
          currentHp: scaledStats.maxHp,
          shieldActive: false,
          stunned: false,
          poisoned: false,
          rocketActive: false,
          rocketTicksLeft: 0,
        };
      });

      selectedEnemyIndex = 0;
      drawBattleUI();
      drawPlayerBattleStatus();
      requestAnimationFrame(gameLoop); // Start the new game loop
    }
    
    function checkInteraction(checkX, checkY) {
      if (currentLevel.interactables) {
        const hitboxX = checkX + hitboxOffsetX;
        const hitboxY = checkY + hitboxOffsetY;
        for (const object of currentLevel.interactables) {
          if (
            hitboxX < object.x + object.width &&
            hitboxX + hitboxWidth > object.x &&
            hitboxY < object.y + object.height &&
            hitboxY + hitboxHeight > object.y
          ) {
            return object;
          }
        }
      }
      return null;
    }

    function handleInteraction(object) {
      if (object.name === "power_box") {
        if (!isPowered) {
          isPowered = true;
          showTemporaryText("You pressed something on the box. The lights flicker on.");
          draw();
        } else {
          showTemporaryText("The power is already on.");
        }
      } else if (object.name === "arcade_machine") {
        if (isPowered) {
          initiateBattle('interactable', object);
        } else {
          showTemporaryText("The machine is turned off...");
        }
      }
    }

    // === ITEM USAGE LOGIC ===
    function useItem(itemName) {
        if (inventory.get(itemName) > 0) {
            const selectedEnemy = activeEnemies[selectedEnemyIndex];
            
            if (itemName === 'bandaid') {
                const healAmount = Math.ceil(playerStats.maxHp * 0.33);
                updateHp(playerStats.currentHp + healAmount);
                showTemporaryText(`Used a Bandage to heal for ${healAmount} HP!`);
            } else if (itemName === 'emp_grenade') {
                activeEnemies.forEach(enemy => {
                    if (!enemy.isBoss) {
                        enemy.stunned = true;
                        setTimeout(() => enemy.stunned = false, 4000);
                    }
                });
                showTemporaryText(`Used an EMP Grenade! Some enemies stunned for 4 seconds!`);
            } else if (itemName === 'poison_vial') {
                if(selectedEnemy && !selectedEnemy.isBoss) {
                    const poisonDamagePerTick = Math.ceil(5 * selectedEnemy.maxHp / 100);
                    const effectDuration = 3000;
                    selectedEnemy.poisoned = true;
                    battleState.poisonedEnemies.set(selectedEnemy.name, {
                        damagePerTick: poisonDamagePerTick / 1000, // damage per millisecond
                        timeRemaining: effectDuration / 1000,
                    });
                    showTemporaryText(`Used a Poison Vial on ${selectedEnemy.name}!`);
                } else {
                    showTemporaryText(`That enemy cannot be poisoned!`);
                    return;
                }
            } else if (itemName === 'extra_life') {
                extraLifeEndTime = performance.now() + 3000;
                showTemporaryText(`Used an Extra Life! You have 3 seconds of invincibility!`);
            }
            
            inventory.set(itemName, inventory.get(itemName) - 1);
            drawInventoryBattlePopup();
            drawBattleUI();
            drawPlayerBattleStatus();
        }
    }


    // Utility: text wrapping for canvas
    function wrapText(context, text, x, y, maxWidth, lineHeight) {
      let words = text.split(' ');
      let line = '';
      for (let n = 0; n < words.length; n++) {
        let testLine = line + words[n] + ' ';
        let metrics = context.measureText(testLine);
        let testWidth = metrics.width;
        if (testWidth > maxWidth && n > 0) {
          context.fillText(line, x, y);
          line = words[n] + ' ';
          y += lineHeight;
        } else {
          line = testLine;
        }
      }
      context.fillText(line, x, y);
    }

    // Show temporary text on screen for 3 seconds
    function showTemporaryText(message) {
      tempText = message;
      if (tempTextTimeout) clearTimeout(tempTextTimeout);
      tempTextTimeout = setTimeout(() => {
        tempText = "";
        draw();
      }, 3000);
    }

    // Check if player can go below 1 HP (used with extra life item)
    function canGoBelow1Hp() {
        return performance.now() >= extraLifeEndTime;
    }

    // Update stamina and clamp between 0 and max
    function updateStamina(newStamina) {
      if (newStamina < 0) newStamina = 0;
      if (newStamina > playerStats.maxStamina) newStamina = playerStats.maxStamina;
      playerStats.currentStamina = newStamina;
    }

    // Update HP and UI bar
    function updateHp(newHealth) {
      if (newHealth < 0) newHealth = 0;
      if (newHealth > playerStats.maxHp) newHealth = playerStats.maxHp;
      playerStats.currentHp = newHealth;
      const newWidth = (playerStats.currentHp / playerStats.maxHp) * 100;
      hpBar.style.width = `${newWidth}%`;
      hpText.textContent = `${playerStats.currentHp}/${playerStats.maxHp}`;
    }

    // Update stats popup UI
    function updateStatsPopup() {
      document.getElementById('popup-level').textContent = playerStats.level;
      document.getElementById('popup-xp').textContent = `${playerStats.xp} / ${playerStats.xpToNextLevel}`;
      document.getElementById('popup-damage').textContent = playerStats.damage;
    }

    // Level up player
    function levelUp() {
      playerStats.level++;
      playerStats.xp -= playerStats.xpToNextLevel;
      playerStats.xpToNextLevel = Math.floor(playerStats.xpToNextLevel * 1.5);
      playerStats.maxHp += Math.floor(2 + (playerStats.level / 2));
      playerStats.damage += Math.floor(1 + (playerStats.level / 6));
      playerStats.currentHp = playerStats.maxHp;
      updateHp(playerStats.currentHp);
      updateStatsPopup();
      showTemporaryText(`Leveled up to ${playerStats.level}!`);
    }

    // Gain XP and check level up
    function gainXP(amount) {
      playerStats.xp += amount;
      if (playerStats.xp >= playerStats.xpToNextLevel) {
        levelUp();
      }
      updateStatsPopup();
    }

    // Remove battle or interactable zone after clearing
    function removeZone(zone) {
      if (!zone) return;
      if (zone.type === 'battleZone') {
        const index = currentLevel.battleZones.indexOf(zone.object);
        if (index > -1) {
          currentLevel.battleZones.splice(index, 1);
        }
      } else if (zone.type === 'interactable') {
        const index = currentLevel.interactables.indexOf(zone.object);
        if (index > -1) {
          currentLevel.interactables.splice(index, 1);
        }
      }
    }

    // Scale enemy stats with level
    function scaleEnemyStats(baseStats) {
      return {
        ...baseStats,
        damage: baseStats.baseDamage + Math.floor(currentLevelIndex / 3),
        maxHp: baseStats.maxHp + Math.floor(currentLevelIndex / 2)
      };
    }

    // Draw general inventory
    function drawGeneralInventory() {
      const inventoryList = document.getElementById('general-inventory-list');
      inventoryList.innerHTML = '';
      if (inventory.size === 0 || Array.from(inventory.values()).every(q => q === 0)) {
        inventoryList.innerHTML = '<p>Your inventory is empty.</p>';
        return;
      }
      inventory.forEach((quantity, itemName) => {
        if (quantity > 0) {
          const p = document.createElement('p');
          p.textContent = `${itemName.replace(/_/g, ' ')}: ${quantity}`;
          inventoryList.appendChild(p);
        }
      });
    }

    // Find battle zone for given player position
    function findBattleZone(checkX, checkY) {
      const hitboxX = checkX + hitboxOffsetX;
      const hitboxY = checkY + hitboxOffsetY;
      if (!currentLevel.battleZones) return null;
      for (const zone of currentLevel.battleZones) {
        if (
          hitboxX < zone.x + zone.width &&
          hitboxX + hitboxWidth > zone.x &&
          hitboxY < zone.y + zone.height &&
          hitboxY + hitboxHeight > zone.y
        ) {
          return zone;
        }
      }
      return null;
    }
    
    // Show game over overlay
    function showGameOver() {
      isGameOver = true;
      document.getElementById('battle-overlay').style.display = 'none';
      document.getElementById('game-over-overlay').style.display = 'flex';
      cancelAnimationFrame(lastFrameTime); // Stop the main game loop
    }

    // Battle inventory popup draw
    function drawInventoryBattlePopup() {
      const inventoryList = document.getElementById('inventory-list');
      inventoryList.innerHTML = '';
      if (inventory.size === 0 || Array.from(inventory.values()).every(q => q === 0)) {
        inventoryList.innerHTML = '<p>Inventory is empty.</p>';
        return;
      }
      inventory.forEach((quantity, itemName) => {
        if (quantity > 0) {
          const itemElement = document.createElement('div');
          itemElement.className = 'inventory-item';
          itemElement.innerHTML = `<span>${itemName.replace(/_/g, ' ')} (${quantity})</span>`;

          const useButton = document.createElement('button');
          useButton.textContent = 'Use';
          useButton.className = 'item-use-button';
          useButton.onclick = () => useItem(itemName);

          itemElement.appendChild(useButton);
          inventoryList.appendChild(itemElement);
        }
      });
    }

    // Stats popup toggle
    document.getElementById('stats-button').addEventListener('click', () => {
        const inventoryPopup = document.getElementById('inventory-popup');
        const statsPopup = document.getElementById('stats-popup');

        if (statsPopup.style.display === 'none') {
            updateStatsPopup();
            statsPopup.style.display = 'block';
            inventoryPopup.style.display = 'none';
        } else {
            statsPopup.style.display = 'none';
        }
    });

    // Inventory button (HUD) toggle
    document.getElementById('inventory-button').addEventListener('click', () => {
        const inventoryPopup = document.getElementById('inventory-popup');
        const statsPopup = document.getElementById('stats-popup');

        if (inventoryPopup.style.display === 'none') {
            drawGeneralInventory();
            inventoryPopup.style.display = 'block';
            statsPopup.style.display = 'none';
        } else {
            inventoryPopup.style.display = 'none';
        }
    });

    // Handle enemy selection click
    document.getElementById('enemy-display').addEventListener('click', (event) => {
      const button = event.target.closest('.enemy-target');
      if (button) {
        selectedEnemyIndex = parseInt(button.dataset.enemyIndex);
        drawBattleUI();
      }
    });

    // Inventory button in battle toggle
    document.getElementById('inventory-battle-button').addEventListener('click', () => {
      const inventoryPopup = document.getElementById('inventory-battle-popup');
      if (inventoryPopup.style.display === 'none') {
        drawInventoryBattlePopup();
        inventoryPopup.style.display = 'block';
      } else {
        inventoryPopup.style.display = 'none';
      }
    });

    document.addEventListener('keydown', function(e) {
      if (isGameOver && e.key.toLowerCase() === 'r') {
        location.reload(); // Reloads the page to restart the game
      }
    });

    // Load level and update background
    function loadLevel(index, newX, newY) {
      currentLevelIndex = index;
      currentLevel = levels[currentLevelIndex];
      bgImg.src = currentLevel.bgSrc;
      x = newX;
      y = newY;
      draw();
    }

    // Wall collision detection
    function isCollidingWithWall(newX, newY) {
      const newHitboxX = newX + hitboxOffsetX;
      const newHitboxY = newY + hitboxOffsetY;
      for (const wall of currentLevel.walls) {
        if (
          newHitboxX < wall.x + wall.width &&
          newHitboxX + hitboxWidth > wall.x &&
          newHitboxY < wall.y + wall.height &&
          newHitboxY + hitboxHeight > wall.y
        ) {
          return true;
        }
      }
      return false;
    }

    // Door collision detection
    function checkDoorCollision(newX, newY) {
      const newHitboxX = newX + hitboxOffsetX;
      const newHitboxY = newY + hitboxOffsetY;
      for (const door of currentLevel.doors) {
        if (
          newHitboxX < door.x + door.width &&
          newHitboxX + hitboxWidth > door.x &&
          newHitboxY < door.y + door.height &&
          newHitboxY + hitboxHeight > door.y
        ) {
          return door;
        }
      }
      return null;
    }

    // Draw game world and player
    function draw() {
      if (inBattle || isGameOver) return;
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.drawImage(bgImg, 0, 0, canvas.width, canvas.height);
      ctx.fillStyle = "rgba(0,0,0,0.0)";
      for (const wall of currentLevel.walls) {
        ctx.fillRect(wall.x, wall.y, wall.width, wall.height);
      }
      if (useImage && img.complete && img.naturalWidth > 0) {
        ctx.drawImage(img, x, y, imageSize, imageSize);
      } else {
        ctx.fillStyle = "#0090ff";
        ctx.fillRect(x, y, imageSize, imageSize);
      }
      ctx.fillStyle = "rgba(0,0,0,0.0)";
      ctx.fillRect(x + hitboxOffsetX, y + hitboxOffsetY, hitboxWidth, hitboxHeight);

      if (tempText) {
        ctx.fillStyle = "white";
        ctx.font = "12px 'Press Start 2P'";
        ctx.textAlign = "center";
        const maxWidth = canvas.width - 40;
        const lineHeight = 15;
        const startY = canvas.height - 100;
        wrapText(ctx, tempText, canvas.width / 2, startY, maxWidth, lineHeight);
      }
    }

    // Save game state to localStorage
    function saveGame() {
      const saveData = {
        playerStats,
        inventory: Array.from(inventory.entries()),
        currentLevelIndex,
        playerPosition: { x, y },
      };
      localStorage.setItem('8bitsAdventureSave', JSON.stringify(saveData));
      showTemporaryText('Game saved!');
      console.log('Game saved:', saveData);
    }

    // Load game state from localStorage
    function loadGame() {
      const saved = localStorage.getItem('8bitsAdventureSave');
      if (!saved) {
        showTemporaryText('No saved game found.');
        console.log('No saved game found.');
        return;
      }
      try {
        const saveData = JSON.parse(saved);
        Object.assign(playerStats, saveData.playerStats);
        inventory.clear();
        saveData.inventory.forEach(([key, value]) => {
          inventory.set(key, value);
        });
        loadLevel(saveData.currentLevelIndex, saveData.playerPosition.x, saveData.playerPosition.y);
        updateHp(playerStats.currentHp);
        updateStatsPopup();
        showTemporaryText('Game loaded!');
        console.log('Game loaded:', saveData);
      } catch (e) {
        console.error('Failed to load save:', e);
        showTemporaryText('Failed to load save.');
      }
    }

    // Create Save and Load buttons after DOM is ready (script at bottom so safe)
    const gameHud = document.getElementById('game-hud');
    if (gameHud) {
      const saveButton = document.createElement('button');
      saveButton.textContent = 'Save Game';
      saveButton.style.fontFamily = '"Press Start 2P", sans-serif';
      saveButton.style.margin = '0 10px';
      saveButton.onclick = saveGame;
      gameHud.appendChild(saveButton);

      const loadButton = document.createElement('button');
      loadButton.textContent = 'Load Game';
      loadButton.style.fontFamily = '"Press Start 2P", sans-serif';
      loadButton.style.margin = '0 10px';
      loadButton.onclick = loadGame;
      gameHud.appendChild(loadButton);
    }

    // Keyboard movement and interaction
    canvas.addEventListener('keydown', function(e) {
      if (inBattle || isGameOver) return;
      if (!bgImg.complete || bgImg.naturalWidth === 0) return;
      let nextX = x, nextY = y;
      const key = e.key.toLowerCase();
      switch(key) {
        case 'arrowup':
        case 'arrowdown':
        case 'arrowleft':
        case 'arrowright':
        case 'w':
        case 'a':
        case 's':
        case 'd':
          e.preventDefault();
          break;
        case 'x':
          e.preventDefault();
          const interactableObject = checkInteraction(x, y);
          if (interactableObject) {
            handleInteraction(interactableObject);
          }
          return;
      }
      if (key === 'arrowleft' || key === 'a') nextX -= speed;
      if (key === 'arrowright' || key === 'd') nextX += speed;
      if (key === 'arrowup' || key === 'w') nextY -= speed;
      if (key === 'arrowdown' || key === 's') nextY += speed;
      if (!isCollidingWithWall(nextX, nextY)) {
        const door = checkDoorCollision(nextX, nextY);
        if (door) {
          loadLevel(door.destLevel, door.destX, door.destY);
          return;
        }
        const battleZone = findBattleZone(nextX, nextY);
        if (battleZone) {
          initiateBattle('battleZone', battleZone);
          return;
        }
        x = nextX;
        y = nextY;
      }
      draw();
    });
    </script>
</body>
</html>
