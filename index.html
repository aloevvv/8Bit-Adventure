<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>8Bitâ€™s Adventure</title>
  <link rel="icon" type="image/png" href="favicon.png" />
  <!-- Google Font: Press Start 2P -->
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet" />
  <style>
    body {
      background: #333;
      color: white;
      font-family: "Press Start 2P", sans-serif;
      text-align: center;
      margin: 0;
    }
    canvas {
      background: #737373;
      display: block;
      margin: 2em auto;
      border: 2px solid white;
    }
    #game-hud {
      position: fixed;
      bottom: 0;
      left: 0;
      width: 100%;
      background-color: #002591;
      color: white;
      display: flex;
      justify-content: space-around;
      align-items: center;
      padding: 10px;
      box-sizing: border-box;
      border-top: 2px solid black;
    }
    .hud-section {
      text-align: center;
      padding: 0 1em;
    }
    #player-status {
      display: flex;
      align-items: center;
      gap: 10px;
    }
    #hp-bar-container {
      width: 150px;
      height: 20px;
      background-color: #555;
      border: 1px solid white;
      position: relative;
    }
    #hp-bar {
      width: 100%;
      height: 100%;
      background-color: #00FF00;
      transition: width 0.5s linear;
    }
    #hp-text {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 0.8em;
      text-shadow: 1px 1px 2px black;
    }
    #battle-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.8);
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      display: none;
      z-index: 2000;
    }
    #enemy-display {
      background-color: #555;
      padding: 20px;
      border: 2px solid white;
      margin-bottom: 20px;
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      justify-content: center;
    }
    #enemy-display button {
      background-color: #333;
      color: white;
      border: 1px solid white;
      cursor: pointer;
      padding: 10px;
      font-family: "Press Start 2P", sans-serif;
      min-width: 100px;
      user-select: none;
    }
    #enemy-display button.selected {
      border: 2px solid yellow;
      background-color: #555;
    }
    #battle-controls button {
      font-family: "Press Start 2P", sans-serif;
      padding: 10px 20px;
      cursor: pointer;
      margin: 5px;
    }
    #player-battle-status {
      background-color: #002591;
      color: white;
      border: 2px solid black;
      padding: 10px;
      margin-top: 20px;
      width: 250px;
      text-align: left;
    }
    #player-battle-status p {
      margin: 0;
      font-size: 1em;
      user-select: none;
    }
    #player-battle-status .hp-bar-container {
      width: 100%;
      height: 15px;
      background-color: #555;
      border: 1px solid white;
      position: relative;
      margin: 8px 0;
    }
    #player-battle-status .hp-bar {
      height: 100%;
      background-color: #00FF00;
    }
    #stats {
      position: relative;
      user-select: none;
    }
    .stats-popup {
      position: absolute;
      bottom: 100%;
      left: 0;
      width: 200px;
      background-color: #002591;
      border: 2px solid black;
      padding: 10px;
      color: white;
      text-align: left;
      z-index: 1000;
      font-size: 0.75em;
      line-height: 1.2em;
    }
    .enemy-target.stunned {
  filter: grayscale(100%);
  opacity: 0.6;
}
    .enemy-target.shielded {
  box-shadow: 0 0 10px 10px rgba(0, 150, 255, 0.8);
  border-color: #0096ff;
}
    .enemy-target.poisoned {
  box-shadow: 0 0 10px 10px rgba(0, 120, 0, 0.8);
  border-color: ##007800;
}
    #player-battle-status .hp-bar-container:last-of-type .hp-bar {
      background-color: #00FFFF;
    }
    #player-battle-status .hp-text {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 0.7em;
      text-shadow: 1px 1px 2px black;
      user-select: none;
    }
    /* Inventory styling */
    #inventory-list {
      display: flex;
      flex-direction: row;
      gap: 10px;
      flex-wrap: wrap;
      justify-content: flex-start;
      max-height: 250px;
      overflow-y: auto;
    }
    .inventory-item {
      display: flex;
      flex-direction: column;
      padding: 5px;
      border: 1px solid #555;
      border-radius: 3px;
      background-color: #55260e;
      color: white;
      min-width: 90px;
      user-select: none;
    }
    .inventory-popup {
      display: none;
      position: absolute;
      bottom: 200px;
      right: 100px;
      width: 250px;
      max-height: 300px;
      background-color: #55260e;
      border: 2px solid black;
      color: white;
      padding: 10px;
      text-align: left;
      overflow-y: auto;
      z-index: 1000;
      font-size: 0.75em;
    }
    .item-use-button {
      font-family: "Press Start 2P", sans-serif;
      font-size: 0.7em;
      padding: 2px 5px;
      cursor: pointer;
      margin-top: 5px;
      align-self: flex-start;
      background-color: #333;
      border: 1px solid white;
      color: white;
      user-select: none;
    }
    .item-use-button:hover {
      background-color: #555;
    }
    #game-over-overlay {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-color: rgba(0, 0, 0, 0.8);
  display: flex;
  justify-content: center;
  align-items: center;
  text-align: center;
  z-index: 2000;
}

.game-over-content {
  color: white;
  font-family: "Press Start 2P", sans-serif;
}

    /* Save and Load buttons styling */
    #game-hud button {
      font-family: "Press Start 2P", sans-serif;
      padding: 8px 15px;
      cursor: pointer;
      background-color: #2b2b2b;
      border: 2px solid white;
      color: white;
      user-select: none;
      transition: background-color 0.3s ease;
    }
    #game-hud button:hover {
      background-color: #0060ff;
    }
  </style>
</head>
<body>
  <!-- Title screen overlay -->
<div id="title-screen" style="position:fixed;inset:0;display:flex;align-items:center;justify-content:center;background:#001a33;z-index:3000;">
  <div style="text-align:center;color:white;">
    <h1 style="font-family:'Press Start 2P',sans-serif;margin-bottom:20px;">8-Bit's Adventure</h1>
    <button id="play-button" style="font-family:'Press Start 2P',sans-serif;padding:12px 20px;font-size:14px;cursor:pointer;">Play</button>
  </div>
</div>

  <canvas id="game" width="640" height="480" tabindex="0"></canvas>

  <div id="game-hud">
  <div class="hud-section" id="stats">
    <p id="stats-button">Stats</p>
    <div id="stats-popup" class="stats-popup" style="display: none;">
      <h4>Player Stats</h4>
      <p>Level: <span id="popup-level"></span></p>
      <p>XP: <span id="popup-xp"></span></p>
      <p>Damage: <span id="popup-damage"></span></p>
    </div>
  </div>

  <div class="hud-section" id="player-status">
    <p> </p>
    <div id="hp-bar-container">
      <div id="hp-bar"></div>
      <div id="hp-text">8/8</div>
    </div>
  </div>

  <div class="hud-section" id="party">
    <p id="party-button">Party</p>
    <div id="party-popup" class="stats-popup" style="display: none;">
      <h4>Party</h4>
      <div id="party-list"></div>
      <div style="margin-top:8px;">
        <button id="equip-ally-button" class="item-use-button">Equip Selected Ally</button>
      </div>
    </div>
  </div>

  <div class="hud-section" id="inventory">
    <p id="inventory-button">Inventory</p>
    <div id="inventory-popup" class="stats-popup" style="display: none;">
      <h4>Inventory</h4>
      <div id="general-inventory-list"></div>
    </div>
  </div>
</div>
<div class="hud-section" id="settings">
  <p id="settings-button">Settings</p>
  <div id="settings-popup" class="stats-popup" style="display:none; width:280px;">
    <h4>Settings</h4>

    <div style="margin:8px 0;">
      <label style="display:block; font-size:10px;">Difficulty</label>
      <select id="difficulty-select" style="width:100%; font-family:'Press Start 2P',sans-serif;">
        <option value="normal">Normal</option>
        <option value="hard">Hard</option>
        <option value="ultimate">Ultimate</option>
      </select>
    </div>

    <div style="margin:8px 0;">
      <label style="display:block; font-size:10px;">Show Zones & Walls</label>
      <input id="toggle-zones" type="checkbox" /> Show debug outlines
    </div>

    <div style="margin:8px 0;">
      <label style="display:block; font-size:10px;">Save Slots</label>
      <div style="display:flex; gap:6px;">
        <button id="save-slot-1" class="item-use-button">Save 1</button>
        <button id="load-slot-1" class="item-use-button">Load 1</button>
      </div>
      <div style="display:flex; gap:6px; margin-top:6px;">
        <button id="save-slot-2" class="item-use-button">Save 2</button>
        <button id="load-slot-2" class="item-use-button">Load 2</button>
      </div>
      <div style="display:flex; gap:6px; margin-top:6px;">
        <button id="save-slot-3" class="item-use-button">Save 3</button>
        <button id="load-slot-3" class="item-use-button">Load 3</button>
      </div>
    </div>
  </div>
</div>


  <div id="battle-overlay">
    <div id="enemy-display"></div>
    <div id="player-battle-status"></div>
    <div id="battle-controls">
      <button id="attack-button">Attack</button>
      <button id="special-attack-button-1">Extra Credits (100 STM)</button>
      <button id="special-attack-button-2">Plasma Blast (200 STM)</button>
      <button id="inventory-battle-button">Inventory</button>
    </div>
    <div id="inventory-battle-popup" class="inventory-popup" style="display: none;">
      <h4>Inventory</h4>
      <div id="inventory-list"></div>
    </div>
    </div>
      <div id="dialog-overlay" style="display:none; position:fixed; inset:0; z-index:2500;
     background:rgba(0,0,0,0.6); align-items:flex-end; justify-content:center; padding:20px;">
  <div id="dialog-box" style="background:#002591; color:white; border:2px solid black;
       padding:16px; max-width:640px; font-family:'Press Start 2P',sans-serif;">
    <div id="dialog-text" style="white-space:pre-wrap; font-size:12px; line-height:1.2;"></div>
    <div style="text-align:right; margin-top:8px;">
      <button id="dialog-next" style="font-family:'Press Start 2P',sans-serif; padding:8px 12px;">Next</button>
    </div>
  </div>
</div>

<div id="password-popup" style="display:none; position:fixed; inset:0; z-index:3000; background:rgba(0,0,0,0.8);">
  <div style="display:flex; flex-direction:column; justify-content:center; align-items:center; height:100%;">
    <div style="background:#002591; padding:20px; border:2px solid black; font-family:'Press Start 2P',sans-serif; color:white; width:300px; text-align:center;">
      <p>Enter 4-digit code:</p>
      <input id="password-input" type="password" maxlength="4" style="font-size:20px; text-align:center; width:100px;" />
      <div style="margin-top:15px;">
        <button id="password-submit" style="font-family:'Press Start 2P',sans-serif; padding:8px 12px; cursor:pointer;">Submit</button>
        <button id="password-cancel" style="font-family:'Press Start 2P',sans-serif; padding:8px 12px; cursor:pointer; margin-left:10px;">Cancel</button>
      </div>
      <p id="password-message" style="color:#ff4444; margin-top:10px; height:18px;"></p>
    </div>
  </div>
</div>

<!-- Must start hidden! -->
<div id="game-over-overlay" style="display: none">
  <div class="game-over-content">
    <h1>Game Over</h1>
    <p>Press 'R' to Restart</p>
  </div>
</div>

  </div>

<script>
console.log('script loaded');

const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');

// Focus canvas for keyboard input
canvas.tabIndex = 0;
canvas.focus();
canvas.addEventListener('click', () => canvas.focus());

// Player and game variables
let isGameOver = false;
let x = 150, y = 50;
const speed = 20;
const imageSize = 60;
const hitboxWidth = 30;
const hitboxHeight = 30;
const hitboxOffsetX = (imageSize - hitboxWidth) / 2;
const hitboxOffsetY = (imageSize - hitboxHeight) / 2;
const useImage = true;
const img = new Image();
img.src = '8bit.png';

const hpBar = document.getElementById('hp-bar');
const hpText = document.getElementById('hp-text');

let selectedEnemyIndex = 0;
let isPowered = false;

let shownDialogs = new Set();
let _dialogQueue = [];


const zoneSprites = {
  fail: new Image (),
  robot: new Image(),
  bossrobot: new Image()
};
zoneSprites.fail.src = 'fail.png';
zoneSprites.bossrobot.src = 'bossrobot.png';
zoneSprites.robot.src = 'robot.png';


  
let tempText = "";
let tempTextTimeout = null;
let defeatedZone = null;
let enemyAttackIntervalId = null;
const ENEMY_ATTACK_DELAY = 2000;
let staminaRegenIntervalId = null;
let inventory = new Map();
let extraLifeTimerId = null;

  const armorTypes = {
  retro: { name: "Retro Armor", hpBonus: 0.10, passiveHealPercent: 0 },
  v8:    { name: "V8 Armor", hpBonus: 0.20, passiveHealPercent: 0 },
  saloon:{ name: "Saloon Armor", hpBonus: 0.40, passiveHealPercent: 0.02 },
  haunted:{name: "Haunted Armor", hpBonus: 0.30, passiveHealPercent: 0, blockChance: 0.15 }, // 15% chance to block
  virus: { name: "Virus Armor", hpBonus: 0.50, passiveHealPercent: 0 }
};

const weaponTypes = {
  retro: { name: "Retro Weapon", dmgBonus: 0.10 },
  v8:    { name: "V8 Weapon", dmgBonus: 0.20 },
  saloon:{ name: "Saloon Weapon", dmgBonus: 0.15 },
  haunted:{name: "Haunted Weapon", dmgBonus: 0.25 },
  virus: { name: "Virus Weapon", dmgBonus: 0.50 }
};

  let equippedArmor = null;  // e.g. "retro", "v8", etc.
let equippedWeapon = null; // e.g. "retro", "virus", etc.

function applyEquipmentBonuses() {
  // read base stats (never mutated by this function)
  const baseMaxHp = playerStats.baseMaxHp;
  const baseDamage = playerStats.baseDamage;

  // Armor bonus to max HP (percentage)
  let armorBonusHp = 0;
  if (equippedArmor && armorTypes[equippedArmor]) {
    armorBonusHp = Math.floor(baseMaxHp * armorTypes[equippedArmor].hpBonus);
  }

  // Weapon bonus to damage (percentage)
  let weaponBonusDmg = 0;
  if (equippedWeapon && weaponTypes[equippedWeapon]) {
    weaponBonusDmg = Math.floor(baseDamage * weaponTypes[equippedWeapon].dmgBonus);
  }

  // compute final stats (idempotent)
  playerStats.maxHp = baseMaxHp + armorBonusHp;
  playerStats.damage = baseDamage + weaponBonusDmg;

  // clamp current HP to max (preserve relative HP percentage)
  if (playerStats.currentHp > playerStats.maxHp) {
    playerStats.currentHp = playerStats.maxHp;
  }

  updateHp(playerStats.currentHp);
  updateStatsPopup();
}

  
// Initialize inventory with items
inventory.set("bandaid", 1);
inventory.set("emp_grenade", 1);
inventory.set("poison_vial", 1);
inventory.set("extra_life", 1);
  
inventory.set("hammer", 0);
inventory.set("laser_cutter", 0);
inventory.set("raft", 0);
inventory.set("keycard", 0);
inventory.set("gas_mask", 0);
inventory.set("drill", 1);
inventory.set("torch", 0);
  
inventory.set("armor_retro", 0);
inventory.set("armor_v8", 0);
inventory.set("armor_saloon", 1);
inventory.set("armor_haunted",1);
inventory.set("armor_virus", 0);

inventory.set("weapon_retro", 0);
inventory.set("weapon_v8", 0);
inventory.set("weapon_saloon", 1);
inventory.set("weapon_haunted", 1);
inventory.set("weapon_virus", 1);

let playerStats = {
  level: 1,
  currentHp: 8,
  maxHp: 8,
  damage: 2,
  xp: 0,
  xpToNextLevel: 10,
  currentStamina: 50,
  maxStamina: 200,

  // new base fields â€” always treat these as the canonical, unmodified stats
  baseMaxHp: 8,
  baseDamage: 2
};
const alliesData = [
  { id: 'ally1', name: 'Lou', baseMaxHp: 30, baseDamage: 3, attackIntervalMs: 1700, level: 1, xp: 0, xpToNextLevel: 10 },
  { id: 'ally2', name: 'Buzz', baseMaxHp: 58, baseDamage: 4, attackIntervalMs: 2200, level: 1, xp: 0, xpToNextLevel: 10 },
  { id: 'ally3', name: 'Colt', baseMaxHp: 23, baseDamage: 6, attackIntervalMs: 3000, level: 1, xp: 0, xpToNextLevel: 10 },
  { id: 'ally4', name: 'Otis', baseMaxHp: 45, baseDamage: 4, attackIntervalMs: 2000, level: 1, xp: 0, xpToNextLevel: 10 },
  { id: 'ally5', name: 'Janet', baseMaxHp: 40, baseDamage: 3, attackIntervalMs: 1500, level: 1, xp: 0, xpToNextLevel: 10 },
  { id: 'ally6', name: 'Max', baseMaxHp: 36, baseDamage: 4, attackIntervalMs: 1000, level: 1, xp: 0, xpToNextLevel: 10 },
];

let unlockedAllies = new Set();  // Track unlocked ally IDs
let equippedAllyId = null;       // Currently equipped ally ID or null
let activeAlly = null;           // Ally battle state (HP etc)
let allyAttackTimerId = null;    // Timer for ally attacks

let inBattle = false;

const enemyTypes = {
  Dummy: { name: "Dummy", maxHp: 12, damage: 1, xpReward: 3, behavior: "normalAttack" },
  Botling: { name: "Botling", maxHp: 10, damage: 1, xpReward: 2, behavior: "normalAttack" },
  Sniperbot: { name: "Sniper", maxHp: 20, damage: 1, xpReward: 5, behavior: "sniperAttack" },
  Puncherbot: { name: "Puncher", maxHp: 36, damage: 1, xpReward: 5, behavior: "normalAttack" },
  Mousebot: { name: "Quickbot", maxHp: 30, damage: 2, xpReward: 5, behavior: "normalAttack" },
  BossBot: { name: "BossRobot", maxHp: 100, damage: 4, xpReward: 50, isBoss: true, behavior: "bossBehavior", defaultResistances: {stun: true, poison:true }},
  Summoner: { name: "Factory", maxHp: 80, damage: 0, xpReward: 20, behavior: "summonerBehavior" },
  SecondStageBossStage1: { name: "Stage1 Boss", maxHp: 50, damage: 3, xpReward: 30, behavior: "secondStageBossBehavior", secondStageType: "SecondStageBossStage2" },
  SecondStageBossStage2: { name: "Stage2 Boss", maxHp: 80, damage: 6, xpReward: 50, behavior: "normalAttack" },
  Healer: { name: "Barbot", maxHp: 35, damage: 1, xpReward: 15, behavior: "healerBehavior" }
};

const levels = [
  {
    bgSrc: "arcadebg.png",
    walls: [
      { x: 0, y: 0, width: 640, height: 20 },
      { x: 0, y: 460, width: 640, height: 20 },
      { x: 290, y: 150, width: 32, height: 200 },
      { x: 290, y: 150, width: 220, height: 20 },
      { x: 500, y: 150, width: 20, height: 200 },
      { x: 0, y: 0, width: 20, height: 480 },
      { x: 290, y: 350, width: 85, height: 15 },
      { x: 450, y: 350, width: 50, height: 15 },
    ],
    doors: [
      { x: 375, y: 340, width: 85, height: 10, destLevel: 1, destX: 300, destY: 375 },
      { x: 620, y: 0, width: 20, height: 480, destLevel: 2, destX: 40, destY: 40 }
    ],
    darkZones: [],
    battleZones: [],
    dialogZones: [],
    interactables: []
  },
  {
    bgSrc: "arcadeinside.png",
    walls: [
      { x: 0, y: 0, width: 640, height: 70 },
      { x: 608, y: 0, width: 32, height: 480 },
      { x: 0, y: 0, width: 50, height: 480 },
      { x: 400, y: 300, width: 100, height: 100},
    ],
    doors: [
      { x: 0, y: 460, width: 640, height: 20, destLevel: 0, destX: 400, destY: 400 }
    ],
    battleZones: [],
    dialogZones: [
  {
    id: 'enter_arcade',
    x: 0, y: 0, width: 640, height: 480,
    text: ["The arcade! Always been my source of comfort.", "It's a little broken down, though."],
    autoShow: true,
    style: 'dialog',
    speaker: '8-Bit'
  }
],
    interactables: [
      { name: "power_box", x: 20, y: 260, width: 100, height: 100, action: "power_on" },
      { name: "arcade_machine", x: 340, y: 80, width: 100, height: 100, action: "start_battle", encounter: [{ type: "Dummy" }] },
      { name: "steel_block", x: 400, y: 300, width: 100, height: 100, action: "break", requiredItem: "laser_cutter" },
      { name: "hammer", x: 150, y: 300, width: 32, height: 32, action: "pickup", itemName: "hammer"},
      { name: "security_panel", x: 500, y: 100, width: 40, height: 40, action: "open_door", requiresKeycard: false, destLevel: 2, destX: 50, destY: 50 },
      { id: "chest_001", name: "wooden_chest", x: 220, y: 220, width: 64, height: 64, action: "chest",
    rewards: [["bandaid",2], ["emp_grenade",1], ["extra_life",1]], opened: false }
    ]
  },
  {
    bgSrc: "arcadeA2.png",
    walls: [
      { x: 0, y: 460, width: 640, height: 20 },
      { x: 620, y: 0, width: 20, height: 220 },
      { x: 580, y: 250, width: 64, height: 64 },
      { x: 0, y: 150, width: 500, height: 70},
      { x: 615, y: 335, width: 25, height: 200},
    ],
    doors: [
      { x: 0, y: 0, width: 20, height: 150, destLevel: 0, destX: 550, destY: 400 },
      { x: 50, y: 0, width: 50, height: 20, destLevel: 3, destX: 50, destY: 400 },
      { x: 100, y: 0, width: 50, height: 20, destLevel: 3, destX: 100, destY: 400 },
      { x: 150, y: 0, width: 50, height: 20, destLevel: 3, destX: 150, destY: 400 },
      { x: 200, y: 0, width: 50, height: 20, destLevel: 3, destX: 200, destY: 400 },
      { x: 250, y: 0, width: 50, height: 20, destLevel: 3, destX: 250, destY: 400 },
      { x: 300, y: 0, width: 50, height: 20, destLevel: 3, destX: 300, destY: 400 },
      { x: 350, y: 0, width: 50, height: 20, destLevel: 3, destX: 350, destY: 400 },
      { x: 400, y: 0, width: 50, height: 20, destLevel: 3, destX: 400, destY: 400 },
      { x: 450, y: 0, width: 50, height: 20, destLevel: 3, destX: 450, destY: 400 },
      { x: 500, y: 0, width: 50, height: 20, destLevel: 3, destX: 500, destY: 400 },
      { x: 550, y: 0, width: 50, height: 20, destLevel: 3, destX: 550, destY: 400 },
      { x: 600, y: 0, width: 40, height: 20, destLevel: 3, destX: 600, destY: 400 }
    ],
     battleZones: [
      { x: 530, y: 80, width: 64, height: 64, encounter: [{ type: "Sniperbot" }], sprite: 'fail' },
      { x: 240, y: 315, width: 64, height: 64, encounter: [{ type: "Sniperbot" }, {type: "Sniperbot"}], sprite: 'fail'}
],
    waterZones: [], // make something like { x: 0, y: 0, width: 1, height: 1 } for zones
  poisonZones: [],
    dialogZones: [
  {
    id: 'encounter_enemies',
    x: 0, y: 0, width: 640, height: 480,
    text: ["Oh, wow. There's robots around.", "I wonder if they're hostile. Maybe I should ask them what happened?"],
    autoShow: true,
    style: 'dialog',
    speaker: '8-Bit'
  },
      {
    id: 'after_first_battle',
    x: 520, y: 170, width: 120, height: 70,
    text: ["Okay, something's definitely up.", "After all, I did wake up to a wasteland.", "Wait, how long was I out for?", "It can't be a few years, I mean, I hope..."],
    autoShow: true,
    style: 'dialog',
    speaker: '8-Bit'
      }
],
    interactables: [
      { name: "big_stone", x: 580, y: 250, width: 64, height: 64, interactRect: { x: 560, y: 230, width: 120, height: 96 }, action: "break", requiredItem: "hammer" }
    ]
  },
  { bgSrc: "arcadeB2_3.png",
    walls: [
      { x: 0, y: 0, width: 640, height: 20 },
      { x: 0, y: 0, width: 20, height: 480 },
      { x: 620, y: 0, width: 20, height: 480},
      { x: 0, y: 160, width: 315, height: 20},
      { x: 460, y: 160, width: 220, height: 20},
    ],
    doors: [
      { x: 0, y: 460, width: 50, height: 20, destLevel: 2, destX: 50, destY: 50 },
      { x: 50, y: 460, width: 50, height: 20, destLevel: 2, destX: 100, destY: 50 },
      { x: 100, y: 460, width: 50, height: 20, destLevel: 2, destX: 150, destY: 50 },
      { x: 150, y: 460, width: 50, height: 20, destLevel: 2, destX: 200, destY: 50 },
      { x: 200, y: 460, width: 50, height: 20, destLevel: 2, destX: 250, destY: 50 },
      { x: 250, y: 460, width: 50, height: 20, destLevel: 2, destX: 300, destY: 50 },
      { x: 300, y: 460, width: 50, height: 20, destLevel: 2, destX: 350, destY: 50 },
      { x: 350, y: 460, width: 50, height: 20, destLevel: 2, destX: 400, destY: 50 },
      { x: 400, y: 460, width: 80, height: 20, destLevel: 2, destX: 450, destY: 50 },
      { x: 450, y: 460, width: 50, height: 20, destLevel: 2, destX: 500, destY: 50 },
      { x: 500, y: 460, width: 50, height: 20, destLevel: 2, destX: 550, destY: 50 },
      { x: 550, y: 460, width: 50, height: 20, destLevel: 2, destX: 550, destY: 50 },
      { x: 600, y: 460, width: 40, height: 20, destLevel: 2, destX: 600, destY: 50 }
    ],
    darkZones: [
    { x: 50, y: 50, width: 50, height: 50 },
      ],
    battleZones: [
      { x: 507, y: 70, width: 64, height: 64, encounter: [{ type: "Sniperbot" }, {type: "Sniperbot"}], sprite: 'fail' },
      { x: 240, y: 60, width: 80, height: 80, encounter: [{ type: "Sniperbot" }, {type: "Puncherbot"}, {type: "Sniperbot"}], sprite: 'fail'}
    ],
    dialogZones: [
      {
    id: 'enter_B2',
    x: 0, y: 0, width: 640, height: 480,
    text: ["Wow, is that a chest I see?", "What's up with that huge crack on the floor though?"],
    autoShow: true,
    style: 'dialog',
    speaker: '8-Bit'
  }
    ],
    interactables: [
      {
  name: "ground_crack",
  x: 486,
  y: 371,
  width: 64,
  height: 64,
  action: "use_drill",
  destLevel: 4,
  destX: 100,
  destY: 100
},
      { id: "chest_001", name: "wooden_chest", x: 78, y: 70, width: 64, height: 64, action: "chest",
    rewards: [["bandaid",1], ["emp_grenade",1]], opened: false }
    ]
  },
  {
    bgSrc: "caves1_4.png",
    walls: [
      { x: 0, y: 0, width: 20, height: 480 },
      { x: 0, y: 0, width: 640, height: 20 },
      { x: 0, y: 460, width: 640, height: 20 },
      { x: 0, y: 250, width: 50, height: 230},
    ],
    doors: [
      { x: 100, y: 163, width: 64, height: 64, destLevel: 3, destX: 550, destY: 400 },
      { x: 620, y: 0, width: 20, height: 50, destLevel: 5, destX: 50, destY: 50 },
      { x: 620, y: 50, width: 20, height: 50, destLevel: 5, destX: 50, destY: 100 },
      { x: 620, y: 100, width: 20, height: 50, destLevel: 5, destX: 50, destY: 150 },
      { x: 620, y: 150, width: 20, height: 50, destLevel: 5, destX: 50, destY: 200 },
      { x: 620, y: 200, width: 20, height: 50, destLevel: 5, destX: 50, destY: 250 },
      { x: 620, y: 250, width: 20, height: 50, destLevel: 5, destX: 50, destY: 300 },
      { x: 620, y: 300, width: 20, height: 50, destLevel: 5, destX: 50, destY: 350 },
      { x: 620, y: 350, width: 20, height: 50, destLevel: 5, destX: 50, destY: 350 },
      { x: 620, y: 400, width: 20, height: 80, destLevel: 5, destX: 50, destY: 400 }
    ],
     battleZones: [],
    waterZones: [],
  poisonZones: [],
    dialogZones: [
      {
    id: 'enter_caves1',
    x: 0, y: 0, width: 640, height: 480,
    text: ["Oh, a cave, interesting!", "I wonder what's in store..."],
    autoShow: true,
    style: 'dialog',
    speaker: '8-Bit'
  }
    ],
    interactables: [
      {
  id: 'lou_recruit',
  name: 'lou_recruit',
  x: 100,
  y: 100,
  width: 32,
  height: 32,
  interactRect: { x: 290, y: 190, width: 52, height: 52 },
  action: 'recruit',
  allyId: 'ally1',               // must match alliesData id
  displayName: 'Lou',
  recruitDialog: [
    { speaker: 'Lou', text: "Hey, looks like you could use a hand.", style: 'lou' },
    { speaker: '8-Bit', text: "Welcome aboard, Lou.", style: 'dialog' }
  ],
  opened: false
}
    ]
  },
  {
    bgSrc: "caves2_5.png",
    walls: [
      { x: 0, y: 0, width: 640, height: 30 },
      { x: 0, y: 450, width: 640, height: 30 },
      { x: 196, y: 196, width: 444, height: 133 },
    ],
    doors: [
      { x: 0, y: 0, width: 20, height: 50, destLevel: 4, destX: 580, destY: 50 },
      { x: 0, y: 50, width: 20, height: 50, destLevel: 4, destX: 580, destY: 100 },
      { x: 0, y: 100, width: 20, height: 50, destLevel: 4, destX: 580, destY: 150 },
      { x: 0, y: 150, width: 20, height: 50, destLevel: 4, destX: 580, destY: 200 },
      { x: 0, y: 200, width: 20, height: 50, destLevel: 4, destX: 580, destY: 250 },
      { x: 0, y: 250, width: 20, height: 50, destLevel: 4, destX: 580, destY: 300 },
      { x: 0, y: 300, width: 20, height: 50, destLevel: 4, destX: 580, destY: 350 },
      { x: 0, y: 350, width: 20, height: 50, destLevel: 4, destX: 580, destY: 400 },
      { x: 0, y: 400, width: 20, height: 80, destLevel: 4, destX: 580, destY: 400 },
      { x: 620, y: 40, width: 20, height: 160, destLevel: 6, destX: 50, destY: 120 },
      { x: 620, y: 330, width: 20, height: 130, destLevel: 6, destX: 50, destY: 350}
    ],
     battleZones: [
      { x: 530, y: 80, width: 64, height: 64, encounter: [{ type: "Sniperbot" }], sprite: 'fail' },
      { x: 240, y: 315, width: 64, height: 64, encounter: [{ type: "Sniperbot" }, {type: "Sniperbot"}], sprite: 'fail'}
],
    waterZones: [],
  poisonZones: [],
    dialogZones: [
  {
    id: 'test',
    x: 0, y: 0, width: 640, height: 480,
    text: [
      { speaker: '8-Bit', text: "Why am I speaking right now?", style: 'dialog' },
      { speaker: 'Boss',  text: "Author wanted to test some code.", style: 'boss' },
      { speaker: '8-Bit', text: "Oh. Well I hope it works.", style: 'dialog' },
      { speaker: 'Boss',  text: "If you're seeing this, it probably does.", style: 'boss' }
    ],
    autoShow: true,
    style: 'dialog'
  }
      ],
    interactables: []
  },
  {
    bgSrc: "caves3_6.png",
    walls: [
      { x: 0, y: 460, width: 640, height: 20 },
      { x: 620, y: 0, width: 20, height: 480 },
      { x: 0, y: 210, width: 640, height: 115 },
      { x: 360, y: 160, width: 100, height: 40 },
      { x: 447, y: 0, width: 200, height: 250 },
    ],
    doors: [
      { x: 0, y: 0, width: 20, height: 210, destLevel: 5, destX: 580, destY: 100 },
      { x: 0, y: 325, width: 20, height: 160, destLevel: 5, destX: 580, destY: 360 }
    ],
     battleZones: [],
    waterZones: [],
  poisonZones: [],
    dialogZones: [],
    interactables: [
      {
  name: "ground_crack",
  x: 526,
  y: 359,
  width: 64,
  height: 64,
  action: "use_drill",
  destLevel: 7,
  destX: 100,
  destY: 100
}
    ]
  },
  {
    bgSrc: "darkcaves1_7.png",
    walls: [
      { x: 0, y: 0, width: 640, height: 20 },
    ],
    doors: [],
    darkZones: [
      { x: 0, y: 0, width: 640, height: 480 }
    ],
    battleZones: [],
    dialogZones: [],
    interactables: []
  },
  {
    bgSrc: "darkcaves2_8.png",
    walls: [
      { x: 0, y: 0, width: 640, height: 20 },
    ],
    doors: [
      { x: 375, y: 340, width: 85, height: 10, destLevel: 1, destX: 300, destY: 375 },
      { x: 620, y: 0, width: 20, height: 480, destLevel: 2, destX: 40, destY: 40 }
    ],
    darkZones: [
      { x: 0, y: 0, width: 640, height: 480 }
    ],
    battleZones: [],
    dialogZones: [],
    interactables: []
  },
  {
    bgSrc: "darkcaves3_9.png",
    walls: [
      { x: 0, y: 0, width: 640, height: 20 },
    ],
    doors: [
      { x: 375, y: 340, width: 85, height: 10, destLevel: 1, destX: 300, destY: 375 },
      { x: 620, y: 0, width: 20, height: 480, destLevel: 2, destX: 40, destY: 40 }
    ],
    darkZones: [
      { x: 0, y: 0, width: 640, height: 480 }
    ],
    battleZones: [],
    dialogZones: [],
    interactables: []
  }
];

let currentLevelIndex = 0;
let currentLevel = levels[currentLevelIndex];

  const titleScreen = document.getElementById('title-screen');
const playBtn = document.getElementById('play-button');
  
// Preload and spawn background + player at game start
let bgImg = new Image();
bgImg.src = 'arcade.png';
const playerImg = new Image();
playerImg.src = '8bit.png'; // keep your existing player path


function preloadImagesForLevel(levelIndex, onComplete) {
  const level = levels[levelIndex];
  // preload bg
  bgImg = new Image();
  bgImg.onload = () => {
    // preload player sprite after bg (optional parallel)
    if (img && img.complete) return onComplete();
    img = img || new Image();
    img.onload = () => onComplete();
    img.src = img.src || '8bit.png';
  };
  bgImg.src = level.bgSrc;
}

// find first unseen dialog zone at a given world position
function findDialogZone(checkX, checkY) {
  const hitboxX = checkX + (typeof hitboxOffsetX !== 'undefined' ? hitboxOffsetX : 0);
  const hitboxY = checkY + (typeof hitboxOffsetY !== 'undefined' ? hitboxOffsetY : 0);
  const hw = typeof hitboxWidth !== 'undefined' ? hitboxWidth : 16;
  const hh = typeof hitboxHeight !== 'undefined' ? hitboxHeight : 16;
  const level = currentLevel;
  if (!level || !level.dialogZones) return null;
  for (const zone of level.dialogZones) {
    if (!zone || !zone.id) continue;
    if (shownDialogs.has(zone.id)) continue;
    if (
      hitboxX < zone.x + zone.width &&
      hitboxX + hw > zone.x &&
      hitboxY < zone.y + zone.height &&
      hitboxY + hh > zone.y
    ) return zone;
  }
  return null;
}


function normalizeDialogLines(textOrLines, defaultStyle) {
  const lines = Array.isArray(textOrLines) ? textOrLines.slice() : [String(textOrLines)];
  return lines.map(line => {
    if (typeof line === 'string') {
      return { speaker: null, text: line, style: defaultStyle || 'dialog' };
    }
    return {
      speaker: line.speaker || null,
      text: line.text != null ? String(line.text) : '',
      style: line.style || defaultStyle || 'dialog'
    };
  });
}

function applyDialogStyle(box, style) {
  box.style.maxWidth = '640px';
  box.style.fontSize = '12px';
  if (style === 'other') {
    box.style.background = '#223344';
    box.style.fontSize = '14px';
  } else if (style === 'lou') {
    box.style.background = '#78bdff';
    box.style.fontSize = '14px';
  } else if (style === 'boss') {
    box.style.background = '#330000';
    box.style.fontSize = '12px';
    } else if (style === 'colt') {
    box.style.background = '#ca2f2f';
    box.style.fontSize = '12px';
  } else {
    box.style.background = '#0e2057';
    box.style.fontSize = '12px';
  }
}

function showDialog(textOrLines, idToMark, opts = {}) {
  const overlay = document.getElementById('dialog-overlay');
  const box = document.getElementById('dialog-box');
  const textDiv = document.getElementById('dialog-text');

  const defaultStyle = opts.style || 'dialog';
  _dialogQueue = normalizeDialogLines(textOrLines, defaultStyle);

  if (_dialogQueue.length > 0) {
    const line = _dialogQueue.shift();
    applyDialogStyle(box, line.style);
    if (line.speaker) {
      textDiv.innerHTML = `<strong>${line.speaker}</strong>\n\n${line.text}`;
    } else {
      textDiv.textContent = line.text;
    }
  } else {
    textDiv.textContent = '';
  }

  overlay.style.display = 'flex';
  overlay._markId = idToMark || null;
  draw();
}


// Play button handler
playBtn.addEventListener('click', () => {
  // Hide title screen
  titleScreen.style.display = 'none';

  // Set starting level and spawn coordinates (adjust if different)
  currentLevelIndex = 0;
  currentLevel = levels[currentLevelIndex];
  x = typeof x === 'number' ? x : 150;
  y = typeof y === 'number' ? y : 50;

  // Preload necessary images then draw/start
  preloadImagesForLevel(currentLevelIndex, () => {
    // show background and player immediately after preload
    draw();

  });


  draw();
});

const closedChestImg = new Image(); closedChestImg.src = "chest_closed.png";
const openChestImg   = new Image(); openChestImg.src = "chest_open.png";

const stoneImg = new Image();
stoneImg.src = "stone.png";

const hammerImg = new Image();
hammerImg.src = "hammer.png";

const steelBlockImg = new Image();
steelBlockImg.src = 'steel_block.png';

const laserCutterImg = new Image();
laserCutterImg.src = 'laser_cutter.png';

const keycardImg = new Image();
keycardImg.src = 'keycard.png';

const gasMaskImg = new Image();
gasMaskImg.src = 'gas_mask.png';

const raftImg = new Image();
raftImg.src = 'raft.png';

const torchImg = new Image();
torchImg.src = 'torch.png';

const drillImg = new Image();
drillImg.src = 'drill.png';

let activeEnemies = [];

// Utility: text wrapping for canvas
function wrapText(context, text, x, y, maxWidth, lineHeight) {
  const words = String(text).split(' ');
  let line = "";
  for (let n = 0; n < words.length; n++) {
    const testLine = line ? (line + " " + words[n]) : words[n];
    const metrics = context.measureText(testLine);
    const testWidth = metrics.width;
    if (testWidth > maxWidth && n > 0) {
      context.fillText(line.trim(), x, y);
      line = words[n];
      y += lineHeight;
    } else {
      line = testLine;
    }
  }
  context.fillText(line.trim(), x, y);
}

// Show temporary text on screen for 3 seconds
function showTemporaryText(message) {
  tempText = message;
  if (tempTextTimeout) clearTimeout(tempTextTimeout);
  tempTextTimeout = setTimeout(() => {
    tempText = "";
    draw();
  }, 3000);
}

  
// Check if player can go below 1 HP (used with extra life item)
function canGoBelow1Hp() {
  return extraLifeTimerId === null;
}

// Update stamina and clamp between 0 and max
function updateStamina(newStamina) {
  if (newStamina < 0) newStamina = 0;
  if (newStamina > playerStats.maxStamina) newStamina = playerStats.maxStamina;
  playerStats.currentStamina = newStamina;
}

// Update HP and UI bar
function updateHp(newHealth) {
  if (newHealth < 0) newHealth = 0;
  if (newHealth > playerStats.maxHp) newHealth = playerStats.maxHp;
  playerStats.currentHp = newHealth;
  const newWidth = (playerStats.currentHp / playerStats.maxHp) * 100;
  hpBar.style.width = `${newWidth}%`;
  hpText.textContent = `${playerStats.currentHp}/${playerStats.maxHp}`;
}

// Update stats popup UI
function updateStatsPopup() {
  document.getElementById('popup-level').textContent = playerStats.level;
  document.getElementById('popup-xp').textContent = `${playerStats.xp} / ${playerStats.xpToNextLevel}`;
  document.getElementById('popup-damage').textContent = playerStats.damage;
}

const passwordPopup = document.getElementById('password-popup');
const passwordInput = document.getElementById('password-input');
const passwordSubmit = document.getElementById('password-submit');
const passwordCancel = document.getElementById('password-cancel');
const passwordMessage = document.getElementById('password-message');

let currentPasswordDoor = null;

function openPasswordPopup(doorObj) {
  currentPasswordDoor = doorObj;
  passwordInput.value = "";
  passwordMessage.textContent = "";
  passwordPopup.style.display = 'flex';
  passwordInput.focus();
}

function closePasswordPopup() {
  passwordPopup.style.display = 'none';
}

passwordSubmit.addEventListener('click', () => {
  if (!currentPasswordDoor) {
    console.error('No password door assigned');
    return;
  }

  const entered = passwordInput.value;

  if (entered === currentPasswordDoor.passcode) {
    showTemporaryText('Access granted!');
    closePasswordPopup();

    if (typeof currentPasswordDoor.destLevel === 'number') {
      loadLevel(currentPasswordDoor.destLevel, currentPasswordDoor.destX, currentPasswordDoor.destY);
    } else {
      console.error('Destination level is invalid or missing');
    }

    currentLevel.interactables = currentLevel.interactables.filter(o => o !== currentPasswordDoor);
    draw();
  } else {
    passwordMessage.textContent = "Incorrect code!";
  }
});

passwordCancel.addEventListener('click', () => {
  closePasswordPopup();
});

function ensureFiniteNumber(v, fallback) {
  const n = Number(v);
  return Number.isFinite(n) ? n : fallback;
}

function levelUpAlly(ally) {
  // Snapshot at start for debugging
  console.log('levelUp start', { id: ally.id, name: ally.name, before: { ...ally } });

  // Preserve existing numeric values when valid; fall back only when truly invalid
  ally.level = ensureFiniteNumber(ally.level, 1);
  ally.xp = ensureFiniteNumber(ally.xp, 0);
  ally.xpToNextLevel = ensureFiniteNumber(ally.xpToNextLevel, 10);
  ally.baseMaxHp = ensureFiniteNumber(ally.baseMaxHp, null);
  ally.baseDamage = ensureFiniteNumber(ally.baseDamage, null);

  // If this ally has defaults in alliesData, use them only when the current values are missing
  const baseAllyTemplate = alliesData.find(a => a.id === ally.id);
  if (baseAllyTemplate) {
    if (ally.baseMaxHp === null) ally.baseMaxHp = ensureFiniteNumber(baseAllyTemplate.baseMaxHp, 1);
    if (ally.baseDamage === null) ally.baseDamage = ensureFiniteNumber(baseAllyTemplate.baseDamage, 0);
  } else {
    // final fallback
    if (ally.baseMaxHp === null) ally.baseMaxHp = 1;
    if (ally.baseDamage === null) ally.baseDamage = 0;
  }

  // Perform repeated level-ups if xp is enough for multiple
  let leveled = false;
  while (ally.xp >= ally.xpToNextLevel && ally.xpToNextLevel > 0) {
    leveled = true;
    ally.level++;
    ally.xp -= ally.xpToNextLevel;
    ally.xpToNextLevel = Math.floor(ally.xpToNextLevel * 1.2);

    // Apply stat growth based on the new level
    ally.baseMaxHp += Math.floor(2 + (ally.level / 2));
    ally.baseDamage += Math.floor(1 + (ally.level / 6));

    console.log('leveled one step', {
      id: ally.id, level: ally.level, xp: ally.xp,
      xpToNextLevel: ally.xpToNextLevel, baseMaxHp: ally.baseMaxHp, baseDamage: ally.baseDamage
    });
  }

  if (!leveled) {
    console.log('no level up: xp below threshold', { xp: ally.xp, xpToNextLevel: ally.xpToNextLevel });
    return; // nothing changed
  }

  // Update hp after all level-ups
  ally.maxHp = ally.baseMaxHp;
  ally.currentHp = ally.maxHp;

  showTemporaryText(`${ally.name} leveled up to ${ally.level}!`);
  drawPartyStatus();

  // Sync back to alliesData (only numeric fields)
  const baseAlly = alliesData.find(a => a.id === ally.id);
  if (baseAlly) {
    baseAlly.level = ally.level;
    baseAlly.xp = ally.xp;
    baseAlly.xpToNextLevel = ally.xpToNextLevel;
    baseAlly.baseMaxHp = ally.baseMaxHp;
    baseAlly.baseDamage = ally.baseDamage;
    console.log('synced to template', { before: baseAlly });
  } else {
    console.warn('No base template found for ally id', ally.id);
  }

  console.log('levelUp end', { id: ally.id, after: { ...ally } });
}


// Level up player
function levelUp() {
  playerStats.level++;
  playerStats.xp -= playerStats.xpToNextLevel;
  playerStats.xpToNextLevel = Math.floor(playerStats.xpToNextLevel * 1.5);

  // increase base stats (affects final via applyEquipmentBonuses)
  playerStats.baseMaxHp += Math.floor(2 + (playerStats.level / 2));
  playerStats.baseDamage += Math.floor(1 + (playerStats.level / 6));

  // recompute final stats and heal
  applyEquipmentBonuses();

  playerStats.currentHp = playerStats.maxHp;
  updateHp(playerStats.currentHp);

  updateStatsPopup();
  showTemporaryText(`Leveled up to ${playerStats.level}!`);
}

// Gain XP and check level up
function gainXP(amount) {
  playerStats.xp += amount;

  // Also give XP to equipped ally
  if (activeAlly) {
    activeAlly.xp += amount;
    while (activeAlly.xp >= activeAlly.xpToNextLevel) {
      levelUpAlly(activeAlly);
    }
  }

  if (playerStats.xp >= playerStats.xpToNextLevel) {
    levelUp();
  }
  updateStatsPopup();
  drawPartyStatus();
}

// Remove battle or interactable zone after clearing
function removeZone(zone) {
  if (!zone) return;
  if (zone.type === 'battleZone') {
    const index = currentLevel.battleZones.indexOf(zone.object);
    if (index > -1) currentLevel.battleZones.splice(index, 1);
  } else if (zone.type === 'interactable') {
    const index = currentLevel.interactables.indexOf(zone.object);
    if (index > -1) currentLevel.interactables.splice(index, 1);
  }
}

// Scale enemy stats with level
// === Difficulty multipliers ===
function getDifficultyMultipliers() {
  // Normal: 1x; Hard: enemy damage x2; Ultimate: enemy damage x2 and enemy HP x2
  if (gameSettings.difficulty === 'hard') {
    return { enemyHp: 1, enemyDmg: 2 };
  } else if (gameSettings.difficulty === 'ultimate') {
    return { enemyHp: 2, enemyDmg: 2 };
  }
  return { enemyHp: 1, enemyDmg: 1 };
}


function scaleEnemyStats(baseStats) {
  const mult = getDifficultyMultipliers();
  return {
    ...baseStats,
    maxHp: Math.max(1, Math.floor((baseStats.maxHp + Math.floor(currentLevelIndex / 2)) * mult.enemyHp)),
    damage: Math.max(0, Math.floor((baseStats.damage + Math.floor(currentLevelIndex / 3)) * mult.enemyDmg))
  };
}


  
// Inventory popup toggle and drawing
const inventoryButton = document.getElementById('inventory-button');
const inventoryPopup = document.getElementById('inventory-popup');
const statsPopup = document.getElementById('stats-popup');
const inventoryList = document.getElementById('general-inventory-list');

inventoryButton.addEventListener('click', () => {
  // don't open during battle or after game over
  if (inBattle || isGameOver) return;

  // Hide stats popup whenever opening inventory
  if (statsPopup) statsPopup.style.display = 'none';

  // Detect if it's currently hidden (using computed style)
  const isHidden = window.getComputedStyle(inventoryPopup).display === 'none';
  if (isHidden) {
    drawGeneralInventory();
    inventoryPopup.style.display = 'block';
  } else {
    inventoryPopup.style.display = 'none';
  }
});

function drawGeneralInventory() {
  inventoryList.innerHTML = "";
  const allZero = inventory.size === 0 || Array.from(inventory.values()).every(q => q === 0);
  if (allZero) {
    inventoryList.innerHTML = '<p>Your inventory is empty.</p>';
    return;
  }
  inventory.forEach((quantity, itemName) => {
    if (quantity > 0) {
      const p = document.createElement('p');
      p.textContent = `${itemName.replace(/_/g, ' ')}: ${quantity}`;

      // Add equip buttons for armor and weapons
      if (itemName.startsWith("armor_")) {
        const type = itemName.replace("armor_", "");
        const equipBtn = document.createElement('button');
        equipBtn.textContent = "Equip";
        equipBtn.className = 'item-use-button';
        equipBtn.onclick = () => equipArmor(type);
        p.appendChild(equipBtn);
      } else if (itemName.startsWith("weapon_")) {
        const type = itemName.replace("weapon_", "");
        const equipBtn = document.createElement('button');
        equipBtn.textContent = "Equip";
        equipBtn.className = 'item-use-button';
        equipBtn.onclick = () => equipWeapon(type);
        p.appendChild(equipBtn);
      }

      inventoryList.appendChild(p);
    }
  });
}


// Find battle zone for given player position
function findBattleZone(checkX, checkY) {
  const hitboxX = checkX + hitboxOffsetX;
  const hitboxY = checkY + hitboxOffsetY;
  if (!currentLevel.battleZones) return null;
  for (const zone of currentLevel.battleZones) {
    if (
      hitboxX < zone.x + zone.width &&
      hitboxX + hitboxWidth > zone.x &&
      hitboxY < zone.y + zone.height &&
      hitboxY + hitboxHeight > zone.y
    ) {
      return zone;
    }
  }
  return null;
}

function showGameOver() {
  isGameOver = true;
  if (enemyAttackIntervalId) clearInterval(enemyAttackIntervalId);
  if (staminaRegenIntervalId) clearInterval(staminaRegenIntervalId);
  document.getElementById('battle-overlay').style.display = 'none';
  document.getElementById('game-over-overlay').style.display = 'flex';
}

// Battle inventory popup draw
function drawInventoryBattlePopup() {
  const battleInventoryList = document.getElementById('inventory-list');
  battleInventoryList.innerHTML = "";

  // whitelist: items that are allowed in battle (exact names or prefixes)
  const allowedExact = new Set(['bandaid','emp_grenade','poison_vial','extra_life']);
  const allowedPrefix = ['battle_']; // add prefixes for any future battle-only items

  // build list of entries that are allowed and have qty > 0
  const entries = [];
  inventory.forEach((quantity, itemName) => {
    if (!quantity || quantity <= 0) return;
    if (allowedExact.has(itemName)) {
      entries.push({ itemName, quantity });
      return;
    }
    for (const p of allowedPrefix) {
      if (itemName.startsWith(p)) { entries.push({ itemName, quantity }); break; }
    }
  });

  if (entries.length === 0) {
    battleInventoryList.innerHTML = '<p>Inventory is empty.</p>';
    return;
  }

  for (const { itemName, quantity } of entries) {
    const itemElement = document.createElement('div');
    itemElement.className = 'inventory-item';
    itemElement.innerHTML = `<span>${itemName.replace(/_/g,' ')} (${quantity})</span>`;

    const useButton = document.createElement('button');
    useButton.textContent = 'Use';
    useButton.className = 'item-use-button';
    useButton.onclick = () => useItem(itemName);
    itemElement.appendChild(useButton);

    battleInventoryList.appendChild(itemElement);
  }
}

  const partyButton = document.getElementById('party-button');
const partyPopup = document.getElementById('party-popup');
const partyListDiv = document.getElementById('party-list');
const equipAllyButton = document.getElementById('equip-ally-button');

partyButton.addEventListener('click', () => {
  if (partyPopup.style.display === 'none') {
    drawPartyList();
    partyPopup.style.display = 'block';
  } else {
    partyPopup.style.display = 'none';
  }
});

function drawPartyList() {
  partyListDiv.innerHTML = '';
  if (unlockedAllies.size === 0) {
    partyListDiv.innerHTML = '<p>No allies unlocked yet.</p>';
    equipAllyButton.disabled = true;
    return;
  }

  equipAllyButton.disabled = false;

  unlockedAllies.forEach(allyId => {
    const ally = alliesData.find(a => a.id === allyId);
    if (!ally) return;

    const div = document.createElement('div');
    div.className = 'party-ally-item';
    div.textContent = `${ally.name} (Lvl ${ally.level}, HP: ${ally.baseMaxHp}, DMG: ${ally.baseDamage})`;
    div.dataset.allyId = ally.id;
    div.style.cursor = 'pointer';

    if (ally.id === equippedAllyId) {
      div.style.fontWeight = 'bold';
      div.style.color = 'yellow';
    }

    div.onclick = () => {
      const prevSelected = partyListDiv.querySelector('.selected');
      if (prevSelected) prevSelected.classList.remove('selected');
      div.classList.add('selected');
    };

    partyListDiv.appendChild(div);
  });
}

equipAllyButton.addEventListener('click', () => {
  const selectedDiv = partyListDiv.querySelector('.selected');
  if (!selectedDiv) {
    showTemporaryText('Select an ally to equip.');
    return;
  }
  const allyId = selectedDiv.dataset.allyId;
  if (!unlockedAllies.has(allyId)) {
    showTemporaryText('This ally is not unlocked.');
    return;
  }
  equippedAllyId = allyId;
  showTemporaryText(`Equipped ${alliesData.find(a => a.id === allyId).name} as ally.`);
  partyPopup.style.display = 'none';
  drawPartyList();
});

function equipArmor(type) {
  if (!armorTypes[type]) {
    showTemporaryText(`Unknown armor type: ${type}`);
    return;
  }
  if ((inventory.get(`armor_${type}`) || 0) <= 0) {
    showTemporaryText(`You don't have ${armorTypes[type].name} in your inventory.`);
    return;
  }
  equippedArmor = type;
  applyEquipmentBonuses();
  showTemporaryText(`Equipped ${armorTypes[type].name}`);
}

function equipWeapon(type) {
  if (!weaponTypes[type]) {
    showTemporaryText(`Unknown weapon type: ${type}`);
    return;
  }
  if ((inventory.get(`weapon_${type}`) || 0) <= 0) {
    showTemporaryText(`You don't have ${weaponTypes[type].name} in your inventory.`);
    return;
  }
  equippedWeapon = type;
  applyEquipmentBonuses();
  showTemporaryText(`Equipped ${weaponTypes[type].name}`);
}
  
// Use inventory item logic
function useItem(itemName) {
  if ((inventory.get(itemName) || 0) <= 0) return;

  // at the top of useItem(itemName) function, add:
if (inBattle) {
  // only allow explicit battle items while in battle
  const battleAllowed = new Set(['bandaid','emp_grenade','poison_vial','extra_life']);
  if (!battleAllowed.has(itemName) && !itemName.startsWith('battle_')) {
    showTemporaryText("You can't use that item during battle.");
    return;
  }
}

  if (itemName === 'bandaid') {
    const healAmount = Math.ceil(playerStats.maxHp * 0.33);
    updateHp(playerStats.currentHp + healAmount);
    showTemporaryText(`Used a Bandage to heal for ${healAmount} HP!`);
  } else if (itemName === 'emp_grenade') {
    activeEnemies.forEach(enemy => {
      if (!(enemy.resistances && enemy.resistances.stun)) enemy.stunned = true;
    });
    setTimeout(() => {
      activeEnemies.forEach(enemy => {
        if (!(enemy.resistances && enemy.resistances.stun)) enemy.stunned = false;
      });
      drawBattleUI();
    }, 4000);
    showTemporaryText('Used an EMP Grenade! Some enemies stunned for 4 seconds!');
  } else if (itemName === 'poison_vial') {
  const POISON_TICK_MS = 500;
  const POISON_DURATION_MS = 3000;
  const poisonDamagePerTick = Math.max(1, Math.ceil(200 * playerStats.damage / 100));

  activeEnemies.forEach(enemy => {
    if (enemy.resistances && enemy.resistances.poison) return;
    enemy.poisoned = true;
    enemy._poisonElapsed = 0;
    enemy._poisonDuration = POISON_DURATION_MS;

    if (enemy._poisonIntervalId != null) {
      enemy._poisonDuration = POISON_DURATION_MS;
      return;
    }

    enemy._poisonIntervalId = setInterval(() => {
      // defensive guards
      if (!enemy || enemy.removed || enemy.currentHp == null) {
        if (enemy && enemy._poisonIntervalId != null) {
          clearInterval(enemy._poisonIntervalId);
          enemy._poisonIntervalId = null;
        }
        if (enemy) enemy.poisoned = false;
        return;
      }

      // tick damage
      enemy.currentHp = Math.max(0, enemy.currentHp - poisonDamagePerTick);
      enemy._poisonElapsed += POISON_TICK_MS;
      enemy._poisonDuration -= POISON_TICK_MS;

      drawBattleUI();

      // death handling: clear interval first, then remove via handler with known index if possible
      if (enemy.currentHp === 0) {
        const idx = activeEnemies.indexOf(enemy);
        if (enemy._poisonIntervalId != null) {
          clearInterval(enemy._poisonIntervalId);
          enemy._poisonIntervalId = null;
        }
        enemy.poisoned = false;

        if (idx >= 0) {
          handleEnemyDeath(enemy, idx);
        } else {
          handleEnemyDeath(enemy);
        }
        return;
      }

      // expiry
      if (enemy._poisonDuration <= 0) {
        if (enemy._poisonIntervalId != null) {
          clearInterval(enemy._poisonIntervalId);
          enemy._poisonIntervalId = null;
        }
        enemy.poisoned = false;
      }
    }, POISON_TICK_MS);
  });

  showTemporaryText('Used a Poison Vial! Enemies are taking poison damage!');
} else if (itemName === 'extra_life') {
    if (extraLifeTimerId) {
      clearTimeout(extraLifeTimerId);
      extraLifeTimerId = null;
    }
    showTemporaryText('Used an Extra Life! You have 3 seconds of invincibility!');
    extraLifeTimerId = setTimeout(() => { extraLifeTimerId = null; }, 3000);
  } else {
    showTemporaryText(`Used ${itemName}.`);
  }

  // decrement inventory and update UI (this line must be inside the useItem function)
  inventory.set(itemName, Math.max(0, (inventory.get(itemName) || 0) - 1));
  drawInventoryBattlePopup();
  drawBattleUI();
  drawPartyStatus();
  drawPlayerBattleStatus();
}



// Draw battle enemies UI
function drawBattleUI() {
  const battleOverlay = document.getElementById('battle-overlay');
  battleOverlay.style.display = 'flex';
  const enemyDisplay = document.getElementById('enemy-display');
  enemyDisplay.innerHTML = "";
  activeEnemies.forEach((enemy, index) => {
    const enemyButton = document.createElement('button');
    enemyButton.innerHTML = `<h3>${enemy.name}</h3><p>HP: ${enemy.currentHp}/${enemy.maxHp}</p>`;
    enemyButton.className = 'enemy-target';
    if (enemy.shieldActive) enemyButton.classList.add('shielded');
    if (enemy.stunned) enemyButton.classList.add('stunned');
    if (enemy.poisoned) enemyButton.classList.add('poisoned');
    enemyButton.dataset.enemyIndex = index;
    enemyDisplay.appendChild(enemyButton);
    if (index === selectedEnemyIndex) enemyButton.classList.add('selected');
  });
}

// Draw player status in battle UI
function drawPlayerBattleStatus() {
  const playerBattleStatusDiv = document.getElementById('player-battle-status');
  playerBattleStatusDiv.innerHTML = "";

  // Player block
  const leftBlock = document.createElement('div');
  leftBlock.style.display = 'inline-block';
  leftBlock.style.verticalAlign = 'top';
  leftBlock.style.marginRight = '12px';

  const playerName = document.createElement('p');
  playerName.textContent = '8-Bit';
  leftBlock.appendChild(playerName);

  const hpContainer = document.createElement('div');
  hpContainer.className = 'hp-bar-container';
  hpContainer.style.width = '150px';
  hpContainer.style.height = '15px';
  hpContainer.style.position = 'relative';

  const innerHpBar = document.createElement('div');
  innerHpBar.className = 'hp-bar';
  innerHpBar.style.width = `${(playerStats.currentHp / playerStats.maxHp) * 100}%`;
  innerHpBar.style.height = '100%';
  innerHpBar.style.backgroundColor = '#00FF00'; // force HP green

  const hpTxt = document.createElement('div');
  hpTxt.className = 'hp-text';
  hpTxt.textContent = `${playerStats.currentHp}/${playerStats.maxHp}`;

  hpContainer.appendChild(innerHpBar);
  hpContainer.appendChild(hpTxt);
  leftBlock.appendChild(hpContainer);

  // Ally block (to the right of player)
  const rightBlock = document.createElement('div');
  rightBlock.style.display = 'inline-block';
  rightBlock.style.verticalAlign = 'top';

  if (activeAlly) {
    const allyName = document.createElement('p');
    allyName.textContent = `${activeAlly.name} (Lvl ${activeAlly.level})`;
    allyName.style.fontWeight = 'bold';
    rightBlock.appendChild(allyName);

    const allyHpContainer = document.createElement('div');
    allyHpContainer.className = 'hp-bar-container';
    allyHpContainer.style.width = '120px';
    allyHpContainer.style.height = '15px';
    allyHpContainer.style.position = 'relative';

    const allyInner = document.createElement('div');
    allyInner.className = 'hp-bar';
    const allyPercent = (activeAlly.currentHp / activeAlly.maxHp) * 100 || 0;
    allyInner.style.width = `${allyPercent}%`;
    allyInner.style.height = '100%';
    allyInner.style.backgroundColor = '#00FF00'; // force ally HP green

    const allyHpText = document.createElement('div');
    allyHpText.className = 'hp-text';
    allyHpText.textContent = `${activeAlly.currentHp}/${activeAlly.maxHp}`;

    allyHpContainer.appendChild(allyInner);
    allyHpContainer.appendChild(allyHpText);
    rightBlock.appendChild(allyHpContainer);
  } else {
    rightBlock.innerHTML = '<p style="opacity:0.7">No ally equipped</p>';
  }

  // Append player + ally blocks
  playerBattleStatusDiv.appendChild(leftBlock);
  playerBattleStatusDiv.appendChild(rightBlock);

  // Stamina bar (separate and explicitly cyan)
  const staminaContainer = document.createElement('div');
  staminaContainer.className = 'hp-bar-container';
  staminaContainer.style.marginTop = '8px';
  staminaContainer.style.width = '100%';
  staminaContainer.style.height = '12px';
  staminaContainer.style.position = 'relative';

  const staminaBar = document.createElement('div');
  staminaBar.className = 'hp-bar';
  staminaBar.style.width = `${(playerStats.currentStamina / playerStats.maxStamina) * 100}%`;
  staminaBar.style.height = '100%';
  staminaBar.style.backgroundColor = '#00FFFF'; // force stamina cyan

  const staminaText = document.createElement('div');
  staminaText.className = 'hp-text';
  staminaText.textContent = `${playerStats.currentStamina}/${playerStats.maxStamina}`;

  staminaContainer.appendChild(staminaBar);
  staminaContainer.appendChild(staminaText);
  playerBattleStatusDiv.appendChild(staminaContainer);
}




  function drawPartyStatus() {
  const partyHud = document.getElementById('party');
  if (!partyHud) return;

  let statusDiv = partyHud.querySelector('.party-status');
  if (!statusDiv) {
    statusDiv = document.createElement('div');
    statusDiv.className = 'party-status';
    statusDiv.style.marginTop = '10px';
    partyHud.appendChild(statusDiv);
  }
  statusDiv.innerHTML = '';

  if (!activeAlly) {
    statusDiv.textContent = ' ';
    return;
  }

  const nameP = document.createElement('p');
  nameP.textContent = `${activeAlly.name} (Lvl ${activeAlly.level})`;
  nameP.style.fontWeight = 'bold';
  statusDiv.appendChild(nameP);

  const hpContainer = document.createElement('div');
  hpContainer.className = 'hp-bar-container';
  hpContainer.style.width = '150px';
  hpContainer.style.height = '15px';
  hpContainer.style.backgroundColor = '#555';
  hpContainer.style.border = '1px solid white';
  hpContainer.style.position = 'relative';

  const hpBar = document.createElement('div');
  hpBar.className = 'hp-bar';
  const hpPercent = (activeAlly.currentHp / activeAlly.maxHp) * 100;
  hpBar.style.width = `${hpPercent}%`;
  hpBar.style.height = '100%';
  hpBar.style.backgroundColor = '#00FF00';

  const hpText = document.createElement('div');
  hpText.className = 'hp-text';
  hpText.textContent = `${activeAlly.currentHp} / ${activeAlly.maxHp}`;
  hpText.style.position = 'absolute';
  hpText.style.top = '50%';
  hpText.style.left = '50%';
  hpText.style.transform = 'translate(-50%, -50%)';
  hpText.style.fontSize = '0.7em';
  hpText.style.textShadow = '1px 1px 2px black';
  hpText.style.userSelect = 'none';

  hpContainer.appendChild(hpBar);
  hpContainer.appendChild(hpText);
  statusDiv.appendChild(hpContainer);
}
  function startAllyAttacking() {
  if (!activeAlly) return;
  if (activeAlly.attackTimerId) clearInterval(activeAlly.attackTimerId);

  activeAlly.attackTimerId = setInterval(() => {
    if (!inBattle || !activeAlly || activeAlly.currentHp <= 0) {
      clearInterval(activeAlly.attackTimerId);
      return;
    }
    if (!activeEnemies.length) return;

    const targetEnemy = activeEnemies[selectedEnemyIndex] || activeEnemies[0];
    if (!targetEnemy) return;

    if (targetEnemy.shieldActive) {
      showTemporaryText(`${activeAlly.name}'s attack was blocked by shield!`);
    } else {
      targetEnemy.currentHp -= activeAlly.damage;
      if (targetEnemy.currentHp < 0) targetEnemy.currentHp = 0;
      showTemporaryText(`${activeAlly.name} attacks ${targetEnemy.name} for ${activeAlly.damage} damage!`);
    }

    if (targetEnemy.currentHp === 0) {
      handleEnemyDeath(targetEnemy);
      if (selectedEnemyIndex >= activeEnemies.length) selectedEnemyIndex = Math.max(0, activeEnemies.length - 1);
      drawBattleUI();
      drawPlayerBattleStatus();
      drawPartyStatus();
      if (activeEnemies.length === 0) {
        endBattle('win');
      }
    } else {
      drawBattleUI();
    }
  }, activeAlly.attackIntervalMs);
}
// Enemy behaviors
// normal enemy attack
function normalAttack(enemy, target) {
  const damage = enemy.damage || 0;
  if (target === playerStats) {
    playerTakeDamage(damage);
    showTemporaryText(`${enemy.name} attacks you for ${damage} damage!`);
  } else if (target === activeAlly) {
    activeAlly.currentHp -= damage;
    if (activeAlly.currentHp < 0) activeAlly.currentHp = 0;
    showTemporaryText(`${enemy.name} attacks ${activeAlly.name} for ${damage} damage!`);
    if (activeAlly.currentHp === 0) {
      showTemporaryText(`${activeAlly.name} has been defeated!`);
      clearInterval(activeAlly.attackTimerId);
      activeAlly.attackTimerId = null;
    }
  }
}

function sniperAttack(enemy, target) {
  const isCritical = Math.random() < 0.3;
  const damage = isCritical ? (enemy.damage * 3) : enemy.damage;
  if (target === playerStats) {
    playerTakeDamage(damage);
    showTemporaryText(`${enemy.name} ${isCritical ? 'snipes critically' : 'attacks'} for ${damage} damage!`);
  } else if (target === activeAlly) {
    activeAlly.currentHp -= damage;
    if (activeAlly.currentHp < 0) activeAlly.currentHp = 0;
    showTemporaryText(`${enemy.name} ${isCritical ? 'snipes critically' : 'attacks'} ${activeAlly.name} for ${damage} damage!`);
    if (activeAlly.currentHp === 0) {
      showTemporaryText(`${activeAlly.name} has been defeated!`);
      clearInterval(activeAlly.attackTimerId);
      activeAlly.attackTimerId = null;
    }
  }
}

function bossBehavior(enemy, target) {
  const now = Date.now();
  if (!enemy.shieldActivatedAt) enemy.shieldActivatedAt = 0;
  if (!enemy.shieldCooldownEnd) enemy.shieldCooldownEnd = 0;

  if (enemy.shieldActive) {
    if (now >= enemy.shieldActivatedAt + 2000) {
      enemy.shieldActive = false;
      enemy.shieldCooldownEnd = now + 3000;
      showTemporaryText(`${enemy.name}'s shield fades.`);
    }
  } else {
    if (now >= enemy.shieldCooldownEnd) {
      enemy.shieldActive = true;
      enemy.shieldActivatedAt = now;
      showTemporaryText(`${enemy.name} activates a shield!`);
    }
  }

  if (enemy.rocketActive && enemy.rocketTicksLeft > 0) {
    const rocketTickDamage = Math.ceil(playerStats.maxHp * 0.05);
    if (target === playerStats) {
      playerTakeDamage(rocketTickDamage);
    } else if (target === activeAlly) {
      activeAlly.currentHp -= rocketTickDamage;
      if (activeAlly.currentHp < 0) activeAlly.currentHp = 0;
      if (activeAlly.currentHp === 0) {
        showTemporaryText(`${activeAlly.name} has been defeated!`);
        clearInterval(activeAlly.attackTimerId);
        activeAlly.attackTimerId = null;
      }
    }
    enemy.rocketTicksLeft--;
    showTemporaryText(`${enemy.name}'s rocket hits ${target === playerStats ? 'you' : activeAlly.name} for ${rocketTickDamage} damage!`);
    if (enemy.rocketTicksLeft === 0) {
      enemy.rocketActive = false;
      showTemporaryText("The rocket damage ends.");
    }
  }

  if (enemy.shieldActive) return;

  if (!enemy.rocketActive && Math.random() < 0.25) {
    enemy.rocketActive = true;
    enemy.rocketTicksLeft = 4;
    showTemporaryText(`${enemy.name} launches a rocket!`);
  }

  const damage = enemy.damage || 0;
  if (target === playerStats) {
    playerTakeDamage(damage);
    showTemporaryText(`${enemy.name} attacks you for ${damage} damage!`);
  } else if (target === activeAlly) {
    activeAlly.currentHp -= damage;
    if (activeAlly.currentHp < 0) activeAlly.currentHp = 0;
    showTemporaryText(`${enemy.name} attacks ${activeAlly.name} for ${damage} damage!`);
    if (activeAlly.currentHp === 0) {
      showTemporaryText(`${activeAlly.name} has been defeated!`);
      clearInterval(activeAlly.attackTimerId);
      activeAlly.attackTimerId = null;
    }
  }
}

function summonerBehavior(enemy, target) {
  if (!enemy.lastSummonTime) enemy.lastSummonTime = 0;
  const now = Date.now();

  if (now - enemy.lastSummonTime >= 4000) {
    enemy.lastSummonTime = now;

    const minionBase = enemyTypes["Botling"];
    const minionStats = scaleEnemyStats(minionBase);
    const minion = {
      type: "Botling",
      name: minionStats.name,
      maxHp: minionStats.maxHp,
      currentHp: minionStats.maxHp,
      damage: minionStats.damage,
      xpReward: minionStats.xpReward,
      shieldActive: false,
      shieldCooldownEnd: 0,
      rocketActive: false,
      rocketTicksLeft: 0,
      stunned: false,
      poisoned: false
    };

    activeEnemies.push(minion);
    showTemporaryText(`${enemy.name} summons a minion!`);
    drawBattleUI();
  }

  if (!enemy.stunned) {
    normalAttack(enemy, target);
  }
}

function secondStageBossBehavior(enemy, target) {
  if (!enemy.stunned) {
    normalAttack(enemy, target);
  }
}

// Override endBattle to check for second stage boss
function endBattle(outcome) {
  inBattle = false;
  document.getElementById('battle-overlay').style.display = 'none';

  if (staminaRegenIntervalId) { clearInterval(staminaRegenIntervalId); staminaRegenIntervalId = null; }
  if (enemyAttackIntervalId) { clearInterval(enemyAttackIntervalId); enemyAttackIntervalId = null; }

  if (outcome === 'win') {
    let totalXp = activeEnemies.reduce((sum, enemy) => sum + (enemy.xpReward || 0), 0);

    for (const enemy of activeEnemies) {
      if (enemy.type === "SecondStageBossStage1" && enemy.currentHp <= 0) {
        // Remove stage 1 enemy and spawn stage 2 boss
        activeEnemies = activeEnemies.filter(e => e !== enemy);

        const stage2Base = enemyTypes[enemyTypes.SecondStageBossStage1.secondStageType];
        const stage2Stats = scaleEnemyStats(stage2Base);
        const stage2Enemy = {
          type: "SecondStageBossStage2",
          name: stage2Stats.name,
          maxHp: stage2Stats.maxHp,
          currentHp: stage2Stats.maxHp,
          damage: stage2Stats.damage,
          xpReward: stage2Stats.xpReward,
          shieldActive: false,
          shieldCooldownEnd: 0,
          rocketActive: false,
          rocketTicksLeft: 0,
          stunned: false,
          poisoned: false
        };

        activeEnemies.push(stage2Enemy);
        showTemporaryText(`${stage2Enemy.name} emerges!`);
        inBattle = true;
        enemyAttackIntervalId = setInterval(takeTurn, ENEMY_ATTACK_DELAY);
        drawBattleUI();
        drawPlayerBattleStatus();
        return; // Important to return early so battle continues
      }
    }

    if (activeEnemies.length === 0) {
      gainXP(totalXp);
      playerStats.currentHp = playerStats.maxHp;
      updateHp(playerStats.currentHp);
      if (defeatedZone) removeZone(defeatedZone);
      activeEnemies = [];
      defeatedZone = null;
      draw();
      document.getElementById('player-battle-status').innerHTML = '';
      return;
    }
  } else if (outcome === 'lose') {
    showGameOver();
  }
}

// Healer: heals all allies every 3 seconds
function healerBehavior(enemy) {
  if (!enemy.lastHealTime) enemy.lastHealTime = 0;
  const now = Date.now();

  if (now - enemy.lastHealTime >= 3000) {
    enemy.lastHealTime = now;

    activeEnemies.forEach(ally => {
      if (ally.currentHp < ally.maxHp) {
        const healAmount = Math.floor(ally.maxHp * 0.15); // Heals 15% max HP
        ally.currentHp += healAmount;
        if (ally.currentHp > ally.maxHp) ally.currentHp = ally.maxHp;
      }
    });
    showTemporaryText(`${enemy.name} heals all allies!`);
    drawBattleUI();
  }

  if (!enemy.stunned) {
    normalAttack(enemy);
  }
}

// Take enemy turn actions
function takeTurn() {
  if (!inBattle) return;

  passiveArmorHeal();

  activeEnemies.forEach(enemy => {
    if (!enemy.stunned) {
      let target = playerStats;
      if (activeAlly && activeAlly.currentHp > 0) {
        target = (Math.random() < 0.5) ? playerStats : activeAlly;
      }

      const behavior = enemyTypes[enemy.type]?.behavior || 'normalAttack';
if (behavior === 'normalAttack') {
  normalAttack(enemy, target);
} else if (behavior === 'sniperAttack') {
  sniperAttack(enemy, target);
} else if (behavior === 'bossBehavior') {
  bossBehavior(enemy, target);
} else if (behavior === 'summonerBehavior') {
  summonerBehavior(enemy, target);
} else if (behavior === 'secondStageBossBehavior') {
  secondStageBossBehavior(enemy, target);
} else if (behavior === 'healerBehavior') {
  healerBehavior(enemy, target);
}
    }
  if (!canGoBelow1Hp() && playerStats.currentHp <= 1) {
    playerStats.currentHp = 1;
  }
  updateHp(playerStats.currentHp);
  drawBattleUI();
  drawPlayerBattleStatus();
  drawPartyStatus();

  if (playerStats.currentHp <= 0) {
    endBattle('lose');
  }
    });
}

function enemyAttack(enemy, target) {
  const damage = enemy.damage || 0;
  if (target === playerStats) {
    playerTakeDamage(damage);
    showTemporaryText(`${enemy.name} attacks you for ${damage} damage!`);
  } else if (target === activeAlly) {
    activeAlly.currentHp -= damage;
    if (activeAlly.currentHp < 0) activeAlly.currentHp = 0;
    showTemporaryText(`${enemy.name} attacks ${activeAlly.name} for ${damage} damage!`);
    if (activeAlly.currentHp === 0) {
      showTemporaryText(`${activeAlly.name} has been defeated!`);
      clearInterval(activeAlly.attackTimerId);
      activeAlly.attackTimerId = null;
    }
  }
}
  function passiveArmorHeal() {
  if (equippedArmor && armorTypes[equippedArmor] && armorTypes[equippedArmor].passiveHealPercent) {
    const healAmount = Math.ceil(playerStats.maxHp * armorTypes[equippedArmor].passiveHealPercent);
    playerStats.currentHp = Math.min(playerStats.currentHp + healAmount, playerStats.maxHp);
    updateHp(playerStats.currentHp);
    showTemporaryText(`Passive heal: +${healAmount} HP`);
  }
}
  function playerTakeDamage(amount) {
    if (equippedArmor === "haunted") {
    const blockChance = armorTypes["haunted"].blockChance || 0;
    if (Math.random() < blockChance) {
      showTemporaryText("Haunted Armor blocked the attack!");
      return; // no damage taken
    }
    }
  playerStats.currentHp -= amount;
  if (playerStats.currentHp < 0) playerStats.currentHp = 0;
  updateHp(playerStats.currentHp);

  if (playerStats.currentHp <= 0) {
    endBattle('lose');
  }
}
  function handleEnemyDeath(enemy) {
  // award XP immediately
  if (enemy && enemy.xpReward) gainXP(enemy.xpReward);

  // cleanup behavior timers if any
  if (enemy.behaviorTimers && enemy.behaviorTimers.length) {
    enemy.behaviorTimers.forEach(id => clearInterval(id));
    enemy.behaviorTimers = [];
  }
  // remove the enemy from activeEnemies
  const idx = activeEnemies.indexOf(enemy);
  if (idx > -1) activeEnemies.splice(idx, 1);

  // update UI and check end of battle
  drawBattleUI();
  drawPlayerBattleStatus();

  // if no enemies remain, finish the battle
  if (activeEnemies.length === 0) {
    endBattle('win');
  }
}
    
function healAllyAfterBattle() {
  if (activeAlly && activeAlly.currentHp > 0) {
    const healAmount = Math.ceil(activeAlly.maxHp * 0.33);
    activeAlly.currentHp = Math.min(activeAlly.currentHp + healAmount, activeAlly.maxHp);
    showTemporaryText(`${activeAlly.name} healed for ${healAmount} HP after battle.`);
  }
}
// End battle and clean up
function endBattle(outcome) {
  inBattle = false;
  document.getElementById('battle-overlay').style.display = 'none';

  if (staminaRegenIntervalId) { clearInterval(staminaRegenIntervalId); staminaRegenIntervalId = null; }
  if (enemyAttackIntervalId) { clearInterval(enemyAttackIntervalId); enemyAttackIntervalId = null; }
  if (activeAlly && activeAlly.attackTimerId) {
    clearInterval(activeAlly.attackTimerId);
    activeAlly.attackTimerId = null;
  }

  if (outcome === 'win') {
    let totalXp = activeEnemies.reduce((sum, enemy) => sum + (enemy.xpReward || 0), 0);
    gainXP(totalXp);
    playerStats.currentHp = playerStats.maxHp;
    updateHp(playerStats.currentHp);
    if (defeatedZone) removeZone(defeatedZone);

    healAllyAfterBattle();
  } else if (outcome === 'lose') {
    showGameOver();
  }

  activeEnemies = [];
  defeatedZone = null;
  activeAlly = null;
  draw();
  drawPartyStatus();
  const pbs = document.getElementById('player-battle-status');
  if (pbs) pbs.innerHTML = "";
}

function initiateBattle(zoneType, zoneObject) {
  inBattle = true;
  defeatedZone = { type: zoneType, object: zoneObject };

  staminaRegenIntervalId = setInterval(() => {
    updateStamina(playerStats.currentStamina + 1);
    drawPlayerBattleStatus();
  }, 100);

  const encounter = (zoneObject && zoneObject.encounter) || [];

  // Build activeEnemies using scaled stats that respect difficulty
  activeEnemies = encounter.map(enemyData => {
    const baseStats = enemyTypes[enemyData.type] || {};

    // scale base stats according to current level and difficulty
    const scaled = scaleEnemyStats(baseStats);

    const maxHp = scaled.maxHp != null ? scaled.maxHp : (enemyData.maxHp || 1);
    const damage = scaled.damage != null ? scaled.damage : (enemyData.damage || 1);

    const enemy = {
      // preserve provided spawn overrides but prefer scaled values
      ...enemyData,
      type: enemyData.type,
      name: baseStats.name || enemyData.type,
      maxHp: Math.max(1, maxHp),
      currentHp: Math.max(1, maxHp),
      damage: Math.max(0, damage),
      xpReward: baseStats.xpReward || enemyData.xpReward || 0,
      shieldActive: false,
      shieldCooldownEnd: 0,
      rocketActive: false,
      rocketTicksLeft: 0,
      stunned: false,
      poisoned: false,
      resistances: (enemyData.resistances || baseStats.defaultResistances) || { stun: false, poison: false },
      isBoss: !!baseStats.isBoss
    };

    // boss-specific initial state
    if (enemy.isBoss) {
      enemy.shieldActivatedAt = 0;
      enemy.shieldCooldownEnd = 0;
      enemy.rocketActive = false;
      enemy.rocketTicksLeft = 0;
    }

    return enemy;
  });

  // Setup activeAlly data from equipped ally
  if (equippedAllyId && unlockedAllies.has(equippedAllyId)) {
    const allyBase = alliesData.find(a => a.id === equippedAllyId);
    activeAlly = {
      id: allyBase.id,
      name: allyBase.name,
      maxHp: allyBase.baseMaxHp,
      currentHp: allyBase.baseMaxHp,
      damage: allyBase.baseDamage,
      attackIntervalMs: allyBase.attackIntervalMs,
      level: allyBase.level,
      xp: allyBase.xp,
      xpToNextLevel: allyBase.xpToNextLevel,
      attackTimerId: null
    };
    startAllyAttacking();
    drawPartyStatus();
  } else {
    activeAlly = null;
  }

  selectedEnemyIndex = 0;
  drawBattleUI();
  drawPlayerBattleStatus();
  if (enemyAttackIntervalId) clearInterval(enemyAttackIntervalId);
  enemyAttackIntervalId = setInterval(takeTurn, ENEMY_ATTACK_DELAY);
}


  // Unlock an ally and update UI/save state
function unlockAlly(allyId) {
  if (!allyId) return;
  if (unlockedAllies.has(allyId)) {
    showTemporaryText(`${alliesData.find(a => a.id === allyId)?.name || allyId} is already unlocked.`);
    return;
  }
  const ally = alliesData.find(a => a.id === allyId);
  if (!ally) {
    console.warn('unlockAlly: unknown allyId', allyId);
    showTemporaryText('Unknown ally.');
    return;
  }

  unlockedAllies.add(allyId);
  // Auto-equip if nothing equipped yet
  if (!equippedAllyId) {
    equippedAllyId = allyId;
    showTemporaryText(`${ally.name} has joined and was auto-equipped.`);
  } else {
    showTemporaryText(`${ally.name} has joined your party!`);
  }

  drawPartyList();
  drawPartyStatus();
}

// Check collision with interactables
function checkInteraction(checkX, checkY) {
  const hitboxX = checkX + hitboxOffsetX;
  const hitboxY = checkY + hitboxOffsetY;
  if (!currentLevel.interactables) return null;
  for (const object of currentLevel.interactables) {
    const r = object.interactRect || { x: object.x, y: object.y, width: object.width, height: object.height };
    if (
      hitboxX < r.x + r.width &&
      hitboxX + hitboxWidth > r.x &&
      hitboxY < r.y + r.height &&
      hitboxY + hitboxHeight > r.y
    ) return object;
  }
  return null;
}


// Handle interaction actions
function handleInteraction(object) {
  if (!object) return;
  // inside handleInteraction(object) add a branch for action === "recruit"
if (object.action === "recruit") {
  // optional short dialog before unlocking
  const preText = object.recruitDialog || [`You meet ${object.displayName || 'someone'}.`, 'They might help you.'];
  // showDialog accepts text or lines; here we mark the dialog id so it's not retriggered
  showDialog(preText, object.id, { style: object.dialogStyle || 'dialog', speaker: object.speaker || null });

  // unlock immediately so the player can equip right away after dialog closes
  // store the allyId on the object as object.allyId (set in level data)
  if (object.allyId) {
    // if you want the unlock to happen only after dialog confirmed, move this call into dialog-next handler by checking overlay._markId
    unlockAlly(object.allyId);
  } else {
    console.warn('recruit object missing allyId', object);
    showTemporaryText('Nothing happened.');
  }

  // remove the interactable so it can't be recruited repeatedly
  currentLevel.interactables = currentLevel.interactables.filter(o => o !== object);
  draw();
  return;
}


  if (object.action === "use_drill") {
  if ((inventory.get("drill") || 0) > 0) {
    showTemporaryText("You use the drill to break through the crack!");
    loadLevel(object.destLevel, object.destX, object.destY);
  } else {
    showTemporaryText("You need a drill to break through here.");
  }
  return;
}

  if (object.requiresKeycard) {
    if ((inventory.get('keycard') || 0) > 0) {
      showTemporaryText("You used a keycard to activate this.");
      // Implement whatever action keycard triggers here, e.g., open door, disable alarm
      if (object.action === 'open_door') {
        loadLevel(object.destLevel, object.destX, object.destY);
      }
      // Remove or disable object after use if needed
      currentLevel.interactables = currentLevel.interactables.filter(o => o !== object);
      draw();
    } else {
      showTemporaryText("You need a keycard to use this.");
    }
    return;
  }
  if (object.action === "password_door") {
  openPasswordPopup(object);
  return;
}
  
  if (object.name === "power_box") {
    if (!isPowered) {
      isPowered = true;
      showTemporaryText("You pressed something on the box. The lights flicker on.");
      draw();
    } else {
      showTemporaryText("The power is already on.");
    }
    return;
  }

  if (object.name === "arcade_machine") {
    if (isPowered) {
      initiateBattle('interactable', object);
    } else {
      showTemporaryText("The machine is turned off ...");
    }
    return;
  }

  if (object.action === "break") {
  const tool = object.requiredItem;
  if ((inventory.get(tool) || 0) > 0) {
    currentLevel.interactables = currentLevel.interactables.filter(o => o !== object);
    currentLevel.walls = currentLevel.walls.filter(w =>
      !(w.x === object.x && w.y === object.y && w.width === object.width && w.height === object.height)
    );
    // Show message based on tool used
    if (tool === "laser_cutter") {
      showTemporaryText("You cut through the steel block!");
    } else if (tool === "hammer") {
      showTemporaryText("You smashed the stone!");
    } else {
      showTemporaryText("You broke the obstacle!");
    }
    draw();
  } else {
    showTemporaryText(`You need a ${tool.replace('_', ' ')} to break this.`);
  }
  return;
}
  
if (object.action === "chest") {
  // if already opened, show a short message and return
  if (object.opened) {
    showDialog("The chest is empty.", null, { speaker: null });
    return;
  }

  // mark opened so it won't grant again
  object.opened = true;

  // grant rewards (rewards is array of [key, qty])
  const rewardLines = [];
  if (Array.isArray(object.rewards)) {
    for (const [key, qty] of object.rewards) {
      const current = inventory.get(key) || 0;
      inventory.set(key, current + (qty || 1));
      rewardLines.push(`+${qty || 1} ${key}`);
    }
  }

  // Build a dialog that lists all rewards (guaranteed)
  const dialogText = ["You opened the chest!", "You received:"].concat(rewardLines);
  showDialog(dialogText, object.id, { speaker: null });

  // optionally update UI immediately
  draw();
  return;
}

  if (object.action === "pickup") {
    const key = object.itemName;
    const current = inventory.get(key) || 0;
    inventory.set(key, current + 1);
    currentLevel.interactables = currentLevel.interactables.filter(o => o !== object);
    currentLevel.walls = currentLevel.walls.filter(w =>
      !(w.x === object.x && w.y === object.y && w.width === object.width && w.height === object.height)
    );
    showTemporaryText(`Picked up a ${key}!`);
    return;
  }
}

// Attack buttons event listeners
document.getElementById('attack-button').addEventListener('click', () => {
  if (!inBattle || !activeEnemies.length) return;
  const targetEnemy = activeEnemies[selectedEnemyIndex];
  if (!targetEnemy) return;

  if (targetEnemy.shieldActive) {
    showTemporaryText(`${targetEnemy.name}'s shield blocks your attack!`);
  } else {
    // Always deal damage regardless of poison status
    targetEnemy.currentHp -= playerStats.damage;
    if (targetEnemy.currentHp < 0) targetEnemy.currentHp = 0;
  }
  if (targetEnemy.currentHp === 0) {
    handleEnemyDeath(targetEnemy);
    // adjust selected index if needed
    if (selectedEnemyIndex >= activeEnemies.length) selectedEnemyIndex = Math.max(0, activeEnemies.length - 1);
    return;
  }

  // Remove dead enemies
  activeEnemies = activeEnemies.filter(enemy => enemy.currentHp > 0);

  // If no enemies left, end battle
  if (activeEnemies.length === 0) {
    endBattle('win');
    return;
  }

  drawBattleUI();
  drawPartyStatus();
  drawPlayerBattleStatus();
});

document.getElementById('special-attack-button-1').addEventListener('click', () => {
  const staminaCost = 100;
  if (!inBattle || !activeEnemies.length || playerStats.currentStamina < staminaCost) {
    showTemporaryText("Not enough stamina!");
    return;
  }
  updateStamina(playerStats.currentStamina - staminaCost);
  const targetEnemy = activeEnemies[selectedEnemyIndex];
  if (!targetEnemy) return;
  targetEnemy.currentHp -= (playerStats.damage * 10);
  if (targetEnemy.currentHp < 0) targetEnemy.currentHp = 0;
  if (targetEnemy.currentHp === 0) {
    handleEnemyDeath(targetEnemy);
    // adjust selected index if needed
    if (selectedEnemyIndex >= activeEnemies.length) selectedEnemyIndex = Math.max(0, activeEnemies.length - 1);
    return;
  }
  let remainingEnemies = activeEnemies.filter(enemy => enemy.currentHp > 0);
  if (remainingEnemies.length === 0) {
    endBattle('win');
    return;
  }
  activeEnemies = remainingEnemies;
  if (selectedEnemyIndex >= activeEnemies.length) selectedEnemyIndex = 0;
  drawBattleUI();
  drawPartyStatus();
  drawPlayerBattleStatus();
});

document.getElementById('special-attack-button-2').addEventListener('click', () => {
  const staminaCost = 200;
  if (!inBattle || playerStats.currentStamina < staminaCost) {
    showTemporaryText("Not enough stamina!");
    return;
  }
  updateStamina(playerStats.currentStamina - staminaCost);

  if (equippedWeapon === "virus") {
    // Virus weapon special attack: example - hits all enemies with  damage + poison effect
    activeEnemies.forEach(enemy => {
      enemy.currentHp -= playerStats.damage * 30;
      if (enemy.currentHp < 0) enemy.currentHp = 0;

      // Apply poison if not boss
      if (!enemy.isBoss && !enemy.poisoned) {
        enemy.poisoned = false;
        // Start poison interval here similar to poison vial effect
        // (You can reuse your poison vial code here)
      }
    });
  } else {
    // Default special attack: damage all enemies with 20x damage (as your current code)
    activeEnemies.forEach(enemy => {
      enemy.currentHp -= playerStats.damage * 20;
      if (enemy.currentHp < 0) enemy.currentHp = 0;
    });
  }

  // Remove dead enemies
  activeEnemies = activeEnemies.filter(enemy => enemy.currentHp > 0);

  if (activeEnemies.length === 0) {
    endBattle('win');
    return;
  }
  if (selectedEnemyIndex >= activeEnemies.length) selectedEnemyIndex = 0;
  drawBattleUI();
  drawPartyStatus();
  drawPlayerBattleStatus();
});

// Handle enemy selection click
document.getElementById('enemy-display').addEventListener('click', (event) => {
  const button = event.target.closest('.enemy-target');
  if (button) {
    selectedEnemyIndex = parseInt(button.dataset.enemyIndex);
    drawBattleUI();
  }
});

// Stats popup toggle
document.getElementById('stats-button').addEventListener('click', () => {
  if (statsPopup.style.display === 'none') {
    updateStatsPopup();
    statsPopup.style.display = 'block';
  } else {
    statsPopup.style.display = 'none';
  }
});

updateHp(playerStats.currentHp);

// Inventory button in battle toggle
document.getElementById('inventory-battle-button').addEventListener('click', () => {
  const inventoryPopupBattle = document.getElementById('inventory-battle-popup');
  if (inventoryPopupBattle.style.display === 'none') {
    drawInventoryBattlePopup();
    inventoryPopupBattle.style.display = 'block';
  } else {
    inventoryPopupBattle.style.display = 'none';
  }
});

  document.getElementById('dialog-next').addEventListener('click', () => {
  const overlay = document.getElementById('dialog-overlay');
  const box = document.getElementById('dialog-box');
  const textDiv = document.getElementById('dialog-text');

  if (_dialogQueue.length > 0) {
    const line = _dialogQueue.shift();
    applyDialogStyle(box, line.style);
    if (line.speaker) {
      textDiv.innerHTML = `<strong>${line.speaker}</strong>\n\n${line.text}`;
    } else {
      textDiv.textContent = line.text;
    }
    return;
  }

  const id = overlay._markId;
  overlay._markId = null;
  overlay.style.display = 'none';
  draw();
  if (id) shownDialogs.add(id);
});

document.addEventListener('keydown', function(e) {
  if (isGameOver && e.key.toLowerCase() === 'r') {
    location.reload();
  }
});

function loadLevel(index, newX = x, newY = y) {
  currentLevelIndex = index;
  currentLevel = levels[currentLevelIndex];

  bgImg = new Image();
  bgImg.onload = () => draw();
  bgImg.src = currentLevel.bgSrc;

  x = newX;
  y = newY;

  draw();
}

function isInZone(zones, px, py) {
  if (!zones) return false;
  const hitboxX = px + hitboxOffsetX;
  const hitboxY = py + hitboxOffsetY;
  for (const zone of zones) {
    if (
      hitboxX < zone.x + zone.width &&
      hitboxX + hitboxWidth > zone.x &&
      hitboxY < zone.y + zone.height &&
      hitboxY + hitboxHeight > zone.y
    ) {
      return true;
    }
  }
  return false;
}

function isInWater(px, py) {
  return isInZone(currentLevel.waterZones, px, py);
}

function isInPoison(px, py) {
  return isInZone(currentLevel.poisonZones, px, py);
}

// Wall collision detection
function isCollidingWithWall(newX, newY) {
  const newHitboxX = newX + hitboxOffsetX;
  const newHitboxY = newY + hitboxOffsetY;
  for (const wall of currentLevel.walls) {
    if (
      newHitboxX < wall.x + wall.width &&
      newHitboxX + hitboxWidth > wall.x &&
      newHitboxY < wall.y + wall.height &&
      newHitboxY + hitboxHeight > wall.y
    ) {
      return true;
    }
  }
  return false;
}

// Door collision detection
function checkDoorCollision(newX, newY) {
  const newHitboxX = newX + hitboxOffsetX;
  const newHitboxY = newY + hitboxOffsetY;
  for (const door of currentLevel.doors) {
    if (
      newHitboxX < door.x + door.width &&
      newHitboxX + hitboxWidth > door.x &&
      newHitboxY < door.y + door.height &&
      newHitboxY + hitboxHeight > door.y
    ) {
      return door;
    }
  }
  return null;
}

// Draw game world and player
function draw() {
  if (inBattle || isGameOver) return;

  // clear canvas first
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  // draw background only when the image is ready
  if (bgImg && bgImg.complete && bgImg.naturalWidth > 0) {
    ctx.drawImage(bgImg, 0, 0, canvas.width, canvas.height);
  } else {
    // optional: fill a temporary background so canvas isn't visually stale
    ctx.fillStyle = "#737373";
    ctx.fillRect(0, 0, canvas.width, canvas.height);
  }
  ctx.fillStyle = "rgba(0,0,0,0.0)";
  for (const wall of currentLevel.walls) {
    ctx.fillRect(wall.x, wall.y, wall.width, wall.height);
  }
  if (currentLevel && currentLevel.battleZones) {
  currentLevel.battleZones.forEach(zone => {
    if (!zone.sprite) return;
    const sprite = zoneSprites[zone.sprite];
    if (!sprite) return;
    // determine dest rect: scale down or up as you like
    const spriteW = Math.min(zone.width, 100); // cap to avoid oversized sprites
    const spriteH = Math.min(zone.height, 100);
    const destX = zone.x + (zone.width - spriteW) / 2;
    const destY = zone.y + (zone.height - spriteH) / 2;
    if (sprite.complete && sprite.naturalWidth > 0) {
      ctx.drawImage(sprite, destX, destY, spriteW, spriteH);
    } else {
      // fallback visual while sprite loads
      ctx.fillStyle = 'rgba(255,0,0,0.0)';
      ctx.fillRect(destX, destY, spriteW, spriteH);
    }
  });
}
  if (useImage && img.complete && img.naturalWidth > 0) {
    ctx.drawImage(img, x, y, imageSize, imageSize);
  } else {
    ctx.fillStyle = "#0090ff";
    ctx.fillRect(x, y, imageSize, imageSize);
  }
  ctx.fillStyle = "rgba(0,0,0,0.0)";
  ctx.fillRect(x + hitboxOffsetX, y + hitboxOffsetY, hitboxWidth, hitboxHeight);

  if (tempText) {
    ctx.fillStyle = "white";
    ctx.font = "12px 'Press Start 2P'";
    ctx.textAlign = "center";
    const maxWidth = canvas.width - 40;
    const lineHeight = 15;
    const startY = canvas.height - 100;
    wrapText(ctx, tempText, canvas.width / 2, startY, maxWidth, lineHeight);
  }
// in draw(), after drawing normal walls and interactables add:
if (gameSettings.showZones) {
  // walls outline
  ctx.save();
  ctx.strokeStyle = 'rgba(255,255,0,0.9)';
  ctx.lineWidth = 2;
  currentLevel.walls.forEach(w => {
    ctx.strokeRect(w.x + 0.5, w.y + 0.5, w.width, w.height);
  });
  // interactable boxes
  ctx.strokeStyle = 'rgba(0,255,255,0.9)';
  currentLevel.interactables.forEach(obj => {
    ctx.strokeRect(obj.x + 0.5, obj.y + 0.5, obj.width, obj.height);
  });
  // battle zones
  ctx.strokeStyle = 'rgba(255,0,0,0.9)';
  (currentLevel.battleZones || []).forEach(z => {
    ctx.strokeRect(z.x + 0.5, z.y + 0.5, z.width, z.height);
  });
  ctx.restore();
}

  currentLevel.interactables.forEach(obj => {
  if (obj.action === "pickup") {
    // Draw key items with their images
    let imgToDraw = null;
    if (obj.name === "hammer") imgToDraw = hammerImg;
    else if (obj.name === "keycard") imgToDraw = keycardImg;
    else if (obj.name === "gas_mask") imgToDraw = gasMaskImg;
    else if (obj.name === "laser_cutter") imgToDraw = laserCutterImg;
    else if (obj.name === "raft") imgToDraw = raftImg;
    else if (obj.name === "torch") imgToDraw = torchImg;
    else if (obj.name === "drill") imgToDraw = drillImg;

    if (imgToDraw && imgToDraw.complete) {
      ctx.drawImage(imgToDraw, obj.x, obj.y, obj.width, obj.height);
    } else {
      ctx.fillStyle = "#cc9900"; // fallback color
      ctx.fillRect(obj.x, obj.y, obj.width, obj.height);
    }
  } else if (obj.action === "break" && obj.name === "steel_block") {
    if (steelBlockImg.complete) {
      ctx.drawImage(steelBlockImg, obj.x, obj.y, obj.width, obj.height);
    } else {
      ctx.fillStyle = "#888"; // fallback gray
      ctx.fillRect(obj.x, obj.y, obj.width, obj.height);
    }
  }
});
// inside draw(), where you draw interactables
currentLevel.interactables.forEach(obj => {
  if (obj.action === "chest") {
    if (obj.opened) {
      // open chest sprite (or fallback)
      if (openChestImg && openChestImg.complete) ctx.drawImage(openChestImg, obj.x, obj.y, obj.width, obj.height);
      else { ctx.fillStyle = "#775533"; ctx.fillRect(obj.x, obj.y, obj.width, obj.height); }
    } else {
      // closed chest sprite (or fallback)
      if (closedChestImg && closedChestImg.complete) ctx.drawImage(closedChestImg, obj.x, obj.y, obj.width, obj.height);
      else { ctx.fillStyle = "#aa7722"; ctx.fillRect(obj.x, obj.y, obj.width, obj.height); }
    }
  }
});
  if (currentLevel.waterZones) {
  ctx.fillStyle = "rgba(0, 0, 255, 0.9)";
  currentLevel.waterZones.forEach(zone => {
    ctx.fillRect(zone.x, zone.y, zone.width, zone.height);
  });
}
function isInDarkZone(px, py) {
  if (!currentLevel.darkZones) return false;
  const hitboxX = px + hitboxOffsetX;
  const hitboxY = py + hitboxOffsetY;
  for (const zone of currentLevel.darkZones) {
    if (
      hitboxX < zone.x + zone.width &&
      hitboxX + hitboxWidth > zone.x &&
      hitboxY < zone.y + zone.height &&
      hitboxY + hitboxHeight > zone.y
    ) {
      return true;
    }
  }
  return false;
}
// Draw poison zones
if (currentLevel.poisonZones) {
  ctx.fillStyle = "rgba(0, 255, 0, 0.4)"; // semi-transparent green
  currentLevel.poisonZones.forEach(zone => {
    ctx.fillRect(zone.x, zone.y, zone.width, zone.height);
  });
}
  // After all normal drawing is done
if (isInDarkZone(x, y) && (inventory.get("torch") || 0) <= 0) {
  // Draw solid black overlay to simulate darkness
  ctx.fillStyle = "black";
  ctx.fillRect(0, 0, canvas.width, canvas.height);
}

  // draw smashable stones (name matches what you added earlier)
  currentLevel.interactables.forEach(obj => {
    if (obj.name === "big_stone" || obj.name === "bigStone") {
      if (stoneImg.complete) ctx.drawImage(stoneImg, obj.x, obj.y, obj.width, obj.height);
      else { ctx.fillStyle = "#888"; ctx.fillRect(obj.x, obj.y, obj.width, obj.height); }
    }
  });
}

  // === Settings storage and defaults ===
const SETTINGS_KEY = '8bitsAdventureSettings';
const SAVE_SLOT_PREFIX = '8bitsAdventureSave_slot_'; // followed by 1,2,3

const defaultSettings = {
  difficulty: 'normal', // normal | hard | ultimate
  showZones: false // false by default
};

let gameSettings = Object.assign({}, defaultSettings);

// load settings on start
function loadSettings() {
  try {
    const raw = localStorage.getItem(SETTINGS_KEY);
    if (raw) {
      const parsed = JSON.parse(raw);
      Object.assign(gameSettings, parsed);
    }
  } catch (e) {
    console.error('Failed to load settings', e);
  }
  // apply UI initial values
  const sel = document.getElementById('difficulty-select');
  const chk = document.getElementById('toggle-zones');
  if (sel) sel.value = gameSettings.difficulty || 'normal';
  if (chk) chk.checked = !!gameSettings.showZones;
}
function saveSettings() {
  try {
    localStorage.setItem(SETTINGS_KEY, JSON.stringify(gameSettings));
  } catch (e) {
    console.error('Failed to save settings', e);
  }
}

// === Save slot helpers ===
function saveToSlot(slotNumber) {
  const key = SAVE_SLOT_PREFIX + slotNumber;
  const allInteractables = levels.map(level => (level.interactables || []).map(obj => ({ ...obj })));
  const saveData = {
    playerStats,
    inventory: Array.from(inventory.entries()),
    currentLevelIndex,
    playerPosition: { x, y },
    allInteractables,
    shownDialogs: Array.from(shownDialogs),
    unlockedAllies: Array.from(unlockedAllies),
    settings: gameSettings
  };
  localStorage.setItem(key, JSON.stringify(saveData));
  showTemporaryText(`Saved to slot ${slotNumber}`);
}
function loadFromSlot(slotNumber) {
  const key = SAVE_SLOT_PREFIX + slotNumber;
  const raw = localStorage.getItem(key);
  if (!raw) {
    showTemporaryText(`No save in slot ${slotNumber}`);
    return;
  }
  try {
    const saveData = JSON.parse(raw);
    Object.assign(playerStats, saveData.playerStats);
    inventory.clear();
    saveData.inventory.forEach(([k, v]) => inventory.set(k, v));
    if (Array.isArray(saveData.allInteractables)) {
      saveData.allInteractables.forEach((arr, idx) => {
        if (levels[idx]) levels[idx].interactables = arr.map(o => ({ ...o }));
      });
    }
    shownDialogs = new Set(saveData.shownDialogs || []);
    unlockedAllies = new Set(saveData.unlockedAllies || []);
    // restore settings from save if present
    if (saveData.settings) {
      Object.assign(gameSettings, saveData.settings);
      const sel = document.getElementById('difficulty-select');
      const chk = document.getElementById('toggle-zones');
      if (sel) sel.value = gameSettings.difficulty;
      if (chk) chk.checked = !!gameSettings.showZones;
    }
    loadLevel(saveData.currentLevelIndex, saveData.playerPosition.x, saveData.playerPosition.y);
    drawPartyList();
    drawPartyStatus();
    updateHp(playerStats.currentHp);
    updateStatsPopup();
    showTemporaryText(`Loaded slot ${slotNumber}`);
  } catch (e) {
    console.error('Failed to load slot', e);
    showTemporaryText('Failed to load save');
  }
}

// === Hook up settings UI buttons ===
document.getElementById('save-slot-1').addEventListener('click', () => saveToSlot(1));
document.getElementById('save-slot-2').addEventListener('click', () => saveToSlot(2));
document.getElementById('save-slot-3').addEventListener('click', () => saveToSlot(3));
document.getElementById('load-slot-1').addEventListener('click', () => loadFromSlot(1));
document.getElementById('load-slot-2').addEventListener('click', () => loadFromSlot(2));
document.getElementById('load-slot-3').addEventListener('click', () => loadFromSlot(3));

// difficulty selector
document.getElementById('difficulty-select').addEventListener('change', (e) => {
  gameSettings.difficulty = e.target.value;
  saveSettings();
  showTemporaryText(`Difficulty set to ${gameSettings.difficulty}`);
});

// toggle zones
document.getElementById('toggle-zones').addEventListener('change', (e) => {
  gameSettings.showZones = !!e.target.checked;
  saveSettings();
  draw(); // redraw overlays
});

// initialize settings on load
loadSettings();

// Save game state to localStorage
function saveGame() {
  // Save interactables for all levels
  const allInteractables = levels.map(level => {
    // Save a deep copy of interactables array for each level
    return level.interactables.map(obj => ({ ...obj }));
  });

  const saveData = {
  playerStats,
  inventory: Array.from(inventory.entries()),
  currentLevelIndex,
  playerPosition: { x, y },
  allInteractables,
  shownDialogs: Array.from(shownDialogs),
  unlockedAllies: Array.from(unlockedAllies)
};

  localStorage.setItem('8bitsAdventureSave', JSON.stringify(saveData));
  showTemporaryText('Game saved!');
  console.log('Game saved:', saveData);
}

// Load game state from localStorage
function loadGame() {
  const saved = localStorage.getItem('8bitsAdventureSave');
  if (!saved) {
    showTemporaryText('No saved game found.');
    console.log('No saved game found.');
    return;
  }

  try {
    const saveData = JSON.parse(saved);
    Object.assign(playerStats, saveData.playerStats);
    inventory.clear();
    saveData.inventory.forEach(([key, value]) => inventory.set(key, value));

    // Restore interactables for all levels
    if (Array.isArray(saveData.allInteractables)) {
      saveData.allInteractables.forEach((interactablesArr, index) => {
        if (levels[index]) {
          levels[index].interactables = interactablesArr.map(obj => ({ ...obj }));
        }
      });
    }

    rebuildWalls ();

    loadLevel(saveData.currentLevelIndex, saveData.playerPosition.x, saveData.playerPosition.y);

    if (Array.isArray(saveData.shownDialogs)) {
      shownDialogs = new Set(saveData.shownDialogs);
    }
    if (Array.isArray(saveData.unlockedAllies)) {
  unlockedAllies = new Set(saveData.unlockedAllies);
} else {
  unlockedAllies = new Set();
}
drawPartyList();
drawPartyStatus();


    updateHp(playerStats.currentHp);
    updateStatsPopup();
    showTemporaryText('Game loaded!');
    console.log('Game loaded:', saveData);

  } catch (e) {
    console.error('Failed to load save:', e);
    showTemporaryText('Failed to load save.');
  }
}

  function rebuildWalls() {
  // For each level, remove walls that correspond to missing interactables (broken objects)
  levels.forEach(level => {
    if (!level.walls || !level.interactables) return;

    // Collect all interactable bounding boxes that block movement (breakable objects)
    const interactableRects = level.interactables.map(obj => ({
      x: obj.x,
      y: obj.y,
      width: obj.width,
      height: obj.height
    }));

    // Filter walls: keep only those that do NOT overlap any interactable bounding box
    level.walls = level.walls.filter(wall => {
      return !interactableRects.some(rect => {
        return (
          wall.x === rect.x &&
          wall.y === rect.y &&
          wall.width === rect.width &&
          wall.height === rect.height
        );
      });
    });
  });
}

// Create Save and Load buttons after DOM is ready (script at bottom so safe)
const gameHud = document.getElementById('game-hud');
if (gameHud) {
  const saveButton = document.createElement('button');
  saveButton.textContent = 'Save Game';
  saveButton.style.fontFamily = "'Press Start 2P', sans-serif";
  saveButton.style.margin = '0 10px';
  saveButton.onclick = saveGame;
  gameHud.appendChild(saveButton);

  const loadButton = document.createElement('button');
  loadButton.textContent = 'Load Game';
  loadButton.style.fontFamily = "'Press Start 2P', sans-serif";
  loadButton.style.margin = '0 10px';
  loadButton.onclick = loadGame;
  gameHud.appendChild(loadButton);
}
  
// Keyboard movement and interaction
canvas.addEventListener('keydown', function(e) {
  if (inBattle || isGameOver) return;
  let nextX = x, nextY = y;
  const key = e.key.toLowerCase();

  // movement keys: prevent default for arrows/wasd
  if (['arrowup','arrowdown','arrowleft','arrowright','w','a','s','d'].includes(key)) {
    e.preventDefault();
  }

  if (key === 'x') {
    e.preventDefault();
    const interactableObject =
      checkInteraction(x - 16, y) ||
      checkInteraction(x + 16, y) ||
      checkInteraction(x, y - 16) ||
      checkInteraction(x, y + 16) ||
      checkInteraction(x, y);
    if (interactableObject) handleInteraction(interactableObject);
    return;
  }

  if (key === 'arrowleft' || key === 'a') nextX -= speed;
  if (key === 'arrowright' || key === 'd') nextX += speed;
  if (key === 'arrowup' || key === 'w') nextY -= speed;
  if (key === 'arrowdown' || key === 's') nextY += speed;

  // Check water crossing
  if (isInWater(nextX, nextY) && (inventory.get('raft') || 0) <= 0) {
    showTemporaryText("You need a raft to cross water!");
    return;
  }

  // Check poison crossing
  if (isInPoison(nextX, nextY) && (inventory.get('gas_mask') || 0) <= 0) {
    showTemporaryText("You need a gas mask to cross poison!");
    return;
  }

  // Existing collision checks
  if (!isCollidingWithWall(nextX, nextY)) {
    const door = checkDoorCollision(nextX, nextY);
    if (door) {
      loadLevel(door.destLevel, door.destX, door.destY);
      return;
    }

    const battleZone = findBattleZone(nextX, nextY);
    if (battleZone) {
      initiateBattle('battleZone', battleZone);
      return;
    }

    // move player
    x = nextX;
    y = nextY;

    // dialog auto-trigger (autoShow only)
    const dialogZone = findDialogZone(nextX, nextY);
    if (dialogZone && dialogZone.autoShow) {
      showDialog(dialogZone.text, dialogZone.id, { style: dialogZone.style || 'dialog', speaker: dialogZone.speaker || null });
      return;
    }
  }

  draw();
});
  </script>
</body>
</html>
