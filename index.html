<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>8Bitâ€™s Adventure</title>
  <link rel="icon" type="image/png" href="favicon.png">
  <!-- Google Font: Press Start 2P -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
  <style>
    body {
      background: #333;
      color: white;
      font-family: "Press Start 2P", sans-serif;
      text-align: center;
      margin: 0;
    }
    canvas {
      background: #737373;
      display: block;
      margin: 2em auto;
      border: 2px solid white;
    }
    #game-hud {
      position: fixed;
      bottom: 0;
      left: 0;
      width: 100%;
      background-color: #002591;
      color: white;
      display: flex;
      justify-content: space-around;
      align-items: center;
      padding: 10px;
      box-sizing: border-box;
      border-top: 2px solid black;
    }
    .hud-section {
      text-align: center;
      padding: 0 1em;
    }
    #player-status {
      display: flex;
      align-items: center;
      gap: 10px;
    }
    #hp-bar-container {
      width: 150px;
      height: 20px;
      background-color: #555;
      border: 1px solid white;
      position: relative;
    }
    #hp-bar {
      width: 100%;
      height: 100%;
      background-color: #00FF00;
      transition: width 0.5s linear;
    }
    #hp-text {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 0.8em;
      text-shadow: 1px 1px 2px black;
    }
    #battle-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.8);
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      display: none;
    }
    #enemy-display {
      background-color: #555;
      padding: 20px;
      border: 2px solid white;
      margin-bottom: 20px;
      display: flex;
      gap: 10px;
    }
    #enemy-display button {
      background-color: #333;
      color: white;
      border: 1px solid white;
      cursor: pointer;
      padding: 10px;
      font-family: "Press Start 2P", sans-serif;
    }
    #enemy-display button.selected {
      border: 2px solid yellow;
      background-color: #555;
    }
    #battle-controls button {
      font-family: "Press Start 2P", sans-serif;
      padding: 10px 20px;
      cursor: pointer;
    }
    #player-battle-status {
      background-color: #002591;
      color: white;
      border: 2px solid black;
      padding: 10px;
      margin-top: 20px;
      width: 250px;
      text-align: left;
    }
    #player-battle-status p {
      margin: 0;
      font-size: 1em;
    }
    #player-battle-status .hp-bar-container {
      width: 100%;
      height: 15px;
      background-color: #555;
      border: 1px solid white;
      position: relative;
    }
    #player-battle-status .hp-bar {
      height: 100%;
      background-color: #00FF00;
    }
    #stats {
      position: relative;
    }
    .stats-popup {
      position: absolute;
      bottom: 100%;
      left: 0;
      width: 200px;
      background-color: #002591;
      border: 2px solid black;
      padding: 10px;
      color: white;
      text-align: left;
      z-index: 1000;
    }
    #player-battle-status .hp-bar-container:last-of-type .hp-bar {
      background-color: #00FFFF;
    }
    #player-battle-status .hp-text {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 0.7em;
      text-shadow: 1px 1px 2px black;
    }
    /* ...existing CSS... */
    #inventory-list {
  display: flex; /* Enables Flexbox for this container */
  flex-direction: row; /* Arranges items horizontally */
  gap: 10px; /* Adds space between the items */
  flex-wrap: wrap; /* Wraps items to the next line if the screen is too narrow */
  justify-content: flex-start; /* Aligns items to the left side */
}

/* Update the inventory-item to no longer use flex for vertical spacing */
.inventory-item {
  display: flex; /* Keep this to arrange the item name and button */
  flex-direction: column;
  padding: 5px;
  border: 1px solid #555; /* Use a full border instead of border-bottom */
  border-radius: 3px;
}


.inventory-popup {
  position: absolute;
  bottom: 200px;
  right: 100px;
  width: 250px;
  max-height: 300px;
  background-color: #55260e;
  border: 2px solid black;
  color: white;
  padding: 10px;
  text-align: left;
  overflow-y: auto;
  z-index: 1000;
}

.item-use-button {
  font-family: "Press Start 2P", sans-serif;
  font-size: 0.7em;
  padding: 2px 5px;
  cursor: pointer;
}

  </style>
</head>
<body>
  <canvas id="game" width="640" height="480" tabindex="0"></canvas>

  <div id="game-hud">
    <div class="hud-section" id="stats">
      <p id="stats-button">Stats</p>
      <div id="stats-popup" class="stats-popup" style="display: none;">
        <h4>Player Stats</h4>
        <p>Level: <span id="popup-level"></span></p>
        <p>XP: <span id="popup-xp"></span></p>
        <p>Damage: <span id="popup-damage"></span></p>
      </div>
    </div>
    <div class="hud-section" id="player-status">
      <p>Player</p>
      <div id="hp-bar-container">
        <div id="hp-bar"></div>
        <div id="hp-text">8/8</div>
      </div>
    </div>
    <div class="hud-section" id="inventory">
      <p>Inventory</p>
    </div>
  </div>

  <div id="battle-overlay">
    <div id="enemy-display"></div>
    <div id="player-battle-status"></div>
    <div id="battle-controls">
      <button id="attack-button">Attack</button>
      <button id="special-attack-button-1">Extra Credits (100 STM)</button>
      <button id="special-attack-button-2">Plasma Blast (200 STM)</button>
      <button id="inventory-battle-button">Inventory</button>
    </div>
    <div id="inventory-battle-popup" class="inventory-popup" style="display: none;">
  <h4>Inventory</h4>
  <div id="inventory-list"></div>
</div>
  </div>
  
  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    
    canvas.focus();
    canvas.addEventListener('click', () => {
      canvas.focus();
    });

    let x = 150, y = 50;
    const speed = 20;
    const imageSize = 60;
    const hitboxWidth = 30;
    const hitboxHeight = 30;
    const hitboxOffsetX = (imageSize - hitboxWidth) / 2;
    const hitboxOffsetY = (imageSize - hitboxHeight) / 2;
    const useImage = true;
    const img = new Image();
    img.src = '8bit.png';
    const hpBar = document.getElementById('hp-bar');
    const hpText = document.getElementById('hp-text');
    let selectedEnemyIndex = 0;
    let isPowered = false;
    let tempText = "";
    let tempTextTimeout = null;
    let defeatedZone = null;
    let enemyAttackIntervalId = null;
    const ENEMY_ATTACK_DELAY = 2000;
    let staminaRegenIntervalId = null;
    let inventory = new Map();
let extraLifeTimerId = null;
    inventory.set("bandaid", 1);
inventory.set("emp_grenade", 1);
inventory.set("poison_vial", 1);
inventory.set("extra_life", 1);

    let playerStats = {
      level: 1,
      currentHp: 8,
      maxHp: 8,
      damage: 2,
      xp: 0,
      xpToNextLevel: 10,
      currentStamina: 50,
      maxStamina: 200,
    };

    let inBattle = false;

    const enemyTypes = {
      Dummy: { name: "Dummy", maxHp: 12, damage: 1, xpReward: 3 },
      Sniperbot: { name: "Sniper", maxHp: 20, damage: 1, xpReward: 5 }
    };
    
    const levels = [
      {
        bgSrc: "arcadebg.png",
        walls: [
          { x: 0, y: 0, width: 640, height: 20 },
          { x: 0, y: 460, width: 640, height: 20 },
          { x: 290, y: 150, width: 32, height: 200 },
          { x: 290, y: 150, width: 220, height: 20 },
          { x: 500, y: 150, width: 20, height: 200 },
          { x: 0, y: 0, width: 20, height: 480 },
        ],
        doors: [
          { x: 375, y: 340, width: 85, height: 10, destLevel: 1, destX: 300, destY: 375 }
        ],
        battleZones: [
          { x: 100, y: 100, width: 50, height: 50, encounter: [{ type: "Sniperbot" }] },
          { x: 400, y: 250, width: 70, height: 70, encounter: [{ type: "Sniperbot" }, { type: "Sniperbot" }] }
        ],
        interactables: []
      },
      {
        bgSrc: "arcadeinside.png",
        walls: [
          { x: 0, y: 0, width: 640, height: 32 },
          { x: 0, y: 460, width: 640, height: 20 },
          { x: 608, y: 0, width: 32, height: 480 },
          { x: 0, y: 0, width: 50, height: 480 },
        ],
        doors: [
          { x: 300, y: 450, width: 40, height: 60, destLevel: 0, destX: 400, destY: 400 }
        ],
        battleZones: [],
        interactables: [
          { name: "power_box", x: 20, y: 260, width: 100, height: 100, action: "power_on" },
          { name: "arcade_machine", x: 340, y: 80, width: 100, height: 100, action: "start_battle", encounter: [{ type: "Dummy" }] }
        ]
      }
    ];

    let currentLevelIndex = 0;
    let currentLevel = levels[currentLevelIndex];
    const bgImg = new Image();
    bgImg.src = currentLevel.bgSrc;
    bgImg.onload = function() { draw(); };

    let activeEnemies = [];

    function wrapText(context, text, x, y, maxWidth, lineHeight) {
      let words = text.split(' ');
      let line = '';
      for (let n = 0; n < words.length; n++) {
        let testLine = line + words[n] + ' ';
        let metrics = context.measureText(testLine);
        let testWidth = metrics.width;
        if (testWidth > maxWidth && n > 0) {
          context.fillText(line, x, y);
          line = words[n] + ' ';
          y += lineHeight;
        } else {
          line = testLine;
        }
      }
      context.fillText(line, x, y);
    }
    
    function showTemporaryText(message) {
      tempText = message;
      if (tempTextTimeout) clearTimeout(tempTextTimeout);
      tempTextTimeout = setTimeout(() => {
        tempText = "";
        draw();
      }, 3000);
    }

    function canGoBelow1Hp() {
  return extraLifeTimerId === null;
}

    function updateStamina(newStamina) {
      if (newStamina < 0) newStamina = 0;
      if (newStamina > playerStats.maxStamina) newStamina = playerStats.maxStamina;
      playerStats.currentStamina = newStamina;
    }

    function updateHp(newHealth) {
      if (newHealth < 0) newHealth = 0;
      if (newHealth > playerStats.maxHp) newHealth = playerStats.maxHp;
      playerStats.currentHp = newHealth;
      const newWidth = (playerStats.currentHp / playerStats.maxHp) * 100;
      hpBar.style.width = `${newWidth}%`;
      hpText.textContent = `${playerStats.currentHp}/${playerStats.maxHp}`;
    }

    function updateStatsPopup() {
      document.getElementById('popup-level').textContent = playerStats.level;
      document.getElementById('popup-xp').textContent = `${playerStats.xp} / ${playerStats.xpToNextLevel}`;
      document.getElementById('popup-damage').textContent = playerStats.damage;
    }
    
    function levelUp() {
      playerStats.level++;
      playerStats.xp -= playerStats.xpToNextLevel;
      playerStats.xpToNextLevel = Math.floor(playerStats.xpToNextLevel * 1.5);
      playerStats.maxHp += Math.floor(2 + (playerStats.level / 2));
      playerStats.damage += Math.floor(1 + (playerStats.level / 3));
      playerStats.currentHp = playerStats.maxHp;
      updateHp(playerStats.currentHp);
      updateStatsPopup();
    }

    function gainXP(amount) {
      playerStats.xp += amount;
      if (playerStats.xp >= playerStats.xpToNextLevel) {
        levelUp();
      }
      updateStatsPopup();
    }

    function removeZone(zone) {
      if (!zone) return;
      if (zone.type === 'battleZone') {
        const index = currentLevel.battleZones.indexOf(zone.object);
        if (index > -1) {
          currentLevel.battleZones.splice(index, 1);
        }
      } else if (zone.type === 'interactable') {
        const index = currentLevel.interactables.indexOf(zone.object);
        if (index > -1) {
          currentLevel.interactables.splice(index, 1);
        }
      }
    }
    
    function scaleEnemyStats(baseStats) {
      return {
        ...baseStats,
        maxHp: baseStats.maxHp + Math.floor(currentLevelIndex / 2),
        damage: baseStats.damage + Math.floor(currentLevelIndex / 3)
      };
    }

    function findBattleZone(checkX, checkY) {
      const hitboxX = checkX + hitboxOffsetX;
      const hitboxY = checkY + hitboxOffsetY;
      if (!currentLevel.battleZones) return null;
      for (const zone of currentLevel.battleZones) {
        if (
          hitboxX < zone.x + zone.width &&
          hitboxX + hitboxWidth > zone.x &&
          hitboxY < zone.y + zone.height &&
          hitboxY + hitboxHeight > zone.y
        ) {
          return zone;
        }
      }
      return null;
    }

function drawInventoryBattlePopup() {
  const inventoryList = document.getElementById('inventory-list');
  inventoryList.innerHTML = ''; // Clear previous list

  if (inventory.size === 0 || Array.from(inventory.values()).every(q => q === 0)) {
    inventoryList.innerHTML = '<p>Inventory is empty.</p>';
    return;
  }

  inventory.forEach((quantity, itemName) => {
    if (quantity > 0) {
      const itemElement = document.createElement('div');
      itemElement.className = 'inventory-item';
      itemElement.innerHTML = `<span>${itemName.replace('_', ' ')} (${quantity})</span>`;

      const useButton = document.createElement('button');
      useButton.textContent = 'Use';
      useButton.className = 'item-use-button';
      useButton.onclick = () => useItem(itemName);

      itemElement.appendChild(useButton);
      inventoryList.appendChild(itemElement);
    }
  });
}

// New function to handle item usage
function useItem(itemName) {
  if (inventory.get(itemName) > 0) {
    if (itemName === 'bandaid') {
      const healAmount = Math.ceil(playerStats.maxHp * 0.33);
      updateHp(playerStats.currentHp + healAmount);
      showTemporaryText(`Used a Bandage to heal for ${healAmount} HP!`);
    } else if (itemName === 'emp_grenade') {
      // Logic for stunning enemies
      activeEnemies.forEach(enemy => {
        if (enemy.name !== "Dummy") { // Exclude bosses and dummies
          enemy.stunned = true;
        }
      });
      setTimeout(() => {
        activeEnemies.forEach(enemy => enemy.stunned = false);
      }, 4000); // Stun for 4 seconds
      showTemporaryText(`Used an EMP Grenade! All enemies stunned for 4 seconds!`);
    } else if (itemName === 'poison_vial') {
      // Logic for poisoning enemies
      const poisonDamagePerTick = Math.ceil(5 * playerStats.damage / 100);
      activeEnemies.forEach(enemy => {
        if (enemy.name !== "Dummy") {
          enemy.poisoned = true;
          let poisonTimer = 0;
          const poisonInterval = setInterval(() => {
            if (poisonTimer >= 3000) { // Poison for 3 seconds
              clearInterval(poisonInterval);
              enemy.poisoned = false;
            } else {
              enemy.currentHp -= poisonDamagePerTick;
              if (enemy.currentHp < 0) enemy.currentHp = 0;
              drawBattleUI();
            }
            poisonTimer += 500;
          }, 500);
        }
      });
      showTemporaryText(`Used a Poison Vial! Enemies are taking poison damage!`);
    } else if (itemName === 'extra_life') {
      // Logic for extra life
      if (extraLifeTimerId) {
        clearTimeout(extraLifeTimerId);
        extraLifeTimerId = null;
      }
      showTemporaryText(`Used an Extra Life! You have 3 seconds of invincibility!`);
      extraLifeTimerId = setTimeout(() => {
        extraLifeTimerId = null;
      }, 3000); // 3 seconds of invincibility
    }

    // Decrement the item count
    inventory.set(itemName, inventory.get(itemName) - 1);
  
    
    function drawBattleUI() {
      const battleOverlay = document.getElementById('battle-overlay');
      battleOverlay.style.display = 'flex';
      const enemyDisplay = document.getElementById('enemy-display');
      enemyDisplay.innerHTML = '';
      activeEnemies.forEach((enemy, index) => {
        const enemyButton = document.createElement('button');
        enemyButton.innerHTML = `<h3>${enemy.name}</h3><p>HP: ${enemy.currentHp}/${enemy.maxHp}</p>`;
        enemyButton.className = 'enemy-target';
        enemyButton.dataset.enemyIndex = index;
        enemyDisplay.appendChild(enemyButton);
        if (index === selectedEnemyIndex) {
          enemyButton.classList.add('selected');
        }
      });
    }

    function drawPlayerBattleStatus() {
      const playerBattleStatusDiv = document.getElementById('player-battle-status');
      playerBattleStatusDiv.innerHTML = '';
      const playerName = document.createElement('p');
      playerName.textContent = `8-Bit`;
      
      const hpContainer = document.createElement('div');
      hpContainer.className = 'hp-bar-container';
      const hpBar = document.createElement('div');
      hpBar.className = 'hp-bar';
      hpBar.style.width = `${(playerStats.currentHp / playerStats.maxHp) * 100}%`;
      const hpText = document.createElement('div');
      hpText.className = 'hp-text';
      hpText.textContent = `${playerStats.currentHp}/${playerStats.maxHp}`;
      hpContainer.appendChild(hpBar);
      hpContainer.appendChild(hpText);
      playerBattleStatusDiv.appendChild(playerName);
      playerBattleStatusDiv.appendChild(hpContainer);
      
      const staminaContainer = document.createElement('div');
      staminaContainer.className = 'hp-bar-container';
      const staminaBar = document.createElement('div');
      staminaBar.className = 'hp-bar';
      staminaBar.style.width = `${(playerStats.currentStamina / playerStats.maxStamina) * 100}%`;
      staminaBar.style.backgroundColor = '#00FFFF';
      const staminaText = document.createElement('div');
      staminaText.className = 'hp-text';
      staminaText.textContent = `${playerStats.currentStamina}/${playerStats.maxStamina}`;
      staminaContainer.appendChild(staminaBar);
      staminaContainer.appendChild(staminaText);
      playerBattleStatusDiv.appendChild(staminaContainer);
    }

    function takeTurn() {
  if (!inBattle) return;
  activeEnemies.forEach(enemy => {
    if (!enemy.stunned) {
      playerStats.currentHp -= enemy.damage;
    }
  });

  // Check for Extra Life invincibility
  if (!canGoBelow1Hp() && playerStats.currentHp <= 1) {
      playerStats.currentHp = 1;
  }
  
  updateHp(playerStats.currentHp);
  drawBattleUI();
  drawPlayerBattleStatus();
  if (playerStats.currentHp <= 0) {
    endBattle('lose');
  }
}

    function endBattle(outcome) {
      inBattle = false;
      document.getElementById('battle-overlay').style.display = 'none';
      
      if (staminaRegenIntervalId) {
        clearInterval(staminaRegenIntervalId);
        staminaRegenIntervalId = null;
      }
      
      if (enemyAttackIntervalId) {
        clearInterval(enemyAttackIntervalId);
        enemyAttackIntervalId = null;
      }

      if (outcome === 'win') {
        let totalXp = activeEnemies.reduce((sum, enemy) => sum + (enemy.xpReward || 0), 0);
        gainXP(totalXp);
        
        playerStats.currentHp = playerStats.maxHp;
        updateHp(playerStats.currentHp);
        
        if (defeatedZone) {
          removeZone(defeatedZone);
        }
      } else if (outcome === 'lose') {
        loadLevel(0, 150, 50);
      }
      
      activeEnemies = [];
      defeatedZone = null;
      draw();
      document.getElementById('player-battle-status').innerHTML = '';
    }

    function initiateBattle(zoneType, zoneObject) {
      inBattle = true;
      defeatedZone = { type: zoneType, object: zoneObject };
      
      staminaRegenIntervalId = setInterval(() => {
        updateStamina(playerStats.currentStamina + 1);
        drawPlayerBattleStatus();
      }, 100);
      
      let encounter = zoneObject.encounter;

      activeEnemies = encounter.map(enemyData => {
        const baseStats = enemyTypes[enemyData.type];
        const scaledStats = scaleEnemyStats(baseStats);
        return {
          ...enemyData,
          ...scaledStats,
          currentHp: scaledStats.maxHp
        };
      });
      selectedEnemyIndex = 0;
      drawBattleUI();
      drawPlayerBattleStatus();
      enemyAttackIntervalId = setInterval(takeTurn, ENEMY_ATTACK_DELAY);
    }

    function checkInteraction(checkX, checkY) {
      if (currentLevel.interactables) {
        const hitboxX = checkX + hitboxOffsetX;
        const hitboxY = checkY + hitboxOffsetY;
        for (const object of currentLevel.interactables) {
          if (
            hitboxX < object.x + object.width &&
            hitboxX + hitboxWidth > object.x &&
            hitboxY < object.y + object.height &&
            hitboxY + hitboxHeight > object.y
          ) {
            return object;
          }
        }
      }
      return null;
    }

    function handleInteraction(object) {
      if (object.name === "power_box") {
        if (!isPowered) {
          isPowered = true;
          showTemporaryText("You pressed something on the box. The lights flicker on.");
          draw();
        } else {
          showTemporaryText("The power is already on.");
        }
      } else if (object.name === "arcade_machine") {
        if (isPowered) {
          initiateBattle('interactable', object);
        } else {
          showTemporaryText("The machine is turned off...");
        }
      }
    }

    document.getElementById('attack-button').addEventListener('click', () => {
      if (!inBattle || !activeEnemies.length) return;
      const targetEnemy = activeEnemies[selectedEnemyIndex];
      if (!targetEnemy) return;
      targetEnemy.currentHp -= playerStats.damage;
      if (targetEnemy.currentHp < 0) targetEnemy.currentHp = 0;

      const remainingEnemies = activeEnemies.filter(enemy => enemy.currentHp > 0);
      
      if (remainingEnemies.length === 0) {
        endBattle('win');
        return;
      }
      activeEnemies = remainingEnemies;
      if (selectedEnemyIndex >= activeEnemies.length) {
        selectedEnemyIndex = 0;
      }
      drawBattleUI();
      drawPlayerBattleStatus();
    });

    document.getElementById('special-attack-button-1').addEventListener('click', () => {
      const staminaCost = 100;
      if (!inBattle || !activeEnemies.length || playerStats.currentStamina < staminaCost) {
        showTemporaryText("Not enough stamina!");
        return;
      }

      updateStamina(playerStats.currentStamina - staminaCost);
      const targetEnemy = activeEnemies[selectedEnemyIndex];
      if (!targetEnemy) return;

      targetEnemy.currentHp -= (playerStats.damage * 10);
      if (targetEnemy.currentHp < 0) targetEnemy.currentHp = 0;

      const remainingEnemies = activeEnemies.filter(enemy => enemy.currentHp > 0);
      if (remainingEnemies.length === 0) {
        endBattle('win');
        return;
      }
      activeEnemies = remainingEnemies;
      if (selectedEnemyIndex >= activeEnemies.length) {
        selectedEnemyIndex = 0;
      }
      drawBattleUI();
      drawPlayerBattleStatus();
    });

    document.getElementById('special-attack-button-2').addEventListener('click', () => {
  const staminaCost = 200;
  if (!inBattle || playerStats.currentStamina < staminaCost) {
    showTemporaryText("Not enough stamina!");
    return;
  }
  
  // Deduct stamina
  updateStamina(playerStats.currentStamina - staminaCost);
  
  // Create a new array to hold the enemies that survive the attack
  let remainingEnemies = [];
  
  // Iterate over all active enemies
  activeEnemies.forEach(enemy => {
    // Calculate and apply damage (20x player's base damage)
    enemy.currentHp -= (playerStats.damage * 20);
    if (enemy.currentHp < 0) enemy.currentHp = 0;
    
    // Add the enemy to the remainingEnemies array if they survive
    if (enemy.currentHp > 0) {
      remainingEnemies.push(enemy);
    }
  });

  // Check if all enemies were defeated
  if (remainingEnemies.length === 0) {
    endBattle('win');
    return;
  }
  
  // Update the activeEnemies array with only the remaining enemies
  activeEnemies = remainingEnemies;
  
  // Reset target selection if needed
  if (selectedEnemyIndex >= activeEnemies.length) {
    selectedEnemyIndex = 0;
  }
  
  // Update the UI
  drawBattleUI();
  drawPlayerBattleStatus();
});


    document.getElementById('enemy-display').addEventListener('click', (event) => {
      const button = event.target.closest('.enemy-target');
      if (button) {
        selectedEnemyIndex = parseInt(button.dataset.enemyIndex);
        drawBattleUI();
      }
    });

    document.getElementById('stats-button').addEventListener('click', () => {
      const statsPopup = document.getElementById('stats-popup');
      if (statsPopup.style.display === 'none') {
        updateStatsPopup();
        statsPopup.style.display = 'block';
      } else {
        statsPopup.style.display = 'none';
      }
    });

    updateHp(playerStats.currentHp);

    document.getElementById('inventory-battle-button').addEventListener('click', () => {
  const inventoryPopup = document.getElementById('inventory-battle-popup');
  
  if (inventoryPopup.style.display === 'none') {
    drawInventoryBattlePopup();
    inventoryPopup.style.display = 'block';
  } else {
    inventoryPopup.style.display = 'none';
    if (staminaRegenIntervalId === null) {
      staminaRegenIntervalId = setInterval(() => {
        updateStamina(playerStats.currentStamina + 1);
        drawPlayerBattleStatus();
      }, 100);
    }
    if (enemyAttackIntervalId === null) {
      enemyAttackIntervalId = setInterval(takeTurn, ENEMY_ATTACK_DELAY);
    }
  }
});

    function loadLevel(index, newX, newY) {
      currentLevelIndex = index;
      currentLevel = levels[currentLevelIndex];
      bgImg.src = currentLevel.bgSrc;
      x = newX;
      y = newY;
      draw();
    }

    function isCollidingWithWall(newX, newY) {
      const newHitboxX = newX + hitboxOffsetX;
      const newHitboxY = newY + hitboxOffsetY;
      for (const wall of currentLevel.walls) {
        if (
          newHitboxX < wall.x + wall.width &&
          newHitboxX + hitboxWidth > wall.x &&
          newHitboxY < wall.y + wall.height &&
          newHitboxY + hitboxHeight > wall.y
        ) {
          return true;
        }
      }
      return false;
    }

    function checkDoorCollision(newX, newY) {
      const newHitboxX = newX + hitboxOffsetX;
      const newHitboxY = newY + hitboxOffsetY;
      for (const door of currentLevel.doors) {
        if (
          newHitboxX < door.x + door.width &&
          newHitboxX + hitboxWidth > door.x &&
          newHitboxY < door.y + door.height &&
          newHitboxY + hitboxHeight > door.y
        ) {
          return door;
        }
      }
      return null;
    }

    function draw() {
      if (inBattle) return;
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.drawImage(bgImg, 0, 0, canvas.width, canvas.height);
      ctx.fillStyle = "rgba(0,0,0,0.0)";
      for (const wall of currentLevel.walls) {
        ctx.fillRect(wall.x, wall.y, wall.width, wall.height);
      }
      if (useImage && img.complete && img.naturalWidth > 0) {
        ctx.drawImage(img, x, y, imageSize, imageSize);
      } else {
        ctx.fillStyle = "#0090ff";
        ctx.fillRect(x, y, imageSize, imageSize);
      }
      ctx.fillStyle = "rgba(0,0,0,0.0)";
      ctx.fillRect(x + hitboxOffsetX, y + hitboxOffsetY, hitboxWidth, hitboxHeight);
      if (tempText) {
        ctx.fillStyle = "white";
        ctx.font = "12px 'Press Start 2P'";
        ctx.textAlign = "center";
        const maxWidth = canvas.width - 40;
        const lineHeight = 15;
        const startY = canvas.height - 100;
        wrapText(ctx, tempText, canvas.width / 2, startY, maxWidth, lineHeight);
      }
    }

    canvas.addEventListener('keydown', function(e) {
      if (inBattle) return;
      if (!bgImg.complete || bgImg.naturalWidth === 0) return;
      let nextX = x, nextY = y;
      const key = e.key.toLowerCase();
      switch(key) {
        case 'arrowup':
        case 'arrowdown':
        case 'arrowleft':
        case 'arrowright':
        case 'w':
        case 'a':
        case 's':
        case 'd':
          e.preventDefault();
          break;
        case 'x':
          e.preventDefault();
          const interactableObject = checkInteraction(x, y);
          if (interactableObject) {
            handleInteraction(interactableObject);
          }
          return;
      }
      if (key === 'arrowleft' || key === 'a') nextX -= speed;
      if (key === 'arrowright' || key === 'd') nextX += speed;
      if (key === 'arrowup' || key === 'w') nextY -= speed;
      if (key === 'arrowdown' || key === 's') nextY += speed;
      if (!isCollidingWithWall(nextX, nextY)) {
        const door = checkDoorCollision(nextX, nextY);
        if (door) {
          loadLevel(door.destLevel, door.destX, door.destY);
          return;
        }
        const battleZone = findBattleZone(nextX, nextY);
        if (battleZone) {
          initiateBattle('battleZone', battleZone);
          return;
        }
        x = nextX;
        y = nextY;
      }
      draw();
    });
  </script>
</body>
</html>
